var documenterSearchIndex = {"docs":
[{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"EditURL = \"lit-04-3DSliceSelective.jl\"","category":"page"},{"location":"tutorial/04-3DSliceSelective/#Slice-Selective-Acquisition-of-3D-Phantom","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"","category":"section"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"using KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"While in the previous examples we simulated using hard RF pulses, in this demonstration we will illustrate the principles of slice selection. First, let's import a 3D phantom, in this case a brain slab (thickness of 2mathrmcm), by calling the function brain_phantom3D.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"obj = brain_phantom3D()\nobj.Δw .= 0 # Removes the off-resonance\np1 = plot_phantom_map(obj, :T2 ; height=400)\nsavefig(p1, \"../assets/3-phantom.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-phantom.html\" style=\"width:50%; height:420px;\"></object></center>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Now, we are going to import a sequence which acquires 3 slices in the longitudinal axis. Note that the sequence contains three EPIs to acquire 3 slices of the phantom.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_multislice.seq\")\nseq = read_seq(seq_file)\np2 = plot_seq(seq; range=[0,10], height=400)\nsavefig(p2, \"../assets/3-seq.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"We can take a look to the slice profiles by using the function simulate_slice_profile:","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"z = range(-2., 2., 200) * 1e-2; # -2 to 2 cm\nrf1, rf2, rf3 = findall(is_RF_on.(seq))\nM1 = simulate_slice_profile(seq[rf1]; z)\nM2 = simulate_slice_profile(seq[rf2]; z)\nM3 = simulate_slice_profile(seq[rf3]; z)\n\nusing PlotlyJS # hide\npa = scatter(x=z*1e2, y=abs.(M1.xy), name=\"Slice 1\") # hide\npb = scatter(x=z*1e2, y=abs.(M2.xy), name=\"Slice 2\") # hide\npc = scatter(x=z*1e2, y=abs.(M3.xy), name=\"Slice 3\") # hide\npd = plot([pa,pb,pc], Layout(xaxis=attr(title=\"z [cm]\"), height=300,margin=attr(t=40,l=0,r=0), title=\"Slice profiles for the slice-selective sequence\")) # hide\nsavefig(pd, \"../assets/3-profile.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Now let's simulate the acquisition. Notice the three echoes, one for every slice excitation.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"raw = simulate(obj, seq, sys; sim_params=Dict{String,Any}(\"Nblocks\"=>20))\np3 = plot_signal(raw; slider=false, height=300)\nsavefig(p3, \"../assets/3-signal.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Finally, we reconstruct the acquiered images.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\n\n# Setting up the reconstruction parameters and perform reconstruction\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the slices\np4 = plot_image(abs.(image[:, :, 1]); height=360, title=\"Slice 1\")\np5 = plot_image(abs.(image[:, :, 2]); height=360, title=\"Slice 2\")\np6 = plot_image(abs.(image[:, :, 3]); height=360, title=\"Slice 3\")\nsavefig(p4, \"../assets/3-recon1.html\") # hide\nsavefig(p5, \"../assets/3-recon2.html\") # hide\nsavefig(p6, \"../assets/3-recon3.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-recon1.html\" style=\"width:50%; height:380px;\"></object><object type=\"text/html\" data=\"../../assets/3-recon2.html\" style=\"width:50%; height:380px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-recon3.html\" style=\"width:50%; height:380px;\"></object></center>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. ","category":"page"},{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"Files matching the pluto-*.jl pattern anywhere in examples/4.reproducible_notebooks will be included.","category":"page"},{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"All files included in this folder will be ignored.","category":"page"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/#Understanding-basic-MRI-sequences","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"","category":"section"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"<iframe type=\"text/html\" src=\"../01-gradient-echo-spin-echo.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"CurrentModule = KomaMRIPlots","category":"page"},{"location":"reference/5-koma-plots/#Plotting-Phantom","page":"KomaMRIPlots","title":"Plotting Phantom","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"plot_phantom_map","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_phantom_map","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_phantom_map","text":"p = plot_phantom_map(obj::Phantom, key::Symbol; kwargs...)\n\nPlots a phantom map for a specific spin parameter given by key.\n\nArguments\n\nobj: (::Phantom) Phantom struct\nkey: (::Symbol, opts: [:ρ, :T1, :T2, :T2s, :x, :y, :z]) symbol for   displaying different parameters of the phantom spins\n\nKeywords\n\nheight: (::Integer, =600) plot height\nwidth: (::Integer, =nothing) plot width\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nview_2d: (::Bool, =false) boolean to indicate whether to use a 2D scatter plot\ncolorbar: (::Bool, =true) boolean to indicate whether to display a colorbar\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the phantom map for a specific spin parameter\n\nReferences\n\nColormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).\n\nExamples\n\njulia> obj2D, obj3D = brain_phantom2D(), brain_phantom3D();\n\njulia> plot_phantom_map(obj2D, :ρ)\n\njulia> plot_phantom_map(obj3D, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-Sequence","page":"KomaMRIPlots","title":"Plotting Sequence","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"plot_seq\nplot_kspace\nplot_M0\nplot_M1\nplot_M2\nplot_eddy_currents\nplot_slew_rate\nplot_seqd","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seq","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seq","text":"p = plot_seq(seq::Sequence; kwargs...)\n\nPlots a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\nfreq_in_phase: (::Bool, =true) Include FM modulation in RF phase\ngl: (::Bool, =false) use PlotlyJS.scattergl backend (faster)\nmax_rf_samples: (::Integer, =100) maximum number of RF samples\nshow_adc: (::Bool, =false) plot ADC samples with markers\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_kspace","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_kspace","text":"p = plot_kspace(seq::Sequence; width=nothing, height=nothing, darkmode=false)\n\nPlots the k-space of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the k-space of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M0","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M0","text":"p = plot_M0(seq::Sequence; kwargs...)\n\nPlots the zero order moment (M0) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M0 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M0(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M1","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M1","text":"p = plot_M1(seq::Sequence; kwargs...)\n\nPlots the first order moment (M1) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M1 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M1(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M2","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M2","text":"p = plot_M2(seq::Sequence; kwargs...)\n\nPlots the second order moment (M2) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M2 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M2(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_eddy_currents","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_eddy_currents","text":"p = plot_eddy_currents(seq::Sequence, λ; kwargs...)\n\nPlots the eddy currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nλ: (::Real, [s]) time constant for the decay of Eddy currents\n\nKeywords\n\nα: (::Vector{Real}, =ones(size(λ))) eddy currents factors\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Eddy currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_eddy_currents(seq, 80e-3)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_slew_rate","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_slew_rate","text":"p = plot_slew_rate(seq::Sequence; kwargs...)\n\nPlots the slew rate currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the slew rate currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_slew_rate(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seqd","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seqd","text":"p = plot_seqd(seq::Sequence; sampling_params=KomaMRIBase.default_sampling_params())\n\nPlots a sampled sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nsampling_params: (::Dict{String,Any}(), =KomaMRIBase.default_sampling_params()) dictionary of   sampling parameters\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the sampled Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seqd(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-RawAcquisitionData","page":"KomaMRIPlots","title":"Plotting RawAcquisitionData","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"plot_signal","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_signal","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_signal","text":"p = plot_signal(raw::RawAcquisitionData; kwargs...)\n\nPlots a raw signal in ISMRMRD format.\n\nArguments\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct (raw signal in ISMRMRD format)\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_sim_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the raw signal\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-images","page":"KomaMRIPlots","title":"Plotting images","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"plot_image","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_image","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_image","text":"p = plot_image(image; height, width, zmin, zmax, darkmode, title)\n\nPlots an image matrix.\n\nArguments\n\nimage: (::Matrix{Number}) image matrix\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nzmin: (::Real, =minimum(abs.(image[:]))) reference value for minimum color\nzmax: (::Real, =maximum(abs.(image[:]))) reference value for maximum color\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the image matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Others","page":"KomaMRIPlots","title":"Others","text":"","category":"section"},{"location":"reference/5-koma-plots/","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"plot_dict","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_dict","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_dict","text":"str = plot_dict(dict::Dict)\n\nGenerates an HTML table based on the dictionary dict.\n\nArguments\n\ndict: (::Dict) dictionary\n\nReturns\n\nstr: (::String) dictionary as an HTML table\n\n\n\n\n\n","category":"function"},{"location":"explanation/3-simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"explanation/3-simulation/#General-Overview","page":"Simulation","title":"General Overview","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"KomaMRI simulates the magnetization of each spin of a Phantom for variable magnetic fields given by a Sequence. It is assumed that a single spin is independent of the state of the other spins in the system (a key feature that enables parallelization). Furthermore, there are defined two regimes in the Sequence: excitation and precession. During the latter, the excitation fields are nulled and are useful for simplifying some physical equations.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The are more internal considerations in the KomaMRI implementation. The Figure 1 summarizes the functions called to perform the simulation.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<center><img width=\"100%\" src=\"../../assets/koma-solution.svg\"></center>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"Figure 1: The sequence seq is discretized after calculating the required time points in the wrapper function simulate. The time points are then divided into Nblocks to reduce the amount of memory used. The phantom obj is divided into Nthreads, and KomaMRI will use either run_spin_excitation! or run_spin_precession! depending on the regime. If an ADC object is present, the simulator will add the signal contributions of each thread to construct the acquired signal sig[t]. All the parameters: Nthreads, Nblocks, Δt_rf, and Δt, are passed through a dictionary called sim_params as an optional parameter of the simulate function.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"From the programming perspective, it is needed to call the simulate function with the sim_params dictionary keyword argument. A user can change the values of the following keys:","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"Parameter Description\n\"return_type\" defines the output of the simulate function. Possible values are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco RawAcquisitionData, the signal values, and the last magnetization state of the simulation, respectively.\n\"sim_method\" defines the type of simulation. The default value is Bloch(), but you can alternatively use the BlochDict() simulation method. Moreover, you have the flexibility to create your own methods without altering the KomaMRI source code; for further details, refer to the Simulation Method Extensibility section.\n\"Δt\" raster time for gradients.\n\"Δt_rf\" raster time for RFs.\n\"precision\" defines the floating-point simulation precision. You can choose between \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively. It's important to note that, especially for GPU operations, using \"f32\" is generally much faster.\n\"Nblocks\" divides the simulation into a specified number of time blocks. This parameter is designed to conserve RAM resources, as KomaMRI computes a series of simulations consecutively, each with the specified number of blocks determined by the value of \"Nblocks\".\n\"Nthreads\" divides the Phantom into a specified number of threads. Because spins are modeled independently of each other, KomaMRI can solve simulations in parallel threads, speeding up the execution time.\n\"gpu\" is a boolean that determines whether to use GPU or CPU hardware resources, as long as they are available on the host computer.\n\"gpu_device\" sets the index ID of the available GPU in the host computer.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"For instance, if you want to perform a simulation on the CPU with float64 precision using the BlochDict() method (assuming you have already defined obj and seq), you can do so like this:","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"# Set non-default simulation parameters and run simulation\nsim_params = KomaMRICore.default_sim_params() \nsim_params[\"gpu\"] = false\nsim_params[\"precision\"] = \"f64\"\nsim_params[\"sim_method\"] = BlochDict()\nraw = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"Additionally, the user must be aware of the functions run_spin_excitation! and run_spin_precession! which defines the algorithm for excitation and precession regimes respectively and can be changed by the user without modifying the source code (more details at Simulation Method Extensibility).","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"Previous simulation, the Sequence is discretized to consider specific time points which are critical for simulation. The user can control the time between intermediate gradient samples with the parameter Δt. Similarly, the parameter Δt_rf manages the time between RF samples, and can be relatively large for 2D imaging where the slice profile is less relevant.","category":"page"},{"location":"explanation/3-simulation/#Computation-Efficiency","page":"Simulation","title":"Computation Efficiency","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"To reduce the memory usage of our simulator, we subdivided time into Nblocks. KomaMRI classifies each block in either the excitation regime or the precession regime before the simulation.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"We increased the simulation speed by separating the calculations into Nthreads and then performing the GPU parallel operations with CUDA.jl . This separation is possible as all magnetization vectors are independent of one another.","category":"page"},{"location":"explanation/3-simulation/#Simulation-Method-Extensibility","page":"Simulation","title":"Simulation Method Extensibility","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"In Julia, functions use different methods based on the input types via multiple dispatch. We used this to specialize the simulation functions for a given sim_method <:SimulationMethod specified in sim_params. For a given simulation method, the function initialize_spin_state outputs a variable Xt <: SpinStateRepresentation that is passed through the simulation (Figure 1). For the default simulation method Bloch, the spin state is of type Mag, but can be extended to a custom representation, like for example EPGs44 or others. Then, the functions run_spin_excitation! and run_spin_precession! can be described externally for custom types sim_method and Xt, extending Koma’s functionalities without the need of modifying the source code and taking advantage of all of Koma’s features.","category":"page"},{"location":"explanation/3-simulation/#Bloch-Simulation-Method","page":"Simulation","title":"Bloch Simulation Method","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"This is the default simulation method used by KomaMRI, however it can always be specified by setting the sim_method = Bloch() entry of the sim_params dictionary. In the following subsection, we will explain the physical and mathematical background and some considerations and assumptions that enables to speed up the simulation.","category":"page"},{"location":"explanation/3-simulation/#Physical-and-Mathematical-Background","page":"Simulation","title":"Physical and Mathematical Background","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The Bloch method of KomaMRI simulates the magnetization of each spin by solving the Bloch equations in the rotating frame:","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag1\n\nfracmathrmd boldsymbolMmathrmd t =\n  gamma boldsymbolM times boldsymbolB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1 \n\nendalign","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"with gamma the gyromagnetic ratio, boldsymbolM = M_x M_y M_z^T the magnetization vector, and","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"boldsymbolB = B_1x(t) B_1y(t) boldsymbolG(t) cdot boldsymbolx + Delta omega(t)^T","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"the effective magnetic field. M_0 is the proton density, T_1 and T_2 are the relaxation times, and Delta omega is the off-resonance, for each position.","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The Bloch Simulation Method also uses the technique of operator splitting to simplify the solution of Equation (1). This reflects mathematically the intuition of separating the Bloch equations in a rotation operator described by","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag2\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n 0            gamma B_z  -gamma B_y \n-gamma B_z   0            gamma B_x \n gamma B_y  -gamma B_x   0\nendbmatrix\nboldsymbolM \n\nendalign","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"and a relaxation operator described by","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag3\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n-tfrac1T_2  0  0 \n0  -tfrac1T_2  0 \n0  0  -tfrac1T_1\nendbmatrix\nboldsymbolM\n+\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix \n\nendalign","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The evolution of the magnetization can then be described as a two-step process for each time step Delta t (Figure 2).","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<p align=\"center\">\n<figure>\n  <img width=\"60%\" src=\"../../assets/block-equation-intuition.svg\">\n  <figcaption><b>Figure 2</b>: Solution of the Bloch equations for one time step can be described by (2) a rotation and (3) a relaxation step.</figcaption>\n</figure>\n</p>","category":"page"},{"location":"explanation/3-simulation/#Bloch()-Method-Example","page":"Simulation","title":"Bloch() Method Example","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"We will consider an RF pulse that excites a phantom with 3 spins, and then we acquire the data:","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<details><summary>View code</summary>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"# Import modules\nusing KomaMRI\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"</details>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The resulting signal from the Bloch() method is the sum of magnetizations in the transverse plane (x, y):","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"# Configure Bloch() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = Bloch()\nsig = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot(abs.(sig[:,1,1]))","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/3-simulation/#BlochDict-Simulation-Method","page":"Simulation","title":"BlochDict Simulation Method","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"This is another simulation method defined in the source code of KomaMRI. You can specify it by setting the sim_method = BlochDict() entry in the sim_params dictionary. Additionally, it offers the option to save the resulting signal in the z-component by using sim_method = BlochDict(save_Mz=true). This method allows you to store the magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z) if specified.","category":"page"},{"location":"explanation/3-simulation/#BlochDict()-Method-Example","page":"Simulation","title":"BlochDict() Method Example","text":"","category":"section"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"We are going to consider the same setup as in the Bloch() Method Example. This includes the same excitation, acquisition, and the same 3-spin phantom:","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<details><summary>View code</summary>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"# Import modules\nusing KomaMRI, PlotlyJS\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"</details>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"The resulting signal from the BlochDict() method comprises the individual magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z):","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"# Configure BlochDict() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = BlochDict(save_Mz=true)\nsig = simulate(obj, seq, sys; sim_params)\n\n# Define the plots for traverse and longitudinal magnetizations\npxy = plot(abs.(sig[:,:,1]));\npz = plot(abs.(sig[:,:,2]));","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"julia> [pxy pz]","category":"page"},{"location":"explanation/3-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-blochdict-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Create-Your-Own-Phantom","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In this section, we will create a custom Phantom struct. While the example is presented in 2D, the concepts discussed here can be readily extended to 3D phantoms.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In KomaMRI, the creation of a Phantom struct involves defining spin position arrays (x, y, z) and spin property arrays. The indices of these arrays are then associated with independent spins.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"For instance, you can create a Phantom with one spin like so:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define arrays of positions (spin at zero position)\nx = [0.0]\ny = [0.0]\nz = [0.0]\n\n# Define arrays of properties (for CSF tissue)\nρ = [1.0]\nT1 = [2.569]\nT2 = [0.329]\nT2s = [0.058]\n\n# Define the phantom\nspin = Phantom(name=\"spin\", x=x, y=y, z=z, ρ=ρ, T1=T1, T2=T2, T2s=T2s)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Phantom{Float64}\n  name: String \"spin\"\n  x: Array{Float64}((1,)) [0.0]\n  y: Array{Float64}((1,)) [0.0]\n  z: Array{Float64}((1,)) [0.0]\n  ρ: Array{Float64}((1,)) [1.0]\n  T1: Array{Float64}((1,)) [2.569]\n  T2: Array{Float64}((1,)) [0.329]\n  T2s: Array{Float64}((1,)) [0.058]\n  Δw: Array{Float64}((1,)) [0.0]\n  Dλ1: Array{Float64}((1,)) [0.0]\n  Dλ2: Array{Float64}((1,)) [0.0]\n  Dθ: Array{Float64}((1,)) [0.0]\n  ux: #122 (function of type KomaMRICore.var\"#122#136\")\n  uy: #123 (function of type KomaMRICore.var\"#123#137\")\n  uz: #124 (function of type KomaMRICore.var\"#124#138\")","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"You can add more properties to the Phantom, such as off-resonance, diffusion parameters, and even functions of motion. However, we won't be utilizing them (except for the off-resonance parameter) to maintain simplicity.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"If you are familiar with the MRI world, you likely have a 2D or 3D array, where each element contains an ID number identifying a different class of tissue. In this setup, the array axes represent spatial positions, while the elements are used for tissue identification.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In this example, we will utilize a .mat file containing arrays with such arrangements. The file is readily available upon installing KomaMRI. Let's read the file and store the 2D data in an array called class:\"","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Import necessary modules\nusing KomaMRI, MAT\n\n# Get data from a .mat file\npath_koma = dirname(dirname(pathof(KomaMRI)))\npath_phantom_mat = joinpath(path_koma, \"KomaMRIBase\", \"src\", \"datatypes\", \"phantom\", \"pelvis2D.mat\")\ndata = MAT.matread(path_phantom_mat)\nclass = data[\"pelvis3D_slice\"]","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"You can visualize the tissue map using the plot_image function:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"plot_image(class)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/create-your-own-phantom-class-map.html\" style=\"width:100%; height:620px;\"></object></center>","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Let's define the position arrays. You need to know the distance between the spins in the original array (in this case, it is 0.5mm), and then you can determine all the positions like this (the z-component is not calculated since this is a 2D example):","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define spin position arrays\nΔx = .5e-3                  # 0.5mm\nM, N = size(class)          # Number of spins in x and y\nFOVx = (M-1)*Δx             # Field of view in x\nFOVy = (N-1)*Δx             # Field of view in y\nx = -FOVx/2:Δx:FOVx/2       # x spin coordinates vector\ny = -FOVy/2:Δx:FOVy/2       # y spin coordinates vector\nx, y = x .+ y'*0, x*0 .+ y' # x and y grid points","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Now, let's define the arrays for the properties. It's essential to have prior knowledge of the property values for different tissue classes. For example, for soft tissue, we use ρ = 0.9, T1 = 1200 * 1e-3, T2 = 80 * 1e-3, and T2s = 80 * 1e-3. Additionally, we create an array mask to identify the location of a tissue's ID. For soft tissue with ID = 153, the mask is (class .== 153). Finally, to obtain a property, sum all the masks with values for all tissue classes. This process is illustrated below: ","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define the proton density array\nρ = (class.==102)*.86 .+    # Fat\n    (class.==153)*.9 .+     # SoftTissue\n    (class.==204)*.4 .+     # SpongyBone\n    (class.==255)*.2        # CorticalBone\n\n# Define the T1 decay array\nT1 = (class.==102)*366 .+   # Fat\n    (class.==153)*1200 .+   # SoftTissue\n    (class.==204)*381 .+    # SpongyBone\n    (class.==255)*100       # CorticalBone\n\n# Define the T2 decay array\nT2 = (class.==102)*70 .+    # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define the T2s decay array\nT2s = (class.==102)*70 .+   # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define off-resonance array\nΔw_fat = -220 * 2π\nΔw = (class.==102) * Δw_fat # FAT1\n\n# Adjust with scaling factor\nT1 = T1*1e-3\nT2 = T2*1e-3\nT2s = T2s*1e-3","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Finally, we can invoke the Phantom constructor. However, before doing so, we choose not to store spins where the proton density is zero to avoid unnecessary data storage. This is achieved by applying the mask ρ.!=0 to the arrays. Additionally, please note that we set the z-position array filled with zeros.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define the phantom\nobj = Phantom{Float64}(\n    name = \"custom-pelvis\",\n\tx = x[ρ.!=0],\n\ty = y[ρ.!=0],\n\tz = 0*x[ρ.!=0],\n\tρ = ρ[ρ.!=0],\n\tT1 = T1[ρ.!=0],\n\tT2 = T2[ρ.!=0],\n\tT2s = T2s[ρ.!=0],\n\tΔw = Δw[ρ.!=0],\n)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"We can display the Phantom struct with the plot_phantom_map function. In this case we select the T1 decay to be displayed, but you can choose other property to be displayed:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"plot_phantom_map(obj, :T1)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"<object type=\"text/html\" data=\"../../assets/create-your-own-phantom-plot-rho.html\" style=\"width:100%; height:620px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"EditURL = \"lit-01-FID.jl\"","category":"page"},{"location":"tutorial/01-FID/#Free-Induction-Decay","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"section"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"First of all, let's use the KomaMRI package and define the default scanner.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"using KomaMRI\nsys = Scanner() # default hardware definition","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The free induction decay is the simplest observable NMR signal. This signal is the one that follows a single tipping RF pulse. To recreate this experiment, we will need to define a Sequence with 2 blocks.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The first block containing an RF pulse with a flip-angle of 90 deg,","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"ampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF,durRF)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"and the second block containing the ADC.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"nADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, we concatenate the sequence blocks to create the final sequence.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"seq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\np1 = plot_seq(seq; slider=false, height=300)\nsavefig(p1, \"../assets/1-seq.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Now, we will define a Phantom with a single spin at x=0 with T_1=1000mathrmms and T_2=100mathrmms.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3])","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, to simulate we will need to use the function simulate.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"raw = simulate(obj, seq, sys)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"To plot the results we will need to use the plot_signal function","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"p2 = plot_signal(raw; slider=false, height=300)\nsavefig(p2, \"../assets/1-signal.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Nice!, we can see that S(t) follows an exponential decay exp(-tT_2) as expected.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"For a little bit of spiciness, let's add off-resonance to our example. We will use Delta f=-100mathrmHz. For this, we will need to add a definition for Δw in our Phantom","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3], Δw=[-2π*100])# and simulate again.\n\nraw = simulate(obj, seq, sys)\np3 = plot_signal(raw; slider=false, height=300)\nsavefig(p3, \"../assets/1-signal2.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal2.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The signal now follows an exponential of the form exp(-tT_2)cdotexp(-iDeltaomega t). The addition of exp(-iDeltaomega t) to the signal will generate a shift in the image space (Fourier shifting property). This effect will be better visualized and explained in later examples.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"This page was generated using Literate.jl.","category":"page"},{"location":"how-to/3-create-your-own-sequence/#Create-Your-Own-Sequence","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"","category":"section"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"warning: Warning\nThis section is currently under construction, and some details on how to construct a Sequence may be missing.","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"This is an example of how to create a Sequence struct:","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"# Export necessary modules\nusing KomaMRI\n\n# Create the function that creates a phantom\nfunction sequence_example(FOV::Real, N::Integer)\n\n    # Define initial paramters (TODO: consider when N is even)\n    sys = Scanner()\n\tΔt = sys.ADC_Δt\n\tGmax = sys.Gmax\n\tNx = Ny = N #Square acquisition\n\tΔx = FOV/(Nx-1)\n\tTa = Δt*(Nx-1) #4-8 us\n    Δτ = Ta/(Ny-1)\n\tGa = 1/(γ*Δt*FOV)\n\tζ = Ga / sys.Smax\n\tGa ≥ sys.Gmax ? error(\"Ga=$(Ga*1e3) mT/m exceeds Gmax=$(Gmax*1e3) mT/m, increase Δt to at least Δt_min=\"\n\t*string(round(1/(γ*Gmax*FOV),digits=2))*\" us.\") : 0\n\tϵ1 = Δτ/(Δτ+ζ)\n\n\t# EPI base\n\tEPI = Sequence(vcat(\n\t    [mod(i,2)==0 ? Grad(Ga*(-1)^(i/2),Ta,ζ) : Grad(0.,Δτ,ζ) for i=0:2*Ny-2],  #Gx\n\t \t[mod(i,2)==1 ? ϵ1*Grad(Ga,Δτ,ζ) :         Grad(0.,Ta,ζ) for i=0:2*Ny-2])) #Gy\n\tEPI.ADC = [mod(i,2)==1 ? ADC(0,Δτ,ζ) : ADC(N,Ta,ζ) for i=0:2*Ny-2]\n\n\t# Pre-wind and wind gradients\n\tϵ2 = Ta/(Ta+ζ)\n    PHASE =   Sequence(reshape(1/2*[Grad(      -Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # This needs to be calculated differently\n\tDEPHASE = Sequence(reshape(1/2*[Grad((-1)^N*Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # for even N\n\tseq = PHASE + EPI + DEPHASE\n\n\t# Saving parameters\n\tseq.DEF = Dict(\"Nx\"=>Nx,\"Ny\"=>Ny,\"Nz\"=>1,\"Name\"=>\"epi\")\n\n    # Return the sequence\n\treturn seq\nend\n\n# Call the function to create a sequence\nFOV, N = 23e-2, 101\nseq = sequence_example(FOV, N)\n\n# Plot the sequence in time and its kspace\nplot_seq(seq; range=[0 30])\nplot_kspace(seq)","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"<object type=\"text/html\" data=\"../../assets/create-your-own-sequence-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/create-your-own-sequence-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore","page":"KomaMRICore","title":"KomaMRICore","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"CurrentModule = KomaMRICore","category":"page"},{"location":"reference/3-koma-core/#Simulation-functions","page":"KomaMRICore","title":"Simulation functions","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"simulate\nsimulate_slice_profile\ndefault_sim_params","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore.simulate","page":"KomaMRICore","title":"KomaMRICore.simulate","text":"out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; sim_params, w)\n\nReturns the raw signal or the last state of the magnetization according to the value of the \"return_type\" key of the sim_params dictionary. \n\nThis is a wrapper function to run_sim_time_iter, which converts the inputs to the appropriate types and discretizes the sequence before simulation. The reported simulation time only considers run_sim_time_iter, as the preprocessing duration should be negligible compared to the simulation time (if this is not the case, please file a bug report). \n\nArguments\n\nobj: (::Phantom) Phantom struct\nseq: (::Sequence) Sequence struct\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameter dictionary\nw: (::Blink.AtomShell.Window, =nothing) the window within which to display a   progress bar in the Blink Window UI. If this variable is anything other than 'nothing',   the progress bar will be considered\n\nReturns\n\nout: (::Vector{Complex} or ::SpinStateRepresentation or ::RawAcquisitionData) depending   on whether \"return_type\" is \"mat\", \"state\" or \"raw\" (default), respectively\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.simulate_slice_profile","page":"KomaMRICore","title":"KomaMRICore.simulate_slice_profile","text":"mag = simulate_slice_profile(seq; z, sim_params)\n\nReturns magnetization of spins distributed along z after running the Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nz: (=range(-2e-2,2e-2,200)) range for the z axis\nsim_params: (::Dict{String, Any}, =Dict{String,Any}(\"Δt_rf\"=>1e-6)) dictionary with   simulation parameters\n\nReturns\n\nmag: (::SpinStateRepresentation) final state of the magnetization vector\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.default_sim_params","page":"KomaMRICore","title":"KomaMRICore.default_sim_params","text":"sim_params = default_sim_params(sim_params=Dict{String,Any}())\n\nThis function returns a dictionary containing default simulation parameters while also allowing the user to define some of them.\n\nArguments\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) user-defined dictionary with   simulation parameters. The following lists its keys along with their possible values:\n\"return_type\": defines the output of the simulate function. Possible values   are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco   RawAcquisitionData, the signal values, and the last magnetization state of the   simulation, respectively\n\"sim_method\": defines the type of simulation. The default value is Bloch(), but you   can alternatively use the BlochDict() simulation method. Moreover, you have the   flexibility to create your own methods without altering the KomaMRI source code\n\"Δt\": raster time for gradients\n\"Δt_rf\": raster time for RFs\n\"precision\": defines the floating-point simulation precision. You can choose between   \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively.   It's important to note that, especially for GPU operations, using \"f32\" is   generally much faster\n\"Nblocks\": divides the simulation into a specified number of time blocks. This parameter   is designed to conserve RAM resources, as KomaMRI computes a series of   simulations consecutively, each with the specified number of blocks determined by   the value of \"Nblocks\"\n\"Nthreads\": divides the Phantom into a specified number of threads. Because spins   are modeled independently of each other, KomaMRI can solve simulations in   parallel threads, speeding up the execution time\n\"gpu\": is a boolean that determines whether to use GPU or CPU hardware resources, as   long as they are available on the host computer\n\"gpu_device\": default value is 'nothing'. If set to integer or device instance, calls the   corresponding function to set the device of the available GPU in the host computer    (e.g. CUDA.device!)\n\nReturns\n\nsim_params: (::Dict{String,Any}) dictionary with simulation parameters\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#GPU-helper-functions","page":"KomaMRICore","title":"GPU helper functions","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"get_backend\nprint_devices\ngpu\ncpu\nf32\nf64","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore.get_backend","page":"KomaMRICore","title":"KomaMRICore.get_backend","text":"get_backend(use_gpu)\n\nGets the simulation backend to use. If use_gpu=false or there are no available GPU backends,  returns CPU(), else, returns the GPU backend (currently either CUDABackend(), MetalBackend(),  ROCBackend(), or oneAPIBackend()).\n\nThe GPU package for the corresponding backend (CUDA.jl, Metal.jl, AMDGPU.jl, or oneAPI.jl) must be loaded and functional, otherwise KomaMRI will default to using the CPU.\n\nArguments\n\n'use_gpu': ('::Bool') If true, attempt to use GPU and check for available backends\n\nReturns\n\n'backend': (::KernelAbstractions.backend) The backend to use\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.print_devices","page":"KomaMRICore","title":"KomaMRICore.print_devices","text":"print_devices()\n\nSimple function to print available devices. Calls internal get_backend() function to get the appropriate GPU / CPU backend and prints device information.\n\nArguments\n\n'use_gpu':  ('::Bool') If true, check for loaded / functional GPU backends and print appropriate warnings if no GPU backends have been loaded\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.gpu","page":"KomaMRICore","title":"KomaMRICore.gpu","text":"gpu(x)\n\nMoves 'x' to the GPU. For this function to work, a GPU backend will need to be loaded with 'using AMDGPU / CUDA / Metal / oneAPI.\n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nusing CUDA\nx = x |> gpu\n\n\n\n\n\ngpu(x, backend)\n\nTries to move x to the GPU backend specified in the 'backend' parameter. \n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nx = gpu(x, CUDABackend())\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.cpu","page":"KomaMRICore","title":"KomaMRICore.cpu","text":"cpu(x)\n\nTries to move object to CPU. This works for functions, and any struct marked with @functor.\n\nSee also gpu.\n\nExamples\n\nx = x |> cpu\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f32","page":"KomaMRICore","title":"KomaMRICore.f32","text":"f32(m)\n\nConverts the eltype of model's parameters to Float32 Recurses into structs marked with @functor.\n\nSee also f64.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f64","page":"KomaMRICore","title":"KomaMRICore.f64","text":"f64(m)\n\nConverts the eltype of model's parameters to Float64 (which is Koma's default).. Recurses into structs marked with @functor.\n\nSee also f32.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#Signal-to-RawAquisitionData-(MRD)","page":"KomaMRICore","title":"Signal to RawAquisitionData (MRD)","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"signal_to_raw_data","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore.signal_to_raw_data","page":"KomaMRICore","title":"KomaMRICore.signal_to_raw_data","text":"raw = signal_to_raw_data(signal, seq; phantom_name, sys, sim_params)\n\nTransforms the raw signal into a RawAcquisitionData struct (nearly equivalent to the ISMRMRD format) used for reconstruction with MRIReco.\n\nArguments\n\nsignal: (::Matrix{Complex}) raw signal matrix\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nphantom_name: (::String, =\"Phantom\") phantom name\nsys: (::Scanner, =Scanner()) Scanner struct\nsim_params: (::Dict{String, Any}, =Dict{String,Any}()) simulation parameter dictionary\n\nReturns\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_se.seq\")\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> sim_params = KomaMRICore.default_sim_params(); sim_params[\"return_type\"] = \"mat\"\n\njulia> signal = simulate(obj, seq, sys; sim_params)\n\njulia> raw = signal_to_raw_data(signal, seq)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#SpinRepresentationState's","page":"KomaMRICore","title":"SpinRepresentationState's","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"Mag","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore.Mag","page":"KomaMRICore","title":"KomaMRICore.Mag","text":"mag = Mag(xy::Complex, z::Real)\n\nThe Magnetization struct.\n\nArguments\n\nxy: (::Complex{Float64}) magnetization of a spin in the xy plane\nz: (::Real) magnetization of a spin in the z plane\n\nReturns\n\nmag: (::Mag) Magnetization struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#Spinor-rotation-matrix-(RF-excitation)","page":"KomaMRICore","title":"Spinor rotation matrix (RF excitation)","text":"","category":"section"},{"location":"reference/3-koma-core/","page":"KomaMRICore","title":"KomaMRICore","text":"Spinor\nQ\nUn\nRx\nRy\nRz","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore.Spinor","page":"KomaMRICore","title":"KomaMRICore.Spinor","text":"spinor = Spinor(α, β)\n\nSpinor(α, β) with Cayley-Klein parameters α and β. Based on \"Introduction to the Shinnar-Le Roux algorithm\", Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (alphabetainmathbbC):\n\nR=leftbeginarraycc\nalpha  -beta^*\nbeta  alpha^*\nendarrayright\n\nwith alpha^2+beta^2 = 1.\n\nThis later operates on the 2times2 representation of (xyz) as follows V^+ = R V R^*.\n\nArguments\n\nα: (::Complex{Float64}) Cayley-Klein parameter α\nβ: (::Complex{Float64}) Cayley-Klein parameter β\n\nReturns\n\nspinor: (::Spinor) Spinor struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#KomaMRICore.Q","page":"KomaMRICore","title":"KomaMRICore.Q","text":"s = Q(φ, nxy, nz)\n\nSpinor rotation matrix. Counter-clockwise rotation of φ with respect to the axis of rotation n=(nx, ny, nz).\n\nPauly, J., Le Roux, P., Nishimura, D., & Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611\n\nvarphi=-gammaDelta tsqrtleftB_1right^2+left(boldsymbolGcdotboldsymbolx\nright)^2=-gammaDelta tleftVert boldsymbolBrightVert\n\nboldsymboln=boldsymbolBleftVert boldsymbolBrightVert\n\nArguments\n\nφ: (::Real, [rad]) φ angle\nnxy: (::Real) nxy factor\nnz: (::Real) nz factor\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Q rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Un","page":"KomaMRICore","title":"KomaMRICore.Un","text":"Rodrigues' formula: Rotation matrix that when applied rotates with respect to \"n\" in an angle θ anti clock-wise\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rx","page":"KomaMRICore","title":"KomaMRICore.Rx","text":"s = Rx(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to x-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to x-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Rx rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Ry","page":"KomaMRICore","title":"KomaMRICore.Ry","text":"s = Ry(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to y-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to y-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Ry rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rz","page":"KomaMRICore","title":"KomaMRICore.Rz","text":"s = Rz(φ)\n\nSpinor counter-clockwise rotation matrix with angle φ with respect to z-axis.\n\nArguments\n\nφ: (::Real, [rad]) angle with respect to z-axis\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Rz rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"EditURL = \"lit-02-SmallTipApproximation.jl\"","category":"page"},{"location":"tutorial/02-SmallTipApproximation/#Small-Tip-Angle-Approximation","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"section"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Based on the results in page 41 of the book \"Handbook of MRI Pulse Sequences\" by Bernstein et al.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"using KomaMRI # hide\nsys = Scanner() # hide\nsys.Smax = 50 # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"In this example, we will showcase a common approximation in MRI, the small tip angle approximation. For this, we will simulate a slice profile for spins with positions zin-22mathrmcm and with a gradient G_z so their frequencies are mapped to fin-55mathrmkHz. To start, we define an RF pulse with a flip angle of 30 deg and pulse duration of T_mathrmrf=32mathrmms.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"B1 = 4.92e-6\nTrf = 3.2e-3\nzmax = 2e-2\nfmax = 5e3\nz = range(-zmax, zmax, 400)\nGz = fmax / (γ * zmax)\nf = γ * Gz * z # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"The designed RF pulse is presented in the figure below, where the additional gradient refocuses the spins' phase after the excitation.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"seq = PulseDesigner.RF_sinc(B1, Trf, sys; G=[0;0;Gz], TBP=8)\np2 = plot_seq(seq; max_rf_samples=Inf, slider=false)\nsavefig(p2, \"../assets/42-seq.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/42-seq.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Now we will perform the simulation using the function simulate_slice_profile. Note that we modified Δt_rf in sim_params to match the resolution of the waveform.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"sim_params = Dict{String, Any}(\"Δt_rf\" => Trf / length(seq.RF.A[1]))\nM = simulate_slice_profile(seq; z, sim_params)\n\nusing PlotlyJS # hide\ns1 = scatter(x=f, y=real.(M.xy), name=\"Mx\") # hide\ns2 = scatter(x=f, y=imag.(M.xy), name=\"My\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns3 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B₁(t))|\", line=attr(dash=\"dash\")) # hide\npb = plot([s1,s2,s3], Layout(title=\"30 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nsavefig(pb, \"../assets/4b-profile.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This produces the following slice profile:","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4b-profile.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"As you can see, for a flip angle of 30 deg, the slice profile is very close to the small tip angle approximation (the Fourier transform of B_1(t)).","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"But what will happen if we use a flip angle of 120 deg instead?","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"α_desired = 120 + 0im               # The multiplication of a complex number scales the RF pulse of a Sequence\nα = get_flip_angles(seq)[1] # Previous FA approx 30 deg\nseq = (α_desired / α) * seq         # Scaling the pulse to have a flip angle of 120\nM = simulate_slice_profile(seq; z, sim_params)\n\ns1 = scatter(x=f, y=abs.(M.xy), name=\"|Mxy|\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns2 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B₁(t))|\", line=attr(dash=\"dash\")) # hide\npa = plot([s1,s2], Layout(title=\"120 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nsavefig(pa, \"../assets/4a-profile.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4a-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"For this case, the small tip angle approximation breaks 😢, thus, the reason for its name!","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This basic sinc pulse is not designed to be B_1-insensitive.  Some adiabatic RF pulses have been proposed to achieve this. Watch out for a future example showing these adiabatic RF pulses 👀.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"EditURL = \"lit-05-SimpleMotion.jl\"","category":"page"},{"location":"tutorial/05-SimpleMotion/#Patient's-Motion-During-Acquisition","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"using KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"It can also be interesting to see the effect of the patient's motion during an MRI scan. For this, Koma provides the ability to add motion <: AbstractMotionSet to the phantom. In this tutorial, we will show how to add a Translate motion to a 2D brain phantom.","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"First, let's load the 2D brain phantom used in the previous tutorials:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"obj = brain_phantom2D()\nobj.Δw .= 0 # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/#Head-Translation","page":"Patient's Motion During Acquisition","title":"Head Translation","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"In this example, we will add a Translate of 2 cm in x, with duration of 200 ms (v = 0.1 m/s):","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"obj.motion = MotionList(\n    Translate(2e-2, 0.0, 0.0, TimeRange(t_start=0.0, t_end=200e-3))\n)\np1 = plot_phantom_map(obj, :T2 ; height=450, intermediate_time_samples=4) # hide\n\nsavefig(p1, \"../assets/5-phantom1.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center><object type=\"text/html\" data=\"../../assets/5-phantom1.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"# Read Sequence # hide\nseq_file1 = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\") # hide\nseq1 = read_seq(seq_file1) # hide\n\n# Simulate # hide\nraw1 = simulate(obj, seq1, sys) # hide\n\n# Recon # hide\nacq1 = AcquisitionData(raw1) # hide\nacq1.traj[1].circular = false # hide\nNx, Ny = raw1.params[\"reconSize\"][1:2] # hide\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny)) # hide\nimage1 = reconstruction(acq1, reconParams) # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"If we simulate an EPI sequence with acquisition duration (183.989 ms) comparable with the motion's duration (200 ms), we will observe motion-induced artifacts in the reconstructed image.","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"# Plotting the recon # hide\np2 = plot_image(abs.(image1[:, :, 1]); height=400) # hide\nsavefig(p2, \"../assets/5-recon1.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center>\n<object type=\"text/html\" data=\"../../assets/5-recon1.html\" style=\"width:65%; height:420px;\"></object>\n</center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"The severity of the artifacts can vary depending on the acquisition duration and k-space trajectory.","category":"page"},{"location":"tutorial/05-SimpleMotion/#Motion-Corrected-Reconstruction","page":"Patient's Motion During Acquisition","title":"Motion-Corrected Reconstruction","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"To correct for the motion-induced artifacts we can perform a motion-corrected reconstruction. This can be achieved by multiplying each sample of the acquired signal  S(t) by a phase shift Deltaphi_mathrmcorr proportional to the displacement boldsymbolu(t) [Godenschweger, 2016]:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"S_mathrmMCleft(tright)=Sleft(tright)cdotmathrme^mathrmiDeltaphi_mathrmcorr=Sleft(tright)cdotmathrme^mathrmi2piboldsymbolkleft(tright)cdotboldsymboluleft(tright)","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"In practice, we would need to estimate or measure the motion before performing a motion-corrected reconstruction, but for this example, we will directly use the displacement functions boldsymbolu(boldsymbolx t) defined by obj.motion::SimpleAction. Since translations are rigid motions (boldsymbolu(boldsymbolx t)=boldsymbolu(t) no position dependence), we can obtain the required displacements by calculating boldsymbolu(boldsymbolx=boldsymbol0 t=t_mathrmadc).","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"sample_times = get_adc_sampling_times(seq1)\ndisplacements = hcat(get_spin_coords(obj.motion, [0.0], [0.0], [0.0], sample_times)...)\n\np3 = KomaMRIPlots.plot( # hide\n    sample_times, # hide\n    displacements .* 1e2, # hide\n    KomaMRIPlots.Layout( # hide\n        title = \"Head displacement in x, y and z\", # hide\n        xaxis_title = \"time (s)\", # hide\n        yaxis_title = \"Displacement (cm)\" # hide\n    )) # hide\nKomaMRIPlots.restyle!(p3,1:3, name=[\"ux(t)\", \"uy(t)\", \"uz(t)\"]) # hide\n\nsavefig(p3, \"../assets/5-displacements.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center><object type=\"text/html\" data=\"../../assets/5-displacements.html\" style=\"width:80%; height:300px;\"></object></center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"We can now get the necessary phase shift for each sample:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"_, kspace = get_kspace(seq1)\nΔΦ = 2π*sum(kspace .* displacements, dims=2)","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"And apply it to the acquired signal to correct its phase:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"acq1.kdata[1] .*= exp.(im*ΔΦ)\n\nimage2 = reconstruction(acq1, reconParams) # hide\n\np4 = plot_image(abs.(image2[:, :, 1]); height=400) # hide\n\nsavefig(p4, \"../assets/5-recon2.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"Finally, we compare the original image ▶️ and the motion-corrected reconstruction ⏸️:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<object type=\"text/html\" data=\"../../assets/5-recon1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/5-recon2.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/6-koma-mri/#KomaMRI","page":"KomaMRI","title":"KomaMRI","text":"","category":"section"},{"location":"reference/6-koma-mri/","page":"KomaMRI","title":"KomaMRI","text":"CurrentModule = KomaMRI","category":"page"},{"location":"reference/6-koma-mri/#User-Interface","page":"KomaMRI","title":"User Interface","text":"","category":"section"},{"location":"reference/6-koma-mri/","page":"KomaMRI","title":"KomaMRI","text":"KomaUI","category":"page"},{"location":"reference/6-koma-mri/#KomaMRI.KomaUI","page":"KomaMRI","title":"KomaMRI.KomaUI","text":"out = KomaUI(; kwargs...)\n\nLaunch the Koma's UI.\n\nKeywords\n\ndarkmode: (::Bool, =true) define dark mode style for the UI\nframe: (::Bool, =true) display the upper frame of the Blink window\nphantom_mode: (::String, =\"2D\", opts=[\"2D\", \"3D\"]) load the default phantom as a   2D or 3D brain example\nsim: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameters dictionary\nrec: (::Dict{Symbol,Any}, =Dict{Symbol,Any}()) reconstruction parameters dictionary\nreturn_window: (::Bool, =false) make the out be either 'nothing' or the Blink window,   depending on whether the return_window keyword argument is set to true\nshow_window: (::Bool, =true) display the Blink window\n\nReturns\n\nout: (::Nothing or ::Blink.AtomShell.Window) returns either 'nothing' or the Blink   window, depending on whether the return_window keyword argument is set to true.\n\nExamples\n\njulia> KomaUI()\n\n\n\n\n\n","category":"function"},{"location":"explanation/4-gpu-explanation/#GPU-Parallelization","page":"GPU Parallelization","title":"GPU Parallelization","text":"","category":"section"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"KomaMRI uses a vendor agnostic approach to GPU parallelization in order to support multiple GPU backends. Currently, the following backends are supported:","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"CUDA.jl (Nvidia)\nMetal.jl (Apple)\nAMDGPU.jl (AMD)\noneAPI.jl (Intel)","category":"page"},{"location":"explanation/4-gpu-explanation/#Choosing-a-GPU-Backend","page":"GPU Parallelization","title":"Choosing a GPU Backend","text":"","category":"section"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"To determine which backend to use, KomaMRI uses package extensions (introduced in Julia 1.9) to avoid having the packages for each GPU backend as explicit dependencies. This means that the user is responsible for loading the backend package (e.g. using CUDA) at the beginning of their code, or prior to calling KomaUI(), otherwise, Koma will default back to the CPU:","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"using KomaMRI\nusing CUDA # loading CUDA will load KomaMRICoreCUDAExt, selecting the backend","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Once this is done, no further action is needed! The simulation objects will automatically be moved to the GPU and back once the simulation is finished. When the simulation is run a message will be shown with either the GPU device being used or the number of CPU threads if running on the CPU.","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Of course, it is still possible to move objects to the GPU manually, and control precision using the f32 and f64 functions:","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"x = rand(100)\nx |> f32 |> gpu # Float32 CuArray","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"To change the precision level used for the entire simulation, the sim_params[\"precision\"] parameter can be set to either f32 or f64 (Note that for most GPUs, Float32 operations are considerably faster compared with Float64). In addition, the sim_params[\"gpu\"] option can be set to true or false to enable / disable the gpu functionality (if set to true, the backend package will still need to be loaded beforehand):","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"using KomaMRI\nusing CUDA\nsys = Scanner\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n#Simulate on the GPU using 32-bit floating point values\nsim_params = Dict{String,Any}(\n  \"Nblocks\" => 20,\n  \"gpu\" => true,\n  \"precision\" => \"f32\"\n  \"sim_method\" => Bloch(),\n)\nsimulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/4-gpu-explanation/#How-Objects-are-moved-to-the-GPU","page":"GPU Parallelization","title":"How Objects are moved to the GPU","text":"","category":"section"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Koma's gpu function implementation calls a separate gpu function with a backend parameter of type <:KernelAbstractions.GPU for the backend it is using. This function then calls the fmap function from package Functors.jl to recursively call adapt from package Adapt.jl on each field of the object being transferred. This is similar to how many other Julia packages, such as Flux.jl, transfer data to the GPU. However, an important difference is that KomaMRI adapts directly to the KernelAbstractions.Backend type in order to use the adapt_storage functions defined in each backend package, rather than defining custom adapters, resulting in an implementation with fewer lines of code.","category":"page"},{"location":"explanation/4-gpu-explanation/#Inside-the-Simulation","page":"GPU Parallelization","title":"Inside the Simulation","text":"","category":"section"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"KomaMRI has three different simulation methods, all of which can run on the GPU: ","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochSimple: BlochSimple.jl\nBlochDict: BlochDict.jl\nBloch: BlochCPU.jl / BlochGPU.jl","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochSimple is the simplest method and prioritizes readability. ","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochDict can be understood as an extension to BlochSimple that outputs a more detailed signal.","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Bloch is equivalent to BlochSimple in the operations it performs, but is much faster since it has been optimized both for the CPU and GPU. The CPU implementation prioritizes conserving memory, and makes extensive use of pre-allocation for the simulation arrays. Unlike the GPU implementation, it does not allocate a matrix of size Number of Spins x Number of Time Points in each block, instead using a for loop to step through time.","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"In contrast, the GPU implementation divides work among as many threads as possible at the beginning of the run_spin_precession! and run_spin_excitation! functions. For the CPU implementation, this would not be beneficial since there are far less CPU threads available compared with the GPU. Preallocation is also used via the same prealloc function used in BlochCPU.jl, where a struct of arrays is allocated at the beginning of the simulation that can be re-used in each simulation block. In addition, a precalc function is called before moving the simulation objects to the GPU to do certain calculations that are faster on the CPU beforehand.","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Compared with BlochSimple, which only uses array broadcasting for parallelization, Bloch also uses kernel-based methods in its run_spin_excitation! function for operations which need to be done sequentially. The kernel implementation uses shared memory to store the necessary arrays for applying the spin excitation for fast memory access, and separates the complex arrays into real and imaginary components to avoid bank conflicts.","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"The performance differences between Bloch and BlochSimple can be seen on the KomaMRI benchmarks page. The first data point is from when Bloch was what is now BlochSimple, before a more optimized implementation was created. The following three pull requests are primarily responsible for the performance differences between Bloch and BlochSimple:","category":"page"},{"location":"explanation/4-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"(443) Optimize runspinprecession! and runspinexcitation! for CPU\n(459) Optimize runspinprecession! for GPU\n(462) Optimize runspinexcitation! for GPU","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"EditURL = \"lit-03-ChemicalShiftEPI.jl\"","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/#Chemical-Shift-in-an-EPI-sequence","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"section"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"using KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"For a more realistic example, we will use a brain phantom.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"obj = brain_phantom2D() # a slice of a brain\np1 = plot_phantom_map(obj, :T2 ; height=400, width=400, view_2d=true)\np2 = plot_phantom_map(obj, :Δw ; height=400, width=400, view_2d=true)\nsavefig(p1, \"../assets/2-phantom1.html\") # hide\nsavefig(p2, \"../assets/2-phantom2.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"At the left, you can see the T_2 map of the phantom, and at the right, the off-resonance Deltaomega. In this example, the fat is the only source of off-resonance (with Delta f =  -220mathrmHz) and you can see it in black in the off-resonance map.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-phantom1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/2-phantom2.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Then, we will load an EPI sequence, that is well known for being affected by off-resonance. With this sequence, we will be able visualize the effect of the chemical shift.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\")\nseq = read_seq(seq_file)\np3 = plot_seq(seq; range=[0 40], slider=true, height=300)\nsavefig(p3, \"../assets/2-seq.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Feel free to explore the sequence's plot 🔍 below!","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"If we simulate this sequence we will end up with the following signal.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"raw = simulate(obj, seq, sys)\np4 = plot_signal(raw; range=[98.4 103.4] , height=300)\nsavefig(p4, \"../assets/2-signal.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Now, we need to inspect what effect the off-resonance had in the reconstructed image. As you can see, the fat layer is now shifted to a different position 🤯, this is why the effect is called chemical shift!","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\nacq.traj[1].circular = false #This is to remove the circular mask\n\n# Setting up the reconstruction parameters\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the recon\nslice_abs = abs.(image[:, :, 1])\np5 = plot_image(slice_abs; height=400)\nsavefig(p5, \"../assets/2-recon.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<center><object type=\"text/html\" data=\"../../assets/2-recon.html\" style=\"width:65%; height:420px;\"></object></center>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"how-to/1-getting-started/#Getting-Started","page":"🏃 Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"how-to/1-getting-started/#Installing-Julia","page":"🏃 Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"KomaMRI was written in Julia, so the first thing you should do is to install it! The latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"page"},{"location":"how-to/1-getting-started/#Installing-KomaMRI","page":"🏃 Getting Started","title":"Installing KomaMRI","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Once Julia is installed, open the Julia REPL, and add the KomaMRI package by typing the following commands:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Press the ] key and then press enter to bring up Julia's package manager.\nType add KomaMRI and then press enter in the package manager session.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"This process should take about 5 minutes in a fresh Julia installation. Here is how it looks in the Julia REPL:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"julia> ]\n\n(@v1.9) pkg> add KomaMRI","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Then press Ctrl+C or backspace to return to the julia> prompt.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"","category":"page"},{"location":"how-to/1-getting-started/#My-First-MRI-Simulation","page":"🏃 Getting Started","title":"My First MRI Simulation","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"For our first simulation we will use KomaMRI's graphical user interface (GUI). For this, you will first need to load KomaMRI by typing using KomaMRI, and then launch the GUI with the KomaUI function. Note that if you want to run simulations on the GPU (for example, using CUDA), then using CUDA is also necessary (see GPU Parallelization).  ","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"julia> using KomaMRI, CUDA\n\njulia> KomaUI()","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"The first time you use this command it may take more time than usual, but a window with the Koma GUI will pop up:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"The user interface has some basic definitions for the scanner, phantom, and sequence already preloaded. So you can immediately interact with the simulation and reconstruction processes, and then visualize the results.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"As a simple demonstration, press the Simulate! button and wait until the simulation is ready. Now you have acquired the Raw Signal and you should see the following:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Then, press the Reconstruct! button and wait until the reconstruction ends. Now you have reconstructed an Image from the Raw Signal and you should see the following in the GUI:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Congratulations, you successfully simulated an MRI acquisition! 🎊","category":"page"},{"location":"explanation/2-seq-events/#Sequence-Events","page":"Sequence Events","title":"Sequence Events","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As we already know, a Sequence struct contains field names that store arrays of RF, Grad, and ADC structs. In the context of MRI, we refer to RF, Grad, and ADC as \"events.\" To create a Sequence, it's essential to understand how to create these fundamental events.","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the following subsections, we will provide detailed explanations of event parameters and guide you through the process of creating a Sequence using RF, Grad, and ADC events.","category":"page"},{"location":"explanation/2-seq-events/#RF","page":"Sequence Events","title":"RF","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The RF struct is defined in the source code of KomaMRI as follows:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct RF\n    A\n    T\n    Δf\n    delay::Real\nend","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 4 field names: ''A'' defines amplitude, ''T'' defines duration time, ''delay'' is the distance between the 0 time and the first waveform sample and ''Δf'' is the displacement respect to the main field carrier frequency (this is for advanced users).","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"''A'' and ''T'' can be numbers or vectors of numbers. Depending on the length of the ''A'' and ''T'', KomaMRI interprets different waveforms: ","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Pulse Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors with the same length (zero-order-hold)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below, we provide a summary of how you can define RF events:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-rf-horizontal.svg\"/></p>","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at some basic examples of creating these RF structs and including them in a Sequence struct. The examples should be self-explanatory.","category":"page"},{"location":"explanation/2-seq-events/#RF-Pulse-Waveform","page":"Sequence Events","title":"RF Pulse Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A, T, delay =  10e-3, 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(10000.0 uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-pulse-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#RF-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"RF Uniformly-Sampled Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> tl = -3:0.2:-0.2; tr = 0.2:0.2:3;\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; sin.(π*tr)./(π*tr)];\n\njulia> T, delay = 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#RF-Time-Shaped-Waveform","page":"Sequence Events","title":"RF Time-Shaped Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> tl = -4:0.2:-0.2; tr = 0.2:0.2:4\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; 1; sin.(π*tr)./(π*tr)]\n\njulia> T = [0.05e-3*ones(length(tl)); 2e-3; 0.05e-3*ones(length(tl))]\n\njulia> delay = 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 4.0 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 4.1 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#Gradient","page":"Sequence Events","title":"Gradient","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The Grad struct is defined as follows in the source code of KomaMRI:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct Grad\n    A\n    T\n    rise::Real\n    fall::Real\n    delay::Real\nend","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 5 field names: ''A'' defines amplitude, ''T'' defines duration time, ''delay'' is the distance between the 0 time and the first waveform sample, ''rise'' and ''fall'' are the time durations of the first and last gradient ramps.","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Just like the RF, ''A'' and ''T'' in the Grad struct can be numbers or vectors of numbers. Depending on the length of the ''A'' and ''T'', KomaMRI interprets different waveforms: ","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Trapezoidal Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors, A has one sample more the T (linear interpolation)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below, we provide a summary of how you can define Grad events:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-gr-horizontal.svg\"/></p>","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at some basic examples of creating these Grad structs and including them in a Sequence struct, focusing on the ''x'' component of the gradients. The examples should be self-explanatory.","category":"page"},{"location":"explanation/2-seq-events/#Gradient-Trapezoidal-Waveform","page":"Sequence Events","title":"Gradient Trapezoidal Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A, T, delay, rise, fall = 50*10e-6, 5e-3, 2e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←2.0 ms→ Grad(0.5 mT, 0.5 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-trapezoidal-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#Gradient-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"Gradient Uniformly-Sampled Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> t = 0:0.25:7.5\n\njulia> A = 10*10e-6 * sqrt.(π*t) .* sin.(π*t)\n\njulia> T = 10e-3;\n\njulia> delay, rise, fall = 1e-3, 0, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 10.0 ms, ↑0.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 12.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#Gradient-Time-Shaped-Waveform","page":"Sequence Events","title":"Gradient Time-Shaped Waveform","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A = 50*10e-6*[1; 1; 0.8; 0.8; 1; 1];\n\njulia> T = 1e-3*[5; 0.2; 5; 0.2; 5];\n\njulia> delay, rise, fall = 1e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 15.4 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 10.75 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#ADC","page":"Sequence Events","title":"ADC","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The ADC struct is defined in the KomaMRI source code as follows:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct ADC\n    N::Integer\n    T::Real\n    delay::Real\n    Δf::Real\n    ϕ::Real\nend","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 5 field names: ''N'' defines number of samples, ''T'' defines total acquisition duration, ''delay'' is the distance between the 0 time and the first sampled signal, ''Δf'' and ''ϕ' are factor to correct signal acquisition (for advanced users).","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below you can see how to define an ADC event:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"50%\" src=\"../../assets/event-shapes-adc.svg\"/></p>","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at a basic example of defining an ADC struct and including it in a Sequence struct:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> N, T, delay =  16, 5e-3, 1e-3;\n\njulia> adc = ADC(N, T, delay)\nADC(16, 0.005, 0.001, 0.0, 0.0)\n\njulia> seq = Sequence(); seq += adc\nSequence[ τ = 6.0 ms | blocks: 1 | ADC: 1 | GR: 0 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-adc.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/#Combination-of-Events","page":"Sequence Events","title":"Combination of Events","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"We can include multiple events within a single block of a sequence. The example below demonstrates how to combine an RF struct, three Grad structs for the x-y-z components, and an ADC struct in a single block of a sequence:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define an RF struct\nA, T =  1e-6*[0; -0.1; 0.2; -0.5; 1; -0.5; 0.2; -0.1; 0], 0.5e-3;\nrf = RF(A, T)\n\n# Define a Grad struct for Gx\nA, T, rise =  50*10e-6, 5e-3, 1e-3\ngx = Grad(A, T, rise)\n\n# Define a Grad struct for Gy\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT, rise = 5e-3, 2e-3;\ngy = Grad(A, T, rise)\n\n# Define a Grad struct for Gz\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT = 5e-3*[0.0; 0.1; 0.3; 0.2; 0.1; 0.2; 0.3; 0.2; 0.1]\ngz = Grad(A, T)\n\n# Define an ADC struct\nN, T, delay =  16, 5e-3, 1e-3\nadc = ADC(N, T, delay)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> seq = Sequence([gx; gy; gz;;], [rf;;], [adc])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 1 | GR: 3 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-combination.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Once the struct events are defined, it's important to note that to create a single block sequence, you need to provide 2D matrices of Grad and RF structs, as well as a vector of ADC structs as arguments in the Sequence constructor.","category":"page"},{"location":"explanation/2-seq-events/#Algebraic-manipulation","page":"Sequence Events","title":"Algebraic manipulation","text":"","category":"section"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Certain mathematical operations can be directly applied to events and sequence structs. This proves helpful when constructing sequences using reference structs and manipulating them algebraically to create new structs. Below, we provide a list of operations you can perform, along with examples where we check the equivalence of two different struct definitions:","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"RF scaling","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nA, T = 10e-6, 0.5e-3    # Define base RF params  \nα = (1 + im*1)/sqrt(2)  # Define a complex scaling factor\n\n# Create two equivalent RFs in different ways\nra = RF(α * A, T)\nrb = α * RF(A, T)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ra ≈ rb\ntrue","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient scaling","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nA, T = 10e-3, 0.5e-3   # Define base gradient params  \nα = 2                  # Define a scaling factor\n\n# Create two equivalent gradients in different ways\nga = Grad(α * A, T)\ngb = α * Grad(A, T)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ga ≈ gb\ntrue","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient addition","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3      # Define common duration of the gradients\nA1 = 5e-3       # Define base amplitude for gradient  \nA2 = 10e-3      # Define another base amplitude for gradient  \n\n# Create two equivalent gradients in different ways\nga = Grad(A1 + A2, T)\ngb = Grad(A1, T) + Grad(A2, T)","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ga ≈ gb\ntrue","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient array multiplication by a matrix","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent gradient vectors in different ways\nga = [gy; gz; gx]\ngb = R * [gx; gy; gz]\n\n# Create two equivalent gradient matrices in different ways\ngc = [gy 2*gy; gz 2*gz; gx 2*gx]\ngd = R * [gx 2*gx; gy 2*gy; gz 2*gz]","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> all(ga .≈ gb)\ntrue\n\njulia> all(gc .≈ gd)\ntrue","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Sequence rotation","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent sequences in different ways\nsa = Sequence(R * [gx; gy; gz;;])\nsb = R * Sequence([gx; gy; gz;;])","category":"page"},{"location":"explanation/2-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> all(sa.GR .≈ sb.GR)\ntrue","category":"page"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/#Low-Field-CMRA-Optimization","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"","category":"section"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"<iframe type=\"text/html\" src=\"../02-low-field-cmra-optimization.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. ","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"Files matching the lit-*.jl pattern anywhere in examples/3.tutorials will be included.","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"All files included in this folder will be ignored.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Use-Koma's-User-Interface","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"This section provides a comprehensive guide on using the User Interface of the KomaMRI package and delves into the internal processes that occur during interaction. By the end of this section, you will be equipped to execute a complete workflow even without any prior programming experience.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-simulation.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Basic-Workflow","page":"Use Koma's User Interface","title":"Basic Workflow","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"As a general overview, remember the following workflow steps when using KomaMRI:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Loading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"In the following subsections, we will cover all the mentioned steps. First, open the Julia REPL and enter the following commands to include the KomaMRI package and launch the user interface:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-dashboard.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Loading-Simulation-Inputs","page":"Use Koma's User Interface","title":"Loading Simulation Inputs","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The user interface has preloaded certain inputs into RAM, including the Scanner, Phantom, and Sequence structs. In the following subsections, we will demonstrate how to visualize these inputs.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Scanner","page":"Use Koma's User Interface","title":"Scanner","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"You can visualize the preloaded Scanner struct by clicking on the Scanner dropdown and then pressing the View Scanner button. The Scanner struct contains hardware-related information, such as the main magnetic field's magnitude:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-scanner-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Phantom","page":"Use Koma's User Interface","title":"Phantom","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To see the phantom already stored in RAM, simply click on the Phantom dropdown an then press the View Phantom button. The preloaded phantom is a slice of a brain:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"It is also possible to load .h5 phantom files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/2.phantoms/. For instance, let's load the sphere_chemical_shift.h5 file:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Note that you can select different spin parameters to visualize like ρ, T1, T2, among others. ","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Sequence","page":"Use Koma's User Interface","title":"Sequence","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"For visualization of the sequence in the time domain, click on the Sequence dropdown and then press the Sequence (MPS) button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"For visualization of the sequence in the k-space, click on the Sequence dropdown and then press the k-space button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"You can also display the Moments related to the Sequence by pressing the View Moments and then pressing the buttons for zero, first and second moments.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"It is also possible to load Pulseq compatible .seq sequence files. The KomaMRI has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/1.sequences/. For instance, let's load the spiral.seq file and view it the time domain and k-space:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"And remember, you are free to interact with the plots:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-seq.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Running-Simulation","page":"Use Koma's User Interface","title":"Running Simulation","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Once the inputs are loaded in RAM, it is possible to perform the simulation to get the Raw Signal.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Simulation-Parameters","page":"Use Koma's User Interface","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To visualize the default simulation parameters, click on the Simulate! dropdown and then press the View Options button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-sim-params-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Raw-Signal","page":"Use Koma's User Interface","title":"Visualization of the Raw Signal","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Press the Simulate! button to perform the simulation (this may take a while). Automatically the generated Raw Signal should be displayed or you can click on the Raw Data dropdown and then press the View Raw Data button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-rawsignal-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Reconstructing-Image-using-MRIReco","page":"Use Koma's User Interface","title":"Reconstructing Image using MRIReco","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Once the Raw Signal is loaded in RAM, it is possible to reconstruct the image.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Reconstruction-Parameters","page":"Use Koma's User Interface","title":"Reconstruction Parameters","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To visualize the default reconstruction parameters, click on the Reconstruct! dropdown and then press the View Options button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-recon-params-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Image","page":"Use Koma's User Interface","title":"Visualization of the Image","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Press the Reconstruct! button to perform the reconstruction (this may take a while).  Automatically the generated Image should be displayed or you can click on the he Reconstruct! dropdown and then press the |Image| button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-image-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Exporting-Results-to-.mat-File","page":"Use Koma's User Interface","title":"Exporting Results to .mat File","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The user interface has the option to save the results in .mat format. Simply click on the Export to .mat and you have the alternatives to get data independently or you can press the All button to have all the results given by the simulator:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-export-to-mat.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"So far, and due to limitations of the user interface dependencies, the .mat files are saved in the temporal directory of your computer OS, which can be found by typing the tempdir() command in the Julia REPL:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-export-data.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#REPL-and-UI-communication","page":"Use Koma's User Interface","title":"REPL and UI communication","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"An amazing feature of KomaMRI is that it allows you to modify certain variables in the Julia REPL, and then the user interface automatically updates its plots in real-time:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-observables.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The variables that update the interface are:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"seq_ui[] for the Sequence\nobj_ui[] for the Phantom\nsys_ui[] for the Scanner\nraw_ui[] for the Raw Signal\nimg_ui[] for the Image","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Don't forget to add the brackets [] to these variables, otherwise it won't work.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Use-Koma-in-Julia-Scripts","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You should already be familiar with the  Graphical User Interface of KomaMRI. However, you can also use this package directly from the Julia REPL or write your own Julia scripts. This allows you to unlock the full potential of KomaMRI, enabling you to utilize more of its functionalities and even test your own MRI ideas.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"This section demonstrates a basic workflow with KomaMRI through writing your own scripts or entering commands directly into the Julia REPL. Let's begin.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Basic-Workflow","page":"Use Koma in Julia Scripts","title":"Basic Workflow","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"As a general overview, remember the following workflow steps when using KomaMRI:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Loading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Let's replicate these previous steps in a Julia script. You will obtain the following code, which you can copy and paste into the Julia REPL:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Import the package\nusing KomaMRI\n\n# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)\n\n# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Let's go through this script step by step.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Loading-Simulation-Inputs","page":"Use Koma in Julia Scripts","title":"Loading Simulation Inputs","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The inputs of the simulation are created in the following part of the script: ","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Scanner","page":"Use Koma in Julia Scripts","title":"Scanner","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The previously created Scanner struct contains default parameters. In your initial simulations, you will likely use this default struct without making any modifications. You can view all the parameters by displaying the struct variable in the Julia REPL. The Scanner's parameters include hardware limitations such as the main magnetic field, maximum gradient values, minimum raster times, and more. You may want to adjust these values for your future custom simulations.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> sys\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Δt: Float64 2.0e-6\n  seq_Δt: Float64 1.0e-5\n  GR_Δt: Float64 1.0e-5\n  RF_Δt: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Phantom","page":"Use Koma in Julia Scripts","title":"Phantom","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Phantom struct created in this example represents a slice of a brain. To create it, we use the function brain_phantom2D, which is part of the subdependency KomaMRICore. While KomaMRI provides some phantom examples for experimentation, you may also want to create your custom Phantom struct tailored to your specific requirements.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Phantom struct contains MRI parameters related to the magnetization properties of an object. These parameters include magnetization positions, proton density, relaxation times, off-resonance, among others. To view all the keys and values of the object, you can do so in the Julia REPL as follows:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> obj\nPhantom{Float64}\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084,  …  0.086, 0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028,  …  0.0, 0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0,  …  0.0, 0.0]\n  ρ: Array{Float64}((6506,)) [0.7, 0.7,  …  0.7, 0.7]\n  T1: Array{Float64}((6506,)) [0.569, 0.569,  …  0.569, 0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329,  …  0.329, 0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058,  …  0.058, 0.058]\n  Δw: Array{Float64}((6506,)) [-0.0, -0.0,  …  -0.0, -0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n...","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"As you can see, attributes of the Phantom struct are vectors representing object properties, with each element holding a value associated with a single magnetization.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can also visualize the Phantom struct using the plot_phantom_map function, which is part of the KomaMRIPlots subdependency. This function plots the magnitude of a property for each magnetization at a specific spatial position. You can observe properties such as proton density and relaxation times, so feel free to replace the :ρ symbol with another property of the phantom in the example below:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_phantom_map(obj, :ρ)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/phantom-rho.html\" style=\"width:100%; height:620px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To utilize test phantoms included with KomaMRI, navigate to the \"examples\" folder and use the read_phantom_jemris  function to read a phantom in .h5 format. The following steps outline how to do this in Julia:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_sphere = joinpath(path_koma, \"examples\", \"2.phantoms\", \"sphere_chemical_shift.h5\")\njulia> sphere = read_phantom_jemris(path_sphere)\njulia> plot_phantom_map(sphere, :T2)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/phantom-T2-circle.html\" style=\"width:100%; height:620px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Sequence","page":"Use Koma in Julia Scripts","title":"Sequence","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Sequence struct in the example represents one of the most basic MRI sequences. It excites the object with a 90° RF pulse and then uses EPI gradients to fill the k-space in a \"square\" manner. While you may want to create your sequences for experiments, you can always use some of the examples already available in KomaMRI.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In MRI, the sequence must be carefully designed with precise timing to obtain an image. It includes subcomponents such as gradients, radio-frequency excitation signals, and sample acquisition. For more information on constructing a Sequence struct, refer to the Sequence section.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can view general information about a Sequence struct by displaying it in the Julia REPL:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> seq\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"For more precise timing checks, you can use the plot_seq function:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_seq(seq; range=[0 30])","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/plot-seq-epi.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"It is important to consider how the sequence traverses through k-space. The plot_kspace function does precisely that:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_kspace(seq)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/kspace-epi.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Additionally, there are helpful sequence construction functions within a submodule of KomaMRI called PulseDesigner. These functions include PulseDesigner.RF_hard, PulseDesigner.RF_sinc, PulseDesigner.EPI, PulseDesigner.radial_base and PulseDesigner.spiral_base. For more details on how to use them, refer to the API documentation.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"KomaMRI is also compatible with Pulseq. The package installation includes some .seq files in Pulseq format, which can be read and used as a Sequence struct. Here's how to read a spiral Pulseq file stored in the \"examples\" folder of KomaMRI:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_spiral = joinpath(path_koma, \"examples\", \"1.sequences\", \"spiral.seq\")\njulia> spiral = read_seq(path_spiral)\njulia> plot_seq(spiral)\njulia> plot_kspace(spiral)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Running-Simulation","page":"Use Koma in Julia Scripts","title":"Running Simulation","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The following lines in the example script configure and perform the simulation:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Simulation-Parameters","page":"Use Koma in Julia Scripts","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To perform simulations, KomaMRI requires certain parameters. You can use the default parameters for testing, but you also have the option to customize specific simulation aspects. In the example, we use the KomaMRICore.default_sim_params function to create a dictionary with default simulation parameters. You can view the keys that can be modified by displaying the sim_params variable:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> sim_params\nDict{String, Any} with 9 entries:\n  \"return_type\" => \"raw\"\n  \"Nblocks\"     => 20\n  \"gpu\"         => true\n  \"Nthreads\"    => 1\n  \"gpu_device\"  => 0\n  \"sim_method\"  => Bloch()\n  \"precision\"   => \"f32\"\n  \"Δt\"          => 0.001\n  \"Δt_rf\"       => 5.0e-5","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"All of these parameters deserve special attention. We will explain some of the most important ones here. For instance, \"Δt\" and \"Δt_rf\" represent the raster times for the gradients and RFs. \"return_type\" specifies the type of variable returned by the simulator (by default, it returns an object ready for use with MRIReco for reconstruction, but you can use the value \"mat\" to return a simple vector). \"gpu\" indicates whether you want to use your GPU device for simulations, and \"precision\" sets the floating-point precision. For more details on how to set these parameters, please refer to the Simulation Parameters Section.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Raw-Signal","page":"Use Koma in Julia Scripts","title":"Raw Signal","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The simulation is performed using the simulate function, which requires three arguments: a Scanner struct, a Phantom struct, and a Sequence struct. Optionally, you can include the keyword argument sim_params if you wish to use custom simulation parameters.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In the example, we can see that the output of the simulation is a special struct:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> typeof(raw)\nRawAcquisitionData\n\njulia> raw\nRawAcquisitionData[SeqName: epi | 101 Profile(s) of 101×1]","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can plot the simulation result with the plot_signal function like so:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_signal(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/raw-epi-brain-default.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Reconstructing-Image-using-MRIReco","page":"Use Koma in Julia Scripts","title":"Reconstructing Image using MRIReco","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"KomaMRI does not handle reconstruction; instead, you should utilize the MRIReco package to generate an image. For convenience, when you install KomaMRI, you also install MRIReco, allowing you to access functions from that package. You should pay special attention to the RawAcquisitionData and AcquisitionData structs, as well as the reconstruction function.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In the example below, we define an auxiliary function, reconstruct_2d_image, which takes a raw signal struct, RawAcquisitionData, as input and returns a 2D Array representing an image. Within this function, we create an AcquisitionData struct and set some reconstruction parameters, which serve as inputs for the reconstruction function. The latter function is responsible for the image generation process.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"If you need more information about how to use the AcquisitionData and the how to fill the reconstruction parameters, you need to visit the MRIReco webpage).","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To display the image, you can use the plot_image function which is part of the KomaMRIPlots subpackage:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_image(image)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<center><object type=\"text/html\" data=\"../../assets/image-default-brain.html\" style=\"width:100%; height:620px;\"></object></center>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Exporting-Results-to-.mat-File","page":"Use Koma in Julia Scripts","title":"Exporting Results to .mat File","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Many people in the MRI community uses MATLAB, probably you are one of them and you want to process the raw signal in the MATLAB environment after simulation is done with KomaMRI. Here we show you an example of how to save a .mat file with the information of the raw signal thank to the help of the MAT package:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Many people in the MRI community use MATLAB; you might be one of them and may want to process the Raw Signal in the MATLAB environment after simulation is completed with KomaMRI. Here, we provide an example of how to save a .mat file containing the  Raw Signal information using the MAT package.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Use the MAT package\nusing MAT\n\n# Perform simulation to return an Array type\nsim_params[\"return_type\"] = \"mat\"\nraw = simulate(obj, seq, sys; sim_params)\n\n# Save the .mat file in the temp directory\nmatwrite(joinpath(tempdir(), \"koma-raw.mat\"), Dict(\"raw\" => raw))","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Note that we need to simulate to return an array type (not the default RawAcquisitionData), and then we utilize the matwrite function to save a file named \"koma-raw.mat\" in your computer's temporary directory. Now, you can navigate to your temporary directory (which you can find by displaying the result of tempdir() in the Julia REPL) and locate the \"koma-raw.mat\" file.","category":"page"},{"location":"reference/4-koma-files/#KomaMRIFiles","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"","category":"section"},{"location":"reference/4-koma-files/","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"CurrentModule = KomaMRIFiles","category":"page"},{"location":"reference/4-koma-files/#Sequence","page":"KomaMRIFiles","title":"Sequence","text":"","category":"section"},{"location":"reference/4-koma-files/","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"read_seq","category":"page"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_seq","page":"KomaMRIFiles","title":"KomaMRIFiles.read_seq","text":"seq = read_seq(filename)\n\nReturns the Sequence struct from a Pulseq file with .seq extension.\n\nArguments\n\nfilename: (::String) absolute or relative path of the sequence file .seq\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#Phantom","page":"KomaMRIFiles","title":"Phantom","text":"","category":"section"},{"location":"reference/4-koma-files/","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"read_phantom_jemris\nread_phantom_MRiLab\nread_phantom\nwrite_phantom","category":"page"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_jemris","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_jemris","text":"obj = read_phantom_jemris(filename)\n\nReturns the Phantom struct from a JEMRIS phantom file .h5.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .h5\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.h5\")\n\njulia> obj = read_phantom_jemris(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_MRiLab","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_MRiLab","text":"obj = read_phantom_MRiLab(filename)\n\nReturns the Phantom struct from a MRiLab phantom file .mat.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .mat\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.mat\")\n\njulia> obj = read_phantom_MRiLab(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom","text":"phantom = read_phantom(filename)\n\nReads a (.phantom) file and creates a Phantom structure from it\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.write_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.write_phantom","text":"phantom = write_phantom(ph,filename)\n\nWrites a (.phantom) file from a Phantom struct.\n\n\n\n\n\n","category":"function"},{"location":"how-to/2-2-use-koma-notebooks/#Use-Koma-in-Notebooks","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"You can use KomaMRI with popular programming environments such as Pluto and Jupyter notebooks. The following sections show how to set up these notebooks and test KomaMRI with them.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/#Pluto","page":"Use Koma in Notebooks","title":"Pluto","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"First, install the Pluto module in your Julia environment. Remember to press the ] button to open the Package Manager Session:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia>\n\n@(1.9) pkg> add Pluto","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Afterward, return to the Julia Session by pressing the backspace button, and then execute the Pluto.run() function:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia> using Pluto\n\njulia> Pluto.run()","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"This should automatically open the Pluto dashboard in your default web browser:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/pluto-dashboard.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, create a new notebook by clicking on + Create a new notebook:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/pluto-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Write and run the following code, which is identical to the Free Induction Decay example. Pluto automatically installs the required modules if they are not present on your system. Additionally, note that we do not directly use KomaMRI since we won't be utilizing the KomaUI function. Instead, we rely on the KomaMRICore and KomaMRIPlots dependencies. To display plots in Pluto, ensure that you import the PlutoPlotly package, as KomaMRIPlots requires its backend to display figures in Pluto:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<embed type=\"text/html\" src=\"../../assets/pluto-fid-example.html\" style=\"height:1024px;width:100%;\">","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"One of the most outstanding features of Pluto is its ability to ensure reproducibility by storing the information necessary to recreate the package environment in the notebook file. When others open your notebook with Pluto, it automatically ensures they use the exact same package environment, guaranteeing seamless functionality on their computers.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/#Jupyter","page":"Use Koma in Notebooks","title":"Jupyter","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Ensure you have Jupyter installed on your computer. Follow this tutorial for installation using Anaconda.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, install the IJulia module in your Julia environment. Remember to press the ] key to open the Package Manager Session:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia>\n\n(@v1.9) pkg> add IJulia","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"For this example, make sure to install KomaMRICore and KomaMRIPlots (we do not use KomaMRI directly since we won't be utilizing the KomaUI() function):","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"(@v1.9) pkg> add KomaMRICore\n\n(@v1.9) pkg> add KomaMRIPlots","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, open Jupyter, navigate to a working folder, and create a new notebook by clicking on New, then Julia 1.9.3.\"","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-create-new-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"A new, empty notebook will appear:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Proceed to write and execute the provided example:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<details><summary>View code</summary>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"# Import modules\nusing KomaMRICore, KomaMRIPlots\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\n\n# Plot the sequence\nplot_seq(seq; slider=false, height=300)","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"</details>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-test-notebook.png\" alt=\"\" style=\"width:100%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"This should be sufficient, and now you can start working with KomaMRI using Jupyter notebooks.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"If you encounter the issue of WebIO not being detected:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-webio-problem.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Refer to this IJulia documentation and this troubleshooting guide for details. Essentially, you need to install a WebIO extension depending on your Jupyter installation.","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase","page":"KomaMRIBase","title":"KomaMRIBase","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"CurrentModule = KomaMRIBase","category":"page"},{"location":"reference/2-koma-base/#Scanner-related-functions","page":"KomaMRIBase","title":"Scanner-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Scanner","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Scanner","page":"KomaMRIBase","title":"KomaMRIBase.Scanner","text":"sys = Scanner(B0, B1, Gmax, Smax, ADC_Δt, seq_Δt, GR_Δt, RF_Δt,\n    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)\n\nThe Scanner struct. It contains hardware limitations of the MRI resonator. It is an input for the simulation.\n\nArguments\n\nB0: (::Real, =1.5, [T]) main magnetic field strength\nB1: (::Real, =10e-6, [T]) maximum RF amplitude\nGmax: (::Real, =60e-3, [T/m]) maximum gradient amplitude\nSmax: (::Real, =500, [mT/m/ms]) gradient's maximum slew-rate\nADC_Δt: (::Real, =2e-6, [s]) ADC raster time\nseq_Δt: (::Real, =1e-5, [s]) sequence-block raster time\nGR_Δt: (::Real, =1e-5, [s]) gradient raster time\nRF_Δt: (::Real, =1e-6, [s]) RF raster time\nRF_ring_down_T: (::Real, =20e-6, [s]) RF ring down time\nRF_dead_time_T: (::Real, =100e-6, [s]) RF dead time\nADC_dead_time_T: (::Real, =10e-6, [s]) ADC dead time\n\nReturns\n\nsys: (::Scanner) Scanner struct\n\nExamples\n\njulia> sys = Scanner()\n\njulia> sys.B0\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Phantom-related-functions","page":"KomaMRIBase","title":"Phantom-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Phantom\nbrain_phantom2D\nbrain_phantom3D\npelvis_phantom2D\nheart_phantom","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Phantom","page":"KomaMRIBase","title":"KomaMRIBase.Phantom","text":"obj = Phantom(name, x, y, z, ρ, T1, T2, T2s, Δw, Dλ1, Dλ2, Dθ, motion)\n\nThe Phantom struct. Most of its field names are vectors, with each element associated with a property value representing a spin. This struct serves as an input for the simulation.\n\nArguments\n\nname: (::String) phantom name\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nρ: (::AbstractVector{T<:Real}) spin proton density vector\nT1: (::AbstractVector{T<:Real}, [s]) spin T1 parameter vector\nT2: (::AbstractVector{T<:Real}, [s]) spin T2 parameter vector\nT2s: (::AbstractVector{T<:Real}, [s]) spin T2s parameter vector\nΔw: (::AbstractVector{T<:Real}, [rad/s]) spin off-resonance parameter vector\nDλ1: (::AbstractVector{T<:Real}) spin Dλ1 (diffusion) parameter vector\nDλ2: (::AbstractVector{T<:Real}) spin Dλ2 (diffusion) parameter vector\nDθ: (::AbstractVector{T<:Real}) spin Dθ (diffusion) parameter vector\nmotion: (::AbstractMotionSet{T<:Real}) motion set\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = Phantom(x=[0.0])\n\njulia> obj.ρ\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom2D","text":"phantom = brain_phantom2D(;axis=\"axial\", ss=4)\n\nCreates a two-dimensional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\naxis: (::String, =\"axial\", opts=[\"axial\", \"coronal\", \"sagittal\"]) orientation of the phantom\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy], if used ss is set to ss=1\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = brain_phantom2D(; axis=\"sagittal\", ss=1)\n\njulia> obj = brain_phantom2D(; axis=\"axial\", us=[1, 2])\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom3D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom3D","text":"obj = brain_phantom3D(; ss=4, us=1, start_end=[160,200])\n\nCreates a three-dimentional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm. \n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 3 element vector [ssx, ssy, ssz]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 3 element vector [usx, usy, usz]\nstart_end: (::Vector{Integer}, =[160,200]) z index range of presampled phantom, 180 is center\n\nReturns\n\nobj: (::Phantom) 3D Phantom struct\n\nExamples\n\njulia> obj = brain_phantom3D(; ss=5)\n\njulia> obj = brain_phantom3D(; us=[2, 2, 1])\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.pelvis_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.pelvis_phantom2D","text":"obj = pelvis_phantom2D(; ss=4, us=1)\n\nCreates a two-dimensional pelvis Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy]\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = pelvis_phantom2D(; ss=2])\n\njulia> obj = pelvis_phantom2D(; us=[1, 2])\n\njulia> pelvis_phantom2D(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.heart_phantom","page":"KomaMRIBase","title":"KomaMRIBase.heart_phantom","text":"obj = heart_phantom(\n    circumferential_strain, radial_strain, rotation_angle; \n    heart_rate, asymmetry\n)\n\nHeart-like LV 2D phantom. The variable circumferential_strain and radial_strain are for streching (if positive)  or contraction (if negative). rotation_angle is for rotation.\n\nKeywords\n\ncircumferential_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nradial_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nrotation_angle: (::Real, =15.0, [º]) maximum rotation angle\nheart_rate: (::Real, =60, [bpm]) heartbeat frequency\ntemporal_asymmetry: (::Real, =0.2) time fraction of the period in which the systole occurs. Therefore, diastole lasts for period * (1 - temporal_asymmetry)\n\nReturns\n\nobj: (::Phantom) Heart-like LV phantom struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Motion-related-functions","page":"KomaMRIBase","title":"Motion-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#AbstractMotionSet-types-and-related-functions","page":"KomaMRIBase","title":"AbstractMotionSet types and related functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"NoMotion\nMotionList\nget_spin_coords","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.NoMotion","page":"KomaMRIBase","title":"KomaMRIBase.NoMotion","text":"nomotion = NoMotion{T<:Real}()\n\nNoMotion struct. It is used to create static phantoms.\n\nReturns\n\nnomotion: (::NoMotion) NoMotion struct\n\nExamples\n\njulia> nomotion = NoMotion{Float64}()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.MotionList","page":"KomaMRIBase","title":"KomaMRIBase.MotionList","text":"motionlist = MotionList(motions...)\n\nMotionList struct. The other option, instead of NoMotion,  is to define a dynamic phantom by means of the MotionList struct. It is composed by one or more Motion instances. \n\nArguments\n\nmotions: (::Vector{Motion{T<:Real}}) vector of Motion instances\n\nReturns\n\nmotionlist: (::MotionList) MotionList struct\n\nExamples\n\njulia>  motionlist = MotionList(\n            Motion(\n                action = Translate(0.01, 0.0, 0.02),\n                time = TimeRange(0.0, 1.0),\n                spins = AllSpins()\n            ),\n            Motion(\n                action = Rotate(0.0, 0.0, 45.0),\n                time = Periodic(1.0),\n                spins = SpinRange(1:10)\n            )\n        )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_spin_coords","page":"KomaMRIBase","title":"KomaMRIBase.get_spin_coords","text":"x, y, z = get_spin_coords(motionset, x, y, z, t)\n\nCalculates the position of each spin at a set of arbitrary time instants, i.e. the time steps of the simulation.  For each dimension (x, y, z), the output matrix has N_\tspins rows and length(t) columns.\n\nArguments\n\nmotionset: (::AbstractMotionSet{T<:Real}) phantom motion\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nt: horizontal array of time instants\n\nReturns\n\nx, y, z: (::Tuple{AbstractArray, AbstractArray, AbstractArray}) spin positions over time\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Motion","page":"KomaMRIBase","title":"Motion","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Motion","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Motion","page":"KomaMRIBase","title":"KomaMRIBase.Motion","text":"motion = Motion(action)\nmotion = Motion(action, time)\nmotion = Motion(action, time, spins)\n\nMotion struct. It defines the motion, during a certain time interval, of a given group of spins. It is composed by three fields: action, which  defines the motion itself, time, which accounts for the time during which the motion takes place, and spins, which indicates the spins  that are affected by that motion.\n\nArguments\n\naction: (::AbstractAction{T<:Real}) action, such as Translate or Rotate\ntime: (::AbstractTimeSpan{T<:Real}, =TimeRange(0.0)) time information about the motion\nspins: (::AbstractSpinSpan, =AllSpins()) spin indexes affected by the motion\n\nReturns\n\nmotion: (::Motion) Motion struct\n\nExamples\n\njulia> motion =  Motion(\n            action = Translate(0.01, 0.0, 0.02),\n            time = TimeRange(0.0, 1.0),\n            spins = SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#AbstractAction-types","page":"KomaMRIBase","title":"AbstractAction types","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Translate\nTranslate(dx, dy, dz, time, spins)\nRotate\nRotate(pitch, roll, yaw, time, spins)\nHeartBeat\nHeartBeat(circumferential_strain, radial_strain, longitudinal_strain, time, spins)\nPath\nPath(dx, dy, dz, time, spins)\nFlowPath\nFlowPath(dx, dy, dz, spin_reset, time, spins)","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Translate","page":"KomaMRIBase","title":"KomaMRIBase.Translate","text":"translate = Translate(dx, dy, dz)\n\nTranslate struct. It produces a linear translation. Its fields are the final displacements in the three axes (dx, dy, dz).\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\n\nReturns\n\ntranslate: (::Translate) Translate struct\n\nExamples\n\njulia> translate = Translate(dx=0.01, dy=0.02, dz=0.03)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Translate-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Translate","text":"translate = Translate(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\ntime: (::AbstractTimeSpan{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\ntranslate: (::Motion) Motion struct\n\nExamples\n\njulia> translate = Translate(0.01, 0.02, 0.03, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.Rotate","page":"KomaMRIBase","title":"KomaMRIBase.Rotate","text":"rotate = Rotate(pitch, roll, yaw)\n\nRotate struct. It produces a rotation in the three axes:  x (pitch), y (roll), and z (yaw). We follow the RAS (Right-Anterior-Superior) orientation,  and the rotations are applied following the right-hand rule (counter-clockwise):\n\n(Image: Head Rotation Axis)\n\nThe applied rotation matrix is obtained as follows: \n\nbeginequation\nbeginaligned\nR = R_z(alpha) R_y(beta) R_x(gamma) \n  = beginbmatrix\ncos alpha  -sin alpha  0 \nsin alpha  cos alpha  0 \n0  0  1\nendbmatrix\nbeginbmatrix\ncos beta  0  sin beta \n0  1  0 \n-sin beta  0  cos beta\nendbmatrix\nbeginbmatrix\n1  0  0 \n0  cos gamma  -sin gamma \n0  sin gamma  cos gamma\nendbmatrix \n  = beginbmatrix\ncos alpha cos beta  cos alpha sin beta sin gamma - sin alpha cos gamma  cos alpha sin beta cos gamma + sin alpha sin gamma \nsin alpha cos beta  sin alpha sin beta sin gamma + cos alpha cos gamma  sin alpha sin beta cos gamma - cos alpha sin gamma \n-sin beta  cos beta sin gamma  cos beta cos gamma\nendbmatrix\nendaligned\nendequation\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\n\nReturns\n\nrotate: (::Rotate) Rotate struct\n\nExamples\n\njulia> rotate = Rotate(pitch=15.0, roll=0.0, yaw=20.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Rotate-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Rotate","text":"rotate = Rotate(pitch, roll, yaw, spins)\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\ntime: (::AbstractTimeSpan{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nrotate: (::Motion) Motion struct with Rotate action\n\nExamples\n\njulia> rotate = Rotate(15.0, 0.0, 20.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.HeartBeat","page":"KomaMRIBase","title":"KomaMRIBase.HeartBeat","text":"heartbeat = HeartBeat(circumferential_strain, radial_strain, longitudinal_strain)\n\nHeartBeat struct. It produces a heartbeat-like motion, characterised by three types of strain: circumferential, radial and longitudinal\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\n\nReturns\n\nheartbeat: (::HeartBeat) HeartBeat struct\n\nExamples\n\njulia> heartbeat = HeartBeat(circumferential_strain=-0.3, radial_strain=-0.2, longitudinal_strain=0.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.HeartBeat-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.HeartBeat","text":"heartbeat = HeartBeat(circumferential_strain, radial_strain, longitudinal_strainl, time, spins)\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\ntime: (::AbstractTimeSpan{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nheartbeat: (::Motion) Motion struct with HeartBeat action\n\nExamples\n\njulia> heartbeat = HeartBeat(-0.3, -0.2, 0.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.Path","page":"KomaMRIBase","title":"KomaMRIBase.Path","text":"path = Path(dx, dy, dz)\n\nPath struct. For this action (and for FlowPath), motion is not defined solely on the basis of  three numerical parameters, one for each spatial direction, as occurs for the Translate, Rotate and HeartBeat actions.\n\nFor this action, it is necessary to define  motion for each spin independently, in x (dx), y (dy) and z (dz). dx, dy and dz are now three matrixes, of (N_spins* times  N_discretetimes) each. This means that each row corresponds to a spin trajectory over a set of discrete time instants.\n\nnote: Note\n*When creating a motion with Flow or FlowPath, you must make sure that  the number of rows of the matrices dx, dy and dz matches the number  of spins that are affected by the motion. Remember that the range of spins affected by a motion  is defined by the spins field of the Motion structexample:julia> motion = Motion(\n    action = Path(\n        dx=[0.01 0.02; 0.02 0.03],  # 2 rows\n        dy=[0.02 0.03; 0.03 0.04], \n        dz=[0.03 0.04; 0.04 0.05]),\n    time = TimeRange(0.0, 1.0),\n    spins = SpinRange(1:2)          # 2 spins\n)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\n\nReturns\n\npath: (::Path) Path struct\n\nExamples\n\njulia> path = Path(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 0.05]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Path-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Path","text":"path = Path(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\ntime: (::AbstractTimeSpan{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\npath: (::Motion) Motion struct with Path action\n\nExamples\n\njulia> path = Path(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.FlowPath","page":"KomaMRIBase","title":"KomaMRIBase.FlowPath","text":"flowpath = FlowPath(dx, dy, dz, spin_reset)\n\nFlowPath struct. This action is the same as Path,  except that it includes an additional field, called spin_reset,  which accounts for spins leaving the volume and being remapped  to another input position. When this happens, the magnetization  state of these spins must be reset during the simulation. \n\nAs with the dx, dy and dz matrices, spin_reset has a size of (N_spins times  N_discretetimes).\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\n\nReturns\n\nflowpath: (::FlowPath) FlowPath struct\n\nExamples\n\njulia> flowpath = FlowPath(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 -0.04],\n           spin_reset=[false false; false true]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.FlowPath-NTuple{6, Any}","page":"KomaMRIBase","title":"KomaMRIBase.FlowPath","text":"flowpath = FlowPath(dx, dy, dz, spin_reset, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\ntime: (::AbstractTimeSpan{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nflowpath: (::Motion) Motion struct with FlowPath action\n\nExamples\n\njulia> flowpath = FlowPath(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          [false false; false true],\n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#AbstractTimeSpan-types-and-related-functions","page":"KomaMRIBase","title":"AbstractTimeSpan types and related functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"TimeRange\nPeriodic\nunit_time","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.TimeRange","page":"KomaMRIBase","title":"KomaMRIBase.TimeRange","text":"timerange = TimeRange(t_start, t_end)\n\nTimeRange struct. It is a specialized type that inherits from AbstractTimeSpan and  defines a time interval, with start and end times.\n\nArguments\n\nt_start: (::Real, [s]) start time\nt_end: (::Real, [s]) end time\n\nReturns\n\ntimerange: (::TimeRange) TimeRange struct\n\nExamples\n\njulia> timerange = TimeRange(0.0, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Periodic","page":"KomaMRIBase","title":"KomaMRIBase.Periodic","text":"periodic = Periodic(period, asymmetry)\n\nPeriodic struct. It is a specialized type that inherits from AbstractTimeSpan,  designed to work with time intervals that repeat periodically. It includes a measure of asymmetry in order to recreate a asymmetric period.\n\nArguments\n\nperiod: (::Real, [s]) period duration\nasymmetry: (::Real, =0.5) temporal asymmetry factor. Between 0 and 1.\n\nReturns\n\nperiodic: (::Periodic) Periodic struct\n\nExamples\n\njulia> periodic = Periodic(1.0, 0.2)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.unit_time","page":"KomaMRIBase","title":"KomaMRIBase.unit_time","text":"t_unit = unit_time(t, time_range)\n\nThe unit_time function normalizes a given array of time values t  to a unit interval [0, 1] based on a specified start time t_start and end time t_end.  This function is used for non-periodic motions, where each element of t is transformed  to fit within the range [0, 1] based on the provided start and end times.\n\n(Image: Unit Time)\n\nArguments\n\nt: (::AbstractArray{T<:Real}, [s]) array of time values to be normalized\ntime_range: (::TimeRange{T<:Real}, [s]) time interval (defined by t_start and t_end) over which we want to normalise\n\nReturns\n\nt_unit: (::AbstractArray{T<:Real}, [s]) array of normalized time values\n\nExamples\n\njulia> t_unit = KomaMRIBase.unit_time([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], TimeRange(1.0, 4.0))\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.333\n 0.666\n 1.0\n 1.0\n\n\n\n\n\nt_unit = unit_time(t, periodic)\n\nThe unit_time function normalizes a given array  of time values t to a unit interval [0, 1] for periodic motions,  based on a specified period and an asymmetry factor.  This function is useful for creating triangular waveforms  or normalizing time values in periodic processes.\n\n(Image: Unit Time Triangular)\n\nArguments\n\nt: (::AbstractArray{T<:Real}, [s]) array of time values to be normalized\nperiodic: (::Periodic{T<:Real}, [s]) information about the period and the temporal asymmetry\n\nReturns\n\nt_unit: (::AbstractArray{T<:Real}, [s]) array of normalized time values\n\nExamples\n\njulia> t_unit = KomaMRIBase.unit_time([0.0, 1.0, 2.0, 3.0, 4.0, 5.0], Periodic(4.0, 0.5))\n6-element Vector{Float64}:\n 0.0\n 0.5\n 1.0\n 0.5\n 0.0\n 0.5\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#AbstractSpinSapn-types","page":"KomaMRIBase","title":"AbstractSpinSapn types","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"AllSpins\nSpinRange","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.AllSpins","page":"KomaMRIBase","title":"KomaMRIBase.AllSpins","text":"allspins = AllSpins()\n\nAllSpins struct. It is a specialized type that inherits from AbstractSpinSpan and is used to cover all the spins of a phantom.\n\nReturns\n\nallspins: (::AllSpins) AllSpins struct\n\nExamples\n\njulia> allspins = AllSpins()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.SpinRange","page":"KomaMRIBase","title":"KomaMRIBase.SpinRange","text":"spinrange = SpinRange(range)\n\nSpinRange struct. It is a specialized type that inherits from AbstractSpinSpan and is used to select a certain range and number of spins.\n\nArguments\n\nrange: (::AbstractVector) spin id's. This argument can be a Range, a Vector or a BitVector\n\nReturns\n\nspinrange: (::SpinRange) SpinRange struct\n\nExamples\n\njulia> spinrange = SpinRange(1:10)\njulia> spinrange = SpinRange([1, 3, 5, 7])\njulia> spinrange = SpinRange(obj.x .> 0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Sequence-related-functions","page":"KomaMRIBase","title":"Sequence-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Sequence\ndur\nget_block_start_times\nget_flip_angles","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Sequence","page":"KomaMRIBase","title":"KomaMRIBase.Sequence","text":"seq = Sequence()\nseq = Sequence(GR)\nseq = Sequence(GR, RF)\nseq = Sequence(GR, RF, ADC)\nseq = Sequence(GR, RF, ADC, DUR)\nseq = Sequence(GR::Array{Grad,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)\n\nThe Sequence struct. It contains events of an MRI sequence. Most field names (except for the DEF field) consist of matrices or vectors, where each column index represents a sequence block. This struct serves as an input for the simulation.\n\nArguments\n\nGR: (::Matrix{Grad}) gradient matrix. Rows for x-y-z amplitudes and columns are for blocks\nRF: (::Matrix{RF}) RF matrix. The 1 row is for the coil and columns are for blocks\nADC: (::Array{ADC,1}) ADC block vector\nDUR: (::Vector, [s]) duration block vector\nDEF: (::Dict{String, Any}) dictionary with relevant information of the sequence.   Possible keys could be [\"AdcRasterTime\", \"GradientRasterTime\", \"Name\", \"Nz\",   \"Num_Blocks\", \"Nx\", \"Ny\", \"PulseqVersion\", \"BlockDurationRaster\",   \"FileName\", \"RadiofrequencyRasterTime\"]\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.dur","page":"KomaMRIBase","title":"KomaMRIBase.dur","text":"y = dur(x::Grad)\ny = dur(x::Vector{Grad})\ny = dur(x::Matrix{Grad})\n\nDuration time in [s] of Grad struct or Grad Array.\n\nArguments\n\nx: (::Grad or ::Vector{Grad} or ::Matrix{Grad}) Grad struct or Grad Array\n\nReturns\n\ny: (::Float64, [s]) duration of the Grad struct or Grad Array\n\n\n\n\n\ny = dur(x::RF)\ny = dur(x::Vector{RF})\ny = dur(x::Matrix{RF})\n\nDuration time in [s] of RF struct or RF Array.\n\nArguments\n\nx: (::RF or ::Vector{RF} or ::Matrix{RF}) RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) duration of the RF struct or RF array\n\n\n\n\n\nT = dur(x::Sequence)\n\nThe total duration of the sequence in [s].\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\nT: (::Real, [s]) total duration of the sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_block_start_times","page":"KomaMRIBase","title":"KomaMRIBase.get_block_start_times","text":"T0 = get_block_start_times(seq::Sequence)\n\nReturns a vector containing the start times of blocks in a sequence. The initial time is always zero, and the final time corresponds to the duration of the sequence.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nReturns\n\nT0: (::Vector, [s]) start times of the blocks in a sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angles","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angles","text":"y = get_flip_angles(x::Sequence)\n\nReturns all the flip angles of the RF pulses in the sequence x.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Vector{Float64}, [deg]) flip angles\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Grad","page":"KomaMRIBase","title":"Grad","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Grad\nGrad(::Function, ::Real, ::Int64)","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(A, T)\ngr = Grad(A, T, rise)\ngr = Grad(A, T, rise, delay)\ngr = Grad(A, T, rise, fall, delay)\ngr = Grad(A, T, rise, fall, delay, first, last)\n\nThe Grad struct represents a gradient of a sequence event.\n\nArguments\n\nA: (::Real or ::Vector, [T/m]) amplitude of the gradient\nT: (::Real or ::Vector, [s]) duration of the flat-top\nrise: (::Real, [s]) duration of the rise\nfall: (::Real, [s]) duration of the fall\ndelay: (::Real, [s]) duration of the delay\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gr = Grad(1, 1, 0.1, 0.1, 0.2)\n\njulia> seq = Sequence([gr]); plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(f::Function, T::Real, N::Integer; delay::Real)\n\nGenerates an arbitrary gradient waveform defined by the function f in the interval t ∈ [0,T]. The time separation between two consecutive samples is given by T/(N-1).\n\nArguments\n\nf: (::Function) function that describes the gradient waveform\nT: (::Real, [s]) duration of the gradient waveform\nN: (::Integer, =300) number of samples of the gradient waveform\n\nKeywords\n\ndelay: (::Real, =0, [s]) delay time of the waveform\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gx = Grad(t -> sin(π*t / 0.8), 0.8)\n\njulia> seq = Sequence([gx]); plot_seq(seq)\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#RF","page":"KomaMRIBase","title":"RF","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"RF\nRF(::Function, ::Real, ::Int64)\nget_flip_angle","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.RF","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF(A, T)\nrf = RF(A, T, Δf)\nrf = RF(A, T, Δf, delay)\n\nThe RF struct represents a Radio Frequency excitation of a sequence event.\n\nArguments\n\nA: (::Complex, [T]) RF complex amplitud modulation (AM), B_1(t) = B_1(t)   e^iphi(t) = B_1(t) + iB_1y(t)\nT: (::Real, [s]) RF duration\nΔf: (::Real or ::Vector, [Hz]) RF frequency difference with respect to the Larmor frequency.   This can be a number but also a vector to represent frequency modulated signals (FM).\ndelay: (::Real, [s]) RF delay time\n\nReturns\n\nrf: (::RF) the RF struct\n\nExamples\n\njulia> rf = RF(1, 1, 0, 0.2)\n\njulia> seq = Sequence(); seq += rf; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.RF-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF_fun(f::Function, T::Real, N::Int64)\n\nGenerate an RF sequence with amplitudes sampled from a function waveform.\n\nnote: Note\nThis function is not being used in this KomaMRI version.\n\nArguments\n\nf: (::Function, [T]) function for the RF amplitud waveform\nT: (::Real, [s]) duration of the RF pulse\nN: (::Int64) number of samples of the RF pulse\n\nReturns\n\nrf:(::RF) RF struct with amplitud defined by the function f\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angle","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angle","text":"α = get_flip_angle(x::RF)\n\nCalculates the flip angle α [deg] of an RF struct. α = γ ∫ B1(τ) dτ\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nα: (::Int64, [deg]) flip angle RF struct x\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#ADC","page":"KomaMRIBase","title":"ADC","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"ADC\nget_adc_sampling_times\nget_adc_phase_compensation","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.ADC","page":"KomaMRIBase","title":"KomaMRIBase.ADC","text":"adc = ADC(N, T)\nadc = ADC(N, T, delay)\nadc = ADC(N, T, delay, Δf, ϕ)\n\nThe ADC struct represents the Analog to Digital Converter (ADC) of a sequence event.\n\nArguments\n\nN: (::Int64) number of acquired samples\nT: (::Float64, [s]) duration to acquire the samples\ndelay: (::Float64, [s]) delay time to start the acquisition\nΔf: (::Float64, [Hz]) delta frequency. It is meant to compensate RF pulse phases\nϕ: (::Float64, [rad]) phase. It is meant to compensate RF pulse phases\n\nReturns\n\nadc: (::ADC) ADC struct\n\nExamples\n\njulia> adc = ADC(16, 1, 0.1)\n\njulia> seq = Sequence(); seq += adc; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_sampling_times","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_sampling_times","text":"times = get_adc_sampling_times(seq)\n\nReturns an array of times when the samples of the sequence seq are acquired.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ntimes: (::Vector{Float64}, [s]) time array when samples are acquired\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_phase_compensation","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_phase_compensation","text":"comp = get_adc_phase_compensation(seq)\n\nReturns an array of phase compensation factors, exp(-mathrmivarphi), which are used to compensate the acquired signal S by applying the operation S_mathrmcomp = S exp(-mathrmivarphi) after the simulation. This compensation is necessary because the signal typically exhibits a phase offset of varphi following RF excitation with a phase of varphi. Such pulses are commonly employed in sequences involving RF spoiling.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ncomp: (::Vector{Complex}, [rad]) array of phase compensations for every acquired sample\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Delay","page":"KomaMRIBase","title":"Delay","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"Delay","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.Delay","page":"KomaMRIBase","title":"KomaMRIBase.Delay","text":"delay = Delay(T)\n\nThe Delay struct is meant to add a delay to a sequence by using a sum operator.\n\nArguments\n\nT: (::Real, [s]) time delay value\n\nReturns\n\ndelay: (::Delay) delay struct\n\nExamples\n\njulia> delay = Delay(0.5)\n\njulia> s = Sequence([Grad(1, 1, 0.1)])\n\njulia> seq = delay + s; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Rotation-matrices","page":"KomaMRIBase","title":"Rotation matrices","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"rotx\nroty\nrotz","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.rotx","page":"KomaMRIBase","title":"KomaMRIBase.rotx","text":"Rx = rotx(θ::Real)\n\nRotates vector counter-clockwise with respect to the x-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRx: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.roty","page":"KomaMRIBase","title":"KomaMRIBase.roty","text":"Ry = roty(θ::Real)\n\nRotates vector counter-clockwise with respect to the y-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRy: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.rotz","page":"KomaMRIBase","title":"KomaMRIBase.rotz","text":"Rz = rotz(θ::Real)\n\nRotates vector counter-clockwise with respect to the z-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRz: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Moments","page":"KomaMRIBase","title":"Moments","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"get_Mk\nget_kspace\nget_M0\nget_M1\nget_M2","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.get_Mk","page":"KomaMRIBase","title":"KomaMRIBase.get_Mk","text":"Mk, Mk_adc = get_Mk(seq::Sequence, k; Δt=1, skip_rf=zeros(Bool, sum(is_RF_on.(seq))))\n\nComputes the kth-order moment of the Sequence seq given by the formula int_0^T t^k G(t) dt.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nk: (::Integer) order of the moment to be computed\nΔt: (::Real, =1, [s]) nominal delta time separation between two time samples   for ADC acquisition and Gradients\nskip_rf: (::Vector{Bool}, =zeros(Bool, sum(is_RF_on.(seq)))) boolean vector which   indicates whether to skip the computation for resetting the integral for excitation or   refocusing RF type\n\nReturns\n\nMk: (3-column ::Matrix{Real}) kth-order moment\nMk_adc: (3-column ::Matrix{Real}) kth-order moment sampled at ADC times\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_kspace","page":"KomaMRIBase","title":"KomaMRIBase.get_kspace","text":"Computes the k-space trajectory of the Sequence seq. Refer to get_Mk and get_M0\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M0","page":"KomaMRIBase","title":"KomaMRIBase.get_M0","text":"Computes the zero-order moment of the Sequence seq. Refer to get_Mk and get_kspace\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M1","page":"KomaMRIBase","title":"KomaMRIBase.get_M1","text":"Computes the 1st-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M2","page":"KomaMRIBase","title":"KomaMRIBase.get_M2","text":"Computes the 2nd-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Event-checks","page":"KomaMRIBase","title":"Event checks","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"is_RF_on\nis_GR_on\nis_Gx_on\nis_Gy_on\nis_Gz_on\nis_ADC_on","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.is_RF_on","page":"KomaMRIBase","title":"KomaMRIBase.is_RF_on","text":"y = is_RF_on(x::Sequence)\ny = is_RF_on(x::Sequence, t::Vector{Float64})\n\nTells if the sequence seq has elements with RF active, or active during time t.\n\nArguments\n\nx: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the RF in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_GR_on","page":"KomaMRIBase","title":"KomaMRIBase.is_GR_on","text":"y = is_GR_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GR in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gx_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gx_on","text":"y = is_Gx_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in x direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRx in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gy_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gy_on","text":"y = is_Gy_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in y direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRy in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gz_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gz_on","text":"y = is_Gz_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in z direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRz in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_ADC_on","page":"KomaMRIBase","title":"KomaMRIBase.is_ADC_on","text":"y = is_ADC_on(x::Sequence)\ny = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})\n\nTells if the sequence seq has elements with ADC active, or active during time t.\n\nArguments\n\nx: (::Sequence) sequence struct\nt: (::Union{Array{Float64,1}, Array{Float64,2}}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the ADC in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#DiscreteSequence","page":"KomaMRIBase","title":"DiscreteSequence","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"DiscreteSequence\ndiscretize\nget_samples\ntimes\nampls\nfreqs","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.DiscreteSequence","page":"KomaMRIBase","title":"KomaMRIBase.DiscreteSequence","text":"seqd = DiscreteSequence(Gx, Gy, Gz, B1, Δf, ADC, t, Δt)\n\nA sampled version of a Sequence struct, containing vectors for event amplitudes at specified times. DiscreteSequence is the struct used for simulation.\n\nArguments\n\nGx: (::AbstractVector{T<:Real}, [T/m]) x-gradient vector\nGy: (::AbstractVector{T<:Real}, [T/m]) y-gradient vector\nGz: (::AbstractVector{T<:Real}, [T/m]) z-gradient vector\nB1: (::AbstractVector{Complex{T<:Real}}, [T]) RF amplitude vector\nΔf: (::AbstractVector{T<:Real}, [Hz]) RF carrier frequency displacement vector\nADC: (::AbstractVector{Bool}) ADC sample vector\nt: (::AbstractVector{T<:Real}, [s]) time vector\nΔt: (::AbstractVector{T<:Real}, [s]) delta time vector\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.discretize","page":"KomaMRIBase","title":"KomaMRIBase.discretize","text":"seqd = discretize(seq::Sequence; sampling_params=default_sampling_params())\n\nThis function returns a sampled Sequence struct with RF and gradient time refinements based on simulation parameters.\n\nArguments\n\nseq: (::Sequence) sequence\n\nKeywords\n\nsampling_params: (::Dict{String, Any}, =default_sampling_params()) sampling   parameter dictionary\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_samples","page":"KomaMRIBase","title":"KomaMRIBase.get_samples","text":"samples = get_samples(seq::Sequence; off_val=0, max_rf_samples=Inf)\n\nReturns the samples of the events in seq.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\noff_val: (::Number, =0) offset value for amplitude. Typically used to hide points in   plots by setting it to Inf\nmax_rf_samples: (::Integer, =Inf) maximum number of samples for the RF struct\n\nReturns\n\nsamples: (::NamedTuple) contains samples for gx, gy, gz, rf, and adc events.   Each event, represented by e::NamedTuple, includes time samples (e.t) and amplitude   samples (e.A)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.times","page":"KomaMRIBase","title":"KomaMRIBase.times","text":"t = times(gr::Grad)\nt = times(rf::RF)\nt = times(adc::ADC)\n\nGet time samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nt: (::Vector{Number}) vector with time samples\n\n\n\n\n\ntimes = times(motion)\n\n\n\n\n\ntimes \n\n\n\n\n\ntimes \n\n\n\n\n\ntimes = times(motion)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.ampls","page":"KomaMRIBase","title":"KomaMRIBase.ampls","text":"A = ampls(g::Grad)\nA = ampls(r::RF)\nA = ampls(d::ADC)\n\nGet amplitude samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nA: (::Vector{Number}) vector with amplitude samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.freqs","page":"KomaMRIBase","title":"KomaMRIBase.freqs","text":"f = freqs(r::RF)\n\nGet frequency samples of MRI sequence event.\n\nArguments\n\nrf: (::RF) RF struct\n\nReturns\n\nf: (::Vector{Number}) vector with frequency samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Other-functions","page":"KomaMRIBase","title":"Other functions","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"trapz\ncumtrapz\nkfoldperm","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.trapz","page":"KomaMRIBase","title":"KomaMRIBase.trapz","text":"y = trapz(Δt, x)\n\nTrapezoidal integration for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Δt for all the spins. NΔt is the length of Δt. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x 1 ::Matrix{Float64}, [T*s]) vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.cumtrapz","page":"KomaMRIBase","title":"KomaMRIBase.cumtrapz","text":"y = cumtrapz(Δt, x)\n\nTrapezoidal cumulative integration over time for every spin of a phantom.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x NΔt ::Matrix{Float64}, [T*s]) matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a   phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.kfoldperm","page":"KomaMRIBase","title":"KomaMRIBase.kfoldperm","text":"array_of_ranges = kfoldperm(N, k; breaks=[])\n\nDivides a list of indices from 1 to N into k groups.\n\nArguments\n\nN: (::Integer) number of elements to be ordered\nk: (::Integer) number of groups to divide the N elements.\n\nKeywords\n\nbreaks: (::Vector{<:Integer}, =[]) array of indices where predefined breakpoints are   placed.\n\nReturns\n\narray_of_ranges: (::Vector{UnitRange{<:Integer}}) array containing ranges of different   groups. The target is k groups, but this could increase by adding elements to the   breaks input array\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Sequence-Building-Blocks-(SBB)","page":"KomaMRIBase","title":"Sequence Building Blocks (SBB)","text":"","category":"section"},{"location":"reference/2-koma-base/","page":"KomaMRIBase","title":"KomaMRIBase","text":"PulseDesigner\nPulseDesigner.RF_hard\nPulseDesigner.RF_sinc\nPulseDesigner.EPI\nPulseDesigner.radial_base\nPulseDesigner.spiral_base\nPulseDesigner.EPI_example","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner","text":"PulseDesigner\n\nA module to define different pulse sequences.\n\n\n\n\n\n","category":"module"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_hard","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_hard","text":"seq = RF_hard(B1, T, sys; G=[0, 0, 0], Δf=0)\n\nReturns a sequence with a RF excitation pulse.\n\nArguments\n\nB1: (::Number, [T]) RF pulse amplitude\nT: (::Real, [s]) RF pulse duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_hard(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_sinc","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_sinc","text":"seq = RF_sinc(B1, T, sys; G=[0, 0, 0], Δf=0, a=0.46, TBP=4)\n\nReturns a sequence with a RF sinc waveform.\n\nReferences\n\nMatt A. Bernstein, Kevin F. King, Xiaohong Joe Zhou, Chapter 2 - Radiofrequency Pulse\n\nShapes, Handbook of MRI Pulse Sequences, 2004, Pages 35-66, https://doi.org/10.1016/B978-012092861-3/50006-6.\n\nArguments\n\nB1: (::Number, [T]) RF sinc amplitude\nT: (::Real, [s]) RF sinc duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\na: (::Real, =0.46) height appodization window parameter\nTBP: (::Real, =4) width appodization window parameter\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_sinc(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI","text":"seq = EPI(FOV::Real, N::Integer, sys::Scanner)\n\nReturns a sequence with EPI gradients.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels in the x and y axis\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct with EPI gradients\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.EPI(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.radial_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.radial_base","text":"seq = radial_base(FOV::Real, Nr::Integer, sys::Scanner)\n\nReturns a sequence with radial gradients for a single trajectory.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the diameter\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct of a single radial trajectory\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.radial_base(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.spiral_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.spiral_base","text":"spiral = spiral_base(FOV, N, sys; S0=sys.Smax*2/3, Nint=8, λ=Nint/FOV, BW=60e3)\n\nDefinition of a spiral base sequence.\n\nReferences\n\nGlover, G.H. (1999), Simple analytic spiral K-space algorithm. Magn. Reson. Med.,\n\n42: 412-415. https://doi.org/10.1002/(SICI)1522-2594(199908)42:2<412::AID-MRM25>3.0.CO;2-U\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the radious\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nS0: (::Vector{Real}, =sys.Smax*2/3, [T/m/s]) slew rate reference\nNint: (::Integer, =8) number of interleaves\nλ: (::Real, =Nint/FOV, [1/m]) kspace spiral parameter\nBW: (::Real, =60e3, [Hz]) adquisition parameter\n\nReturns\n\nspiral: (::Function) function that returns a Sequence struct when evaluated\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> spiral = PulseDesigner.spiral_base(FOV, N, sys)\n\njulia> seq = spiral(0)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI_example","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI_example","text":"seq = EPI_example(; sys=Scanner())\n\nReturns a sequence suitable for acquiring the 2D brain example in the provided examples.\n\nKeywords\n\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) EPI example Sequence struct\n\nExamples\n\njulia> seq = PulseDesigner.EPI_example();\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"how-to/4-run-distributed-simulations/#Run-Distributed-Simulations","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"While KomaMRI provides built-in support for CPU and GPU parallelization, it is sometimes desirable to distribute simulation work even further across multiple GPUs or compute nodes. This can be done by using Distributed.jl and making use of the independent spin property: each spin in the system is independent from the rest, so the phantom spins can be subdivided into separate simulations and results recombined, as in the diagram below:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNode.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"The following two examples demonstrate how to use Distributed.jl to run a simulation using multiple GPUS, and using multiple nodes in an HPC cluster.","category":"page"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-GPUs","page":"Run Distributed Simulations","title":"Using Multiple GPUs","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"To run a simulation using multiple GPUs, the phantom object can be divided using the kfoldperm function. Distributed.jl can then be used to start one Julia worker process per available device so that each device simulates a different part of the object. The results can then be fetched asynchronously by the main process and combined to produce a final signal. This is shown in the following diagram: ","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiGPU.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"The SLURM SBATCH script below requests 4 GPUs, all on a single computer. The Julia code then distributes work among each GPU:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"details: SLURM Script Requesting Multiple GPUs\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --ntasks=1                                 # 1 task\n#SBATCH --cpus-per-task=1                          # Request 1 CPU\n#SBATCH --gpus=4                                   # Request 4 GPUs\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"using Distributed\nusing CUDA\n\n#Add workers based on the number of available devices\naddprocs(length(devices()))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI, CUDA\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    #Divide phantom\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    KomaMRICore.set_device!(i-1) #Sets device for this worker, note that CUDA devices are indexed from 0\n    simulate(obj[parts[i]], seq, sys)\nend","category":"page"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-Nodes-in-an-HPC-Cluster","page":"Run Distributed Simulations","title":"Using Multiple Nodes in an HPC Cluster","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"This example uses the package ClusterManagers.jl to initialize worker processes on a SLURM cluster based on the number of tasks specified in the #SBATCH –ntasks directive. This can be useful to divide simulation work among multiple compute nodes if the problem is too large to fit into memory for a single computer, or if the number of desired workers is greater than the typical number of CPU cores available. An illustration of this is shown below:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNodeCPU.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"This SBATCH script requests 20 separate nodes, with each taking a single task. The Julia code is similar to the example for multiple GPUs, but initializes the processes slightly differently:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"details: SLURM Script Requesting Multiple Nodes\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --nodes=20                                 # 20 nodes\n#SBATCH --ntasks=20                                # 20 tasks\n#SBATCH --ntasks-per-node=1                        # 1 task per node\n#SBATCH --cpus-per-task=4                          # 4 CPUs per task\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"using Distributed\nusing ClusterManagers\n\n#Add workers based on the specified number of SLURM tasks\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    simulate(obj[parts[i]], seq, sys)\nend","category":"page"},{"location":"#Introduction","page":"🏠 Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"KomaMRI is a Julia package meant to simulate general Magnetic Resonance Imaging (MRI) scenarios. Its name comes from the Japanese word for spinning-top こま (ko-ma) as they precess due to gravity like spins in a magnetic field.","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"KomaMRI generates raw data by solving the Bloch equations using the specified scanner, phantom and sequence. It also provides a Graphical User Interface (GUI) that encapsulates the whole imaging pipeline (simulation and reconstruction).","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"<p align=\"center\"><img class=\"docs-light-only\" width=\"100%\" src=\"assets/koma-schema.svg\"/></p>\n<p align=\"center\"><img class=\"docs-dark-only\"  width=\"100%\" src=\"assets/koma-schema-dark.svg\"\"/></p>","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"We organized the documentation following the philosophy presented by David Laing.","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"details: How to Cite Koma\nIf you use Koma, please cite our paper:Plain Text:Castillo-Passi, C, Coronado, R, Varela-Mattatall, G, Alberola-López, C, Botnar, R, Irarrazaval, P. KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration. Magn Reson Med. 2023; 1- 14. doi: 10.1002/mrm.29635BibTex:@article{https://doi.org/10.1002/mrm.29635,\n        author = {Castillo-Passi, Carlos and Coronado, Ronal and Varela-Mattatall, Gabriel and Alberola-López, Carlos and Botnar, René and Irarrazaval, Pablo},\n        title = {KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration},\n        journal = {Magnetic Resonance in Medicine},\n        keywords = {Bloch equations, GPU, GUI, Julia, open source, simulation},\n        doi = {https://doi.org/10.1002/mrm.29635},\n        url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.29635},\n        eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/mrm.29635},\n}","category":"page"},{"location":"#Features","page":"🏠 Home","title":"Features","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"Fast simulations by using CPU and GPU parallelization 🏃💨.\nOpen Source, so anyone can include additional features 🆙.\nCompatibility with community-standards 🤝 like Pulseq .seq and ISMRMRD .mrd.\nCompatibility with Pluto and Jupyter notebooks 🎈\nInteractive visualizations using PlotlyJS.jl 📲\nCross-platform 🌐 thanks to the use of the Julia programming language.\nFriendly user interface for people with no programming skills 😌.\nFlexible API for advanced users 👨‍💻.","category":"page"},{"location":"#Potential-Use-Cases","page":"🏠 Home","title":"Potential Use Cases","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"The generation of synthetic data to train Machine Learning models.\nTo test novel pulse sequences before implementing them directly in a real scanner (with a Pulseq sequence).\nTeaching exercises for MRI acquisition or reconstruction.","category":"page"},{"location":"explanation/1-sequence/#Sequence","page":"Sequence","title":"Sequence","text":"","category":"section"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"This section delves into some details about how a sequence is constructed. The sequence definition in KomaMRI is strongly related to the Pulseq definition. After reading this section, you should be able to create your own Sequence structs for conducting custom simulations using the KomaMRI package.","category":"page"},{"location":"explanation/1-sequence/#Sequence-Overview","page":"Sequence","title":"Sequence Overview","text":"","category":"section"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"Let's introduce the following simple sequence figure to expand from a visual example to a more general sequence definition:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"<p align=\"center\"><img width=\"80%\" src=\"../../assets/sequence-diagram.svg\"/></p>","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"A sequence can be thought of as an ordered concatenation of blocks over time. Each block is essentially a sequence with a length of 1. Every block consists of an RF pulse, the (xyz) gradients, and the acquisition of samples. Each block also has an associated time duration. To simplify, we will refer to these components as follows:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"beginmatrix*l\ntextseqi        textblock i of the sequence \ntextseqRFi     textRF pulse at the i block \ntextseqGRxi   textgradient x at the i block \ntextseqGRyi   textgradient y at the i block \ntextseqGRzi   textgradient z at the i block \ntextseqADCi    textacquisition at the i block \ntextseqDURi    textduration at the i block\nendmatrix*","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"The best way to understand the Sequence struct in KomaMRI is by examining the source code where this struct is defined:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"mutable struct Sequence\n    GR::Array{Grad,2}\n    RF::Array{RF,2}\n    ADC::Array{ADC,1}\n    DUR::Array{Any,1}\n    DEF::Dict{String,Any}\nend","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"As you can see, a Sequence struct contains 5 field names: ''DEF'' contains information for reconstruction steps (so it is not mandatory to fill it), ''DUR'' is a vector that contains the time durations of each block, ''ADC'' is also a vector with the acquisition samples for every block (an vector of ADC structs), ''GR'' is a 2D matrix which 3 rows representing the x-y-z gradients and columns having the samples of each block (a matrix of Grad structs) and ''RF'' is also a 2D matrix where each row represents a different coil and the columns are for different block samples too (a matrix of RF structs). The RF, Grad and ADC are MRI events that will be explained in the section Events Definitions.","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"warning: Warning\nSo far, KomaMRI can only manage one coil for RF excitations. However, in future versions, parallel transmit pTX will be managed by adding more ``rows'' to the RF matrix of the Sequence field name.","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"In order to understand how a Sequence struct can be manipulated in Julia, let's use the EPI sequence example. You can display basic information of the Sequence variable in the Julia REPL:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq = PulseDesigner.EPI_example()\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"As you can see, this Sequence has 204 blocks, 1 of these blocks has an RF struct with values different from zero, there are 205 number of Grad structs considering the x-y-z components, 101 ADC structs acquire samples of some blocks and 62.846 ms is the total time duration of the complete Sequence.","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"To display the sequence in an graph, we can use the plot_seq function:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-epi-example-full.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"This way, you can see exactly where the RF, Grad and ADC structs are located in time.","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"You can access and filter information for the RF, Grad, ADC, and DUR field names of a Sequence using the dot notation. This allows you to display helpful information about the organization of the Sequence struct:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq.RF\n1×204 Matrix{RF}:\n ⊓(0.5872 ms)  ⇿(0.0 ms)  ⇿(0.0 ms)  …  ⇿(0.0 ms)  ⇿(0.0 ms)   \n\njulia> seq.GR\n3×204 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)  …  ⇿(0.2062 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)     ⊓(0.2062 ms)  ⇿(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> seq.ADC\n204-element Vector{ADC}:\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ⋮\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n\njulia> seq.DUR\n204-element Vector{Float64}:\n 0.0005871650124959989\n 0.0004042313086942605\n 0.0004042313086942605\n ⋮\n 0.0004042313086942605\n 0.0004042313086942605","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"Additionally, you can access a subset of blocks in a Sequence by slicing or indexing. The result will also be a Sequence struct, allowing you to perform the same operations as you would with a full Sequence. For example, if you want to analyze the first 11 blocks, you can do the following:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq[1:11].GR\n3×11 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)   …  ⊓(0.4042 ms)  ⇿(0.2062 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)      ⇿(0.4042 ms)  ⊓(0.2062 ms)  ⇿(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> plot_seq(seq[1:11]; slider=false)","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-epi-example-some-blocks.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/1-sequence/#Concatenation-of-Sequences","page":"Sequence","title":"Concatenation of Sequences","text":"","category":"section"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"Sequences can be concatenated side by side. The example below demonstrates how to concatenate sequences:","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"julia> s = PulseDesigner.EPI_example()[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq = s + s + s\nSequence[ τ = 11.512 ms | blocks: 33 | ADC: 15 | GR: 33 | RF: 3 | DEF: 5 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/1-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-concatenation.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"reference/1-api/#API-Overview","page":"API Overview","title":"API Overview","text":"","category":"section"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/koma-schema-subdirs.svg\"/></p>","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"KomaMRI is divided into the following sub-packages:","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"KomaMRIBase: Custom types and functions\nKomaMRICore: Simulation functions\nKomaMRIFiles: File I/O functions\nKomaMRIPlots: Plotting functions\nKomaMRI: User Interface","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"The idea of separating the package into sub-packages is to make it easier to maintain and to allow users to use only the parts they need. Two common use-cases can be:","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"GUI users: They will use the KomaMRI package to interact with the GUI. Internally this includes al the others.\nAdvanced users: They will use the sub-packages directly to build their own scripts or notebooks, for simulation only KomaMRICore is required.","category":"page"}]
}
