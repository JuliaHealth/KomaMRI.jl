var documenterSearchIndex = {"docs":
[{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. ","category":"page"},{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"Files matching the pluto-*.jl pattern anywhere in examples/4.reproducible_notebooks will be included.","category":"page"},{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"All files included in this folder will be ignored.","category":"page"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/#Understanding-basic-MRI-sequences","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"","category":"section"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"<iframe type=\"text/html\" src=\"../01-gradient-echo-spin-echo.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"page"},{"location":"tutorial/06-DiffusionMotion/#Diffusion-induced-Signal-Attenuation","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"","category":"section"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"using KomaMRI # hide\nusing PlotlyJS # hide\nusing Random # hide","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"The purpose of this tutorial is to showcase the simulation of diffusion-related effects. For this, we are going to define a Path motion to simulate the Brownian motion of spins. This is not the most efficient way of simulating diffusion, but it is a good way to understand the phenomenon. In particular, we will going to simulate isotropic diffusion, characterized by the Apparent Diffusion Coefficient (ADC).","category":"page"},{"location":"tutorial/06-DiffusionMotion/#Creating-a-phantom-with-isotropic-diffusion","page":"Diffusion-induced Signal Attenuation","title":"Creating a phantom with isotropic diffusion","text":"","category":"section"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"First we will define a Phantom without motion containing 10000 spins. The spins will have the same relaxation times T_1 = 1000mathrmms and T_2 = 100mathrmms, and will be placed at the origin.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Nspins = 10_000\nobj = Phantom(;\n    x  = zeros(Nspins),\n    T1 = ones(Nspins) * 1000e-3,\n    T2 = ones(Nspins) * 100e-3,\n)","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Now we will define the Brownian motion of the spins using the Path motion definition. The motion will be defined by the displacements in the x, y, and z directions (dx, dy, and dz) of the spins. The displacements will be generated by a random walk with mean square displacement","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"mathbbEleftx^2right=2D Δt","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"where D is the diffusion coefficient and Δt is time step duration.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"D = 2e-9               # Diffusion Coefficient of water in m^2/s\nT = 100e-3             # Duration of the motion\nNt = 100               # Number of time steps\nΔt = T / (Nt - 1)      # Time sep\nΔr = sqrt(2 * D * Δt)  # √ Mean square displacement","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Random walk is defined as the cumulative sum of random displacements:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"rng = MersenneTwister(1234) # Setting up the random seed\ndx = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2)\ndy = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2)\ndz = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2)","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Including the random_walk into the Phantom definition:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"random_walk = Path(dx, dy, dz, TimeRange(0.0, T))\nobj.motion = random_walk\np1 = plot_phantom_map(obj, :T1; time_samples=Nt÷4, height=450)\n\nsavefig(p1, \"../assets/6-displacements.html\") # hide","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"<center><object type=\"text/html\" data=\"../../assets/6-displacements.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"The plot shows the random walk of spins due to diffusion, also known as Brownian motion. This motion was named after Robert Brown, who first described the phenomenon in 1827 while looking at pollen suspended in water under a microscope.","category":"page"},{"location":"tutorial/06-DiffusionMotion/#Pulse-Gradient-Spin-Echo-(PGSE)-sequence","page":"Diffusion-induced Signal Attenuation","title":"Pulse Gradient Spin Echo (PGSE) sequence","text":"","category":"section"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"The classical sequence used to measure diffusion is the pulse gradient spin echo (PGSE) introduced by Stejskal and Tanner in 1965. This sequence is characterized by the use of two diffusion gradients, placed right before and right after the inversion RF pulse. The duration of each gradient is defined by the δ parameter and the distance between the beginning of both gradients is described by the Δ parameter. In this tutorial square-shaped gradients will be used.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"First, we generate the RF pulses:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"sys   = Scanner()\ndurRF = 1e-3\nB1    = (π / 2) / (2π * γ * durRF)\nrf90  = PulseDesigner.RF_hard(B1, durRF, sys)\nrf180 = (0.0 + 2im) * rf90","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Now we generate the gradients:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"G = 30e-3            # Gradient amplitude\nδ = 30e-3            # Duration of the gradient\nΔ = durRF + δ        # Time between the two gradients\ngx_diff = Grad(G, δ)","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Finally, we generate the ADC:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"adc_dwell_time = 1e-6\nadc = ADC(1, adc_dwell_time, durRF/2 - adc_dwell_time/2) # ADCs with N=1 are positioned at the center","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"Obtaining the PGSE sequence:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"seq = Sequence()\nseq += rf90\nseq += gx_diff\nseq += rf180\nseq += gx_diff\nseq += adc\np2 = plot_seq(seq; show_adc=true) # Plotting the sequence\n\nsavefig(p2, \"../assets/6-pgse_sequence.html\") # hide","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"<center><object type=\"text/html\" data=\"../../assets/6-pgse_sequence.html\" style=\"width:100%; height:300px;\"></object></center>","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"For the isotropic diffusion, the signal attenuation is given by the Stejskal-Tanner formula:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"E = expleft(-b Dright)","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"where (b) is the b-value, defined as:","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"b = (gamma G delta)^2 cdot left(Delta - delta3right)","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"where gamma is the gyromagnetic ratio, G is the gradient amplitude, delta is the gradient duration, and Delta is the time between the two gradients.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"function bvalue(seq)\n    block, axis = 2, 1 # Gx from second block\n    G = seq.GR[axis, block].A\n    δ = seq.GR[axis, block].T\n    Δ = dur(seq[2:3]) # Because there are no gaps\n    b = (2π * γ * G * δ)^2 * (Δ - δ/3)\n    return b * 1e-6\nend","category":"page"},{"location":"tutorial/06-DiffusionMotion/#Diffusion-Weighted-Imaging-(DWI)","page":"Diffusion-induced Signal Attenuation","title":"Diffusion Weighted Imaging (DWI)","text":"","category":"section"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"For DWI, multiple b-values are acquired to determine the tissue's ADC. For this, we will scale the gradient's amplitude of the previous sequence to obtain a desired b-value. We will store the sequences in a vector seqs and simulate the signal for each one of them.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"seqs = Sequence[] # Vector of sequences\nbvals = [0, 250, 500, 1000, 1500, 2000] # b-values in s/mm^2\nfor bval_target in bvals\n    gradient_scaling = sqrt(bval_target / bvalue(seq))\n    seq_b = gradient_scaling * seq\n    push!(seqs, seq_b)\nend","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"To simulate, we will broadcast the simulate function over the sequences and store the signals in a vector Sb. The Ref's are used to avoid broadcasting the obj and sys arguments (they will remain constant for all seqs).","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"sim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"Δt\"] = Δt # Set max. grad. time step to fit diffusion time step\n\nsignals = simulate.(Ref(obj), seqs, Ref(sys); sim_params) # simulate broadcasted over seqs\n\nSb = [sb[1] for sb in signals] # Reshaping the simulated signals\nbvals_si = bvals .* 1e6 # Convert b-values from s/mm^2 to s/m^2\n\nE_simulated   = abs.(Sb) ./ abs.(Sb[1])\nE_theoretical = exp.(-bvals_si .* D)\n\ns_sim  = scatter(x=bvals, y=E_simulated,   name=\"Simulated\") # hide\ns_theo = scatter(x=bvals, y=E_theoretical, name=\"exp(-b D)\", line=attr(dash=\"dash\")) # hide\nlayout = Layout(title=\"Diffusion-induced signal attenuation E(b)\", xaxis=attr(title=\"b-value [s/mm^2]\")) # hide\np3 = plot([s_sim, s_theo], layout) # hide\n\nsavefig(p3, \"../assets/6-pgse_signal_attenuation.html\") # hide","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"<center><object type=\"text/html\" data=\"../../assets/6-pgse_signal_attenuation.html\" style=\"width:80%; height:400px;\"></object></center>","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"The plot shows the signal attenuation as a function of the b-value. The simulated signal attenuation matches the theoretical curve, showing the expected exponential decay with the b-value.","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"","category":"page"},{"location":"tutorial/06-DiffusionMotion/","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/6-simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"explanation/6-simulation/#General-Overview","page":"Simulation","title":"General Overview","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"KomaMRI simulates the magnetization of each spin of a Phantom for variable magnetic fields given by a Sequence. It is assumed that a single spin is independent of the state of the other spins in the system (a key feature that enables parallelization). Furthermore, there are defined two regimes in the Sequence: excitation and precession. During the latter, the excitation fields are nulled and are useful for simplifying some physical equations.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The are more internal considerations in the KomaMRI implementation. The Figure 1 summarizes the functions called to perform the simulation.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<center><img width=\"100%\" src=\"../../assets/koma-solution.svg\"></center>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"Figure 1: The sequence seq is discretized after calculating the required time points in the wrapper function simulate. The time points are then divided into Nblocks to reduce the amount of memory used. The phantom obj is divided into Nthreads, and KomaMRI will use either run_spin_excitation! or run_spin_precession! depending on the regime. If an ADC object is present, the simulator will add the signal contributions of each thread to construct the acquired signal sig[t]. All the parameters: Nthreads, Nblocks, Δt_rf, and Δt, are passed through a dictionary called sim_params as an optional parameter of the simulate function.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"From the programming perspective, it is needed to call the simulate function with the sim_params dictionary keyword argument. A user can change the values of the following keys:","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"Parameter Description\n\"return_type\" defines the output of the simulate function. Possible values are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco RawAcquisitionData, the signal values, and the last magnetization state of the simulation, respectively.\n\"sim_method\" defines the type of simulation. The default value is Bloch(), but you can alternatively use the BlochDict() simulation method. Moreover, you have the flexibility to create your own methods without altering the KomaMRI source code; for further details, refer to the Simulation Method Extensibility section.\n\"Δt\" raster time for gradients.\n\"Δt_rf\" raster time for RFs.\n\"precision\" defines the floating-point simulation precision. You can choose between \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively. It's important to note that, especially for GPU operations, using \"f32\" is generally much faster.\n\"Nblocks\" divides the simulation into a specified number of time blocks. This parameter is designed to conserve RAM resources, as KomaMRI computes a series of simulations consecutively, each with the specified number of blocks determined by the value of \"Nblocks\".\n\"Nthreads\" divides the Phantom into a specified number of threads. Because spins are modeled independently of each other, KomaMRI can solve simulations in parallel threads, speeding up the execution time.\n\"gpu\" is a boolean that determines whether to use GPU or CPU hardware resources, as long as they are available on the host computer.\n\"gpu_device\" sets the index ID of the available GPU in the host computer.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"For instance, if you want to perform a simulation on the CPU with float64 precision using the BlochDict() method (assuming you have already defined obj, seq and sys), you can do so like this:","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"# Set non-default simulation parameters and run simulation\nsim_params = KomaMRICore.default_sim_params() \nsim_params[\"gpu\"] = false\nsim_params[\"precision\"] = \"f64\"\nsim_params[\"sim_method\"] = BlochDict()\nraw = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"Additionally, the user must be aware of the functions run_spin_excitation! and run_spin_precession! which defines the algorithm for excitation and precession regimes respectively and can be changed by the user without modifying the source code (more details at Simulation Method Extensibility).","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"Previous simulation, the Sequence is discretized to consider specific time points which are critical for simulation. The user can control the time between intermediate gradient samples with the parameter Δt. Similarly, the parameter Δt_rf manages the time between RF samples, and can be relatively large for 2D imaging where the slice profile is less relevant.","category":"page"},{"location":"explanation/6-simulation/#Computation-Efficiency","page":"Simulation","title":"Computation Efficiency","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"To reduce the memory usage of our simulator, we subdivided time into Nblocks. KomaMRI classifies each block in either the excitation regime or the precession regime before the simulation.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"We increased the simulation speed by separating the calculations into Nthreads and then performing the GPU parallel operations with CUDA.jl . This separation is possible as all magnetization vectors are independent of one another.","category":"page"},{"location":"explanation/6-simulation/#Simulation-Method-Extensibility","page":"Simulation","title":"Simulation Method Extensibility","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"In Julia, functions use different methods based on the input types via multiple dispatch. We used this to specialize the simulation functions for a given sim_method <:SimulationMethod specified in sim_params. For a given simulation method, the function initialize_spin_state outputs a variable Xt <: SpinStateRepresentation that is passed through the simulation (Figure 1). For the default simulation method Bloch, the spin state is of type Mag, but can be extended to a custom representation, like for example EPGs44 or others. Then, the functions run_spin_excitation! and run_spin_precession! can be described externally for custom types sim_method and Xt, extending Koma’s functionalities without the need of modifying the source code and taking advantage of all of Koma’s features.","category":"page"},{"location":"explanation/6-simulation/#Bloch-Simulation-Method","page":"Simulation","title":"Bloch Simulation Method","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"This is the default simulation method used by KomaMRI, however it can always be specified by setting the sim_method = Bloch() entry of the sim_params dictionary. In the following subsection, we will explain the physical and mathematical background and some considerations and assumptions that enables to speed up the simulation.","category":"page"},{"location":"explanation/6-simulation/#Physical-and-Mathematical-Background","page":"Simulation","title":"Physical and Mathematical Background","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The Bloch method of KomaMRI simulates the magnetization of each spin by solving the Bloch equations in the rotating frame:","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag1\n\nfracmathrmd boldsymbolMmathrmd t =\n  gamma boldsymbolM times boldsymbolB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1 \n\nendalign","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"with gamma the gyromagnetic ratio, boldsymbolM = M_x M_y M_z^T the magnetization vector, and","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"boldsymbolB = B_1x(t) B_1y(t) boldsymbolG(t) cdot boldsymbolx + Delta omega(t)^T","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"the effective magnetic field. M_0 is the proton density, T_1 and T_2 are the relaxation times, and Delta omega is the off-resonance, for each position.","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The Bloch Simulation Method also uses the technique of operator splitting to simplify the solution of Equation (1). This reflects mathematically the intuition of separating the Bloch equations in a rotation operator described by","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag2\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n 0            gamma B_z  -gamma B_y \n-gamma B_z   0            gamma B_x \n gamma B_y  -gamma B_x   0\nendbmatrix\nboldsymbolM \n\nendalign","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"and a relaxation operator described by","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"beginalign tag3\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n-tfrac1T_2  0  0 \n0  -tfrac1T_2  0 \n0  0  -tfrac1T_1\nendbmatrix\nboldsymbolM\n+\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix \n\nendalign","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The evolution of the magnetization can then be described as a two-step process for each time step Delta t (Figure 2).","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<p align=\"center\">\n<figure>\n  <img width=\"60%\" src=\"../../assets/block-equation-intuition.svg\">\n  <figcaption><b>Figure 2</b>: Solution of the Bloch equations for one time step can be described by (2) a rotation and (3) a relaxation step.</figcaption>\n</figure>\n</p>","category":"page"},{"location":"explanation/6-simulation/#Bloch()-Method-Example","page":"Simulation","title":"Bloch() Method Example","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"We will consider an RF pulse that excites a phantom with 3 spins, and then we acquire the data:","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<details><summary>View code</summary>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"# Import modules\nusing KomaMRI\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"</details>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The resulting signal from the Bloch() method is the sum of magnetizations in the transverse plane (x, y):","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"# Configure Bloch() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = Bloch()\nsig = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot(abs.(sig[:,1,1]))","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/6-simulation/#BlochDict-Simulation-Method","page":"Simulation","title":"BlochDict Simulation Method","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"This is another simulation method defined in the source code of KomaMRI. You can specify it by setting the sim_method = BlochDict() entry in the sim_params dictionary. Additionally, it offers the option to save the resulting signal in the z-component by using sim_method = BlochDict(save_Mz=true). This method allows you to store the magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z) if specified.","category":"page"},{"location":"explanation/6-simulation/#BlochDict()-Method-Example","page":"Simulation","title":"BlochDict() Method Example","text":"","category":"section"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"We are going to consider the same setup as in the Bloch() Method Example. This includes the same excitation, acquisition, and the same 3-spin phantom:","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<details><summary>View code</summary>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"# Import modules\nusing KomaMRI, PlotlyJS\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"</details>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"The resulting signal from the BlochDict() method comprises the individual magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z):","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"# Configure BlochDict() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = BlochDict(save_Mz=true)\nsig = simulate(obj, seq, sys; sim_params)\n\n# Define the plots for traverse and longitudinal magnetizations\npxy = plot(abs.(sig[:,:,1]));\npz = plot(abs.(sig[:,:,2]));","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"julia> [pxy pz]","category":"page"},{"location":"explanation/6-simulation/","page":"Simulation","title":"Simulation","text":"<object type=\"text/html\" data=\"../../assets/sim-blochdict-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Create-Your-Own-Phantom","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In this section, we will create some custom Phantom structs.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In KomaMRI, the creation of a Phantom struct involves defining spin position arrays (x, y, z) and spin property arrays.  The indices of these arrays are then associated with independent spins. See the Phantom explanation section for more information about how digital phantoms work in KomaMRI. ","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Basic-case:-1-spin-phantom","page":"Create Your Own Phantom","title":"Basic case: 1-spin phantom","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"You can create a Phantom with one spin like so:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define arrays of positions (spin at zero position)\nx = [0.0]\ny = [0.0]\nz = [0.0]\n\n# Define arrays of properties (for CSF tissue)\nρ = [1.0]\nT1 = [2.569]\nT2 = [0.329]\nT2s = [0.058]\n\n# Define the phantom\nspin = Phantom(name=\"spin\", x=x, y=y, z=z, ρ=ρ, T1=T1, T2=T2, T2s=T2s)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Phantom{Float64}\n  name: String \"spin\"\n  x: Array{Float64}((1,)) [0.0]\n  y: Array{Float64}((1,)) [0.0]\n  z: Array{Float64}((1,)) [0.0]\n  ρ: Array{Float64}((1,)) [1.0]\n  T1: Array{Float64}((1,)) [2.569]\n  T2: Array{Float64}((1,)) [0.329]\n  T2s: Array{Float64}((1,)) [0.058]\n  Δw: Array{Float64}((1,)) [0.0]\n  Dλ1: Array{Float64}((1,)) [0.0]\n  Dλ2: Array{Float64}((1,)) [0.0]\n  Dθ: Array{Float64}((1,)) [0.0]\n  motion: NoMotion NoMotion()","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"You can add more properties to the Phantom, such as off-resonance, diffusion parameters, and even motion information.","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Loading-phantom-data-from-a-.mat-file","page":"Create Your Own Phantom","title":"Loading phantom data from a .mat file","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"If you are familiar with the MRI world, you likely have a 2D or 3D array, where each element contains an ID number identifying a different class of tissue. In this setup, the array axes represent spatial positions, while the elements are used for tissue identification.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In this example, we will utilize a .mat file containing arrays with such arrangements. The file is readily available upon installing KomaMRI. Let's read the file and store the 2D data in an array called class:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Get data from a .mat file\npath_koma = dirname(dirname(pathof(KomaMRI)))\npath_phantom_mat = joinpath(path_koma, \"KomaMRIBase\", \"src\", \"datatypes\", \"phantom\", \"pelvis2D.mat\")\ndata = KomaMRIFiles.matread(path_phantom_mat)\nclass = data[\"pelvis3D_slice\"]","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"You can visualize the tissue map using the plot_image function:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"plot_image(class)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/create-your-own-phantom-class-map.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Let's define the position arrays. You need to know the distance between the spins in the original array (in this case, it is 0.5mm), and then you can determine all the positions like this (the z-component is not calculated since this is a 2D example):","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define spin position arrays\nΔx = .5e-3                  # 0.5mm\nM, N = size(class)          # Number of spins in x and y\nFOVx = (M-1)*Δx             # Field of view in x\nFOVy = (N-1)*Δx             # Field of view in y\nx = -FOVx/2:Δx:FOVx/2       # x spin coordinates vector\ny = -FOVy/2:Δx:FOVy/2       # y spin coordinates vector\nx, y = x .+ y'*0, x*0 .+ y' # x and y grid points","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Now, let's define the arrays for the properties. It's essential to have prior knowledge of the property values for different tissue classes. For example, for soft tissue, we use ρ = 0.9, T1 = 1200 * 1e-3, T2 = 80 * 1e-3, and T2s = 80 * 1e-3. Additionally, we create an array mask to identify the location of a tissue's ID. For soft tissue with ID = 153, the mask is (class .== 153). Finally, to obtain a property, sum all the masks with values for all tissue classes. This process is illustrated below: ","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define the proton density array\nρ = (class.==102)*.86 .+    # Fat\n    (class.==153)*.9 .+     # SoftTissue\n    (class.==204)*.4 .+     # SpongyBone\n    (class.==255)*.2        # CorticalBone\n\n# Define the T1 decay array\nT1 = (class.==102)*366 .+   # Fat\n    (class.==153)*1200 .+   # SoftTissue\n    (class.==204)*381 .+    # SpongyBone\n    (class.==255)*100       # CorticalBone\n\n# Define the T2 decay array\nT2 = (class.==102)*70 .+    # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define the T2s decay array\nT2s = (class.==102)*70 .+   # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define off-resonance array\nΔw_fat = -220 * 2π\nΔw = (class.==102) * Δw_fat # FAT1\n\n# Adjust with scaling factor\nT1 = T1*1e-3\nT2 = T2*1e-3\nT2s = T2s*1e-3","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Finally, we can invoke the Phantom constructor. However, before doing so, we choose not to store spins where the proton density is zero to avoid unnecessary data storage. This is achieved by applying the mask ρ.!=0 to the arrays. Additionally, please note that we set the z-position array filled with zeros.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"# Define the phantom\nobj = Phantom{Float64}(\n    name = \"custom-pelvis\",\n\tx = x[ρ.!=0],\n\ty = y[ρ.!=0],\n\tz = 0*x[ρ.!=0],\n\tρ = ρ[ρ.!=0],\n\tT1 = T1[ρ.!=0],\n\tT2 = T2[ρ.!=0],\n\tT2s = T2s[ρ.!=0],\n\tΔw = Δw[ρ.!=0],\n)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"We can display the Phantom struct with the plot_phantom_map function. In this case we select the T1 decay to be displayed, but you can choose other property to be displayed:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"plot_phantom_map(obj, :T1)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"<object type=\"text/html\" data=\"../../assets/create-your-own-phantom-pelvis-T1.html\" style=\"width:85%; height:470px;\"></object>","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Creating-a-custom-flow-cylinder-phantom","page":"Create Your Own Phantom","title":"Creating a custom flow cylinder phantom","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"This section shows how to create a slightly more complex phantom, which includes flow, from scratch. ","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"The phantom is modelled as a vertical cylindrical tube, with outer radius of 10 mm, an inner radius of 4.5 mm, and a length of 40 mm.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"First, we generate the 3D grid that defines the spatial layaout of the spins:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"R = 10e-3; r = 4.5e-3; L = 40e-3; Δx = 1e-3\n\n#POSITIONS\nx = -R:Δx:R\ny = -R:Δx:R \nz = -L/2:Δx:L/2\n\nxx = reshape(x, (length(x),1,1)) \nyy = reshape(y, (1,length(y),1)) \nzz = reshape(z, (1,1,length(z))) \n\n# Grid\nx = 1*xx .+ 0*yy .+ 0*zz\ny = 0*xx .+ 1*yy .+ 0*zz\nz = 0*xx .+ 0*yy .+ 1*zz","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Then, we separate the grid into two regions. The boolean array bl marks the inner part of the tube, where the \"blood\" spins should flow,  while the ts array identifies the surrounding tissue, which must remain static. The ⚪(R) function helps us with this task:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"⚪(R) =  (x.^2 .+ y.^2 .<= R^2) # circle of radius R\n\nts = Bool.(⚪(R) - ⚪(r))\nbl = Bool.(⚪(r))","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Once each region is defined, we can go ahead and create the phantom. It is often convenient to generate the phantoms for each region separately. Let's start with the static outer tissue, which is very straightforward. We’ll assign it PD, T1, and T2 values of 1.0, 700 ms, and 42 ms, respectively:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"PD = 1.0; T1 = 700e-3; T2 = 42e-3\n\ntissue = Phantom(\n    name=\"Tissue\",\n    x=x[ts],\n    y=y[ts],\n    z=z[ts],\n    ρ=PD.*ones(length(x[ts])),\n    T1=T1.*ones(length(x[ts])),\n    T2=T2.*ones(length(x[ts]))\n)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Phantom{Float64}\n  name: String \"Tissue\"\n  x: Array{Float64}((10168,)) [0.0, -0.004, -0.003, -0.002, -0.001  …  0.0, 0.001, 0.002, 0.003, 0.004, 0.0]\n  y: Array{Float64}((10168,)) [-0.01, -0.009, -0.009, -0.009, -0.009  …  0.009, 0.009, 0.009, 0.009, 0.01]\n  z: Array{Float64}((10168,)) [-0.02, -0.02, -0.02, -0.02, -0.02  …  0.02, 0.02, 0.02, 0.02, 0.02, 0.02]\n  ρ: Array{Float64}((10168,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  T1: Array{Float64}((10168,)) [0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7  …  0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7]\n  T2: Array{Float64}((10168,)) [0.042, 0.042, 0.042, 0.042, 0.042  …  0.042, 0.042, 0.042, 0.042, 0.042]\n  T2s: Array{Float64}((10168,)) [1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6  …  1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6]\n  Δw: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: NoMotion NoMotion()","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Now, we repeat the process for the blood spins inside the tube. For this region, the PD, T1, and T2 values will be 0.9, 1200 ms, and 92 ms, respectively.","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"To define the flow movement for these inner spins, we need to create a FlowPath motion. This will include both the trajectories followed by each spin and the flags that indicate when a spin leaves the phantom's domain (at the upper end) and is reinjected at the lower end of the cylinder:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"PD = 0.9; T1 = 1200e-3; T2 = 92e-3\n\nNt = 500    # Number of discrete time nodes\nv  = 200e-3 # 200 mm/s \n\ndx = dy = zeros(length(z[bl]), Nt)\ndz =z[bl] .+ cumsum(L/Nt .+ zeros(1,Nt), dims=2)\n\nspin_reset = dz .> L/2\nfor i in 1:size(spin_reset, 1)\n    idx = findfirst(x -> x == 1, spin_reset[i, :])\n    if idx !== nothing\n        spin_reset[i, :]  .= 0\n        spin_reset[i, idx] = 1 # Activate the flag at the NEXT node after the jump\n    end\nend\n\ndz[dz .> L/2] .-= L\ndz .-= z[bl]\n\nblood = Phantom(\n    name=\"Blood\",\n    x=x[bl],\n    y=y[bl],\n    z=z[bl],\n    ρ =PD.*ones(length(x[bl])),\n    T1=T1.*ones(length(x[bl])),\n    T2=T2.*ones(length(x[bl])),\n    motion=FlowPath(dx, dy, dz, spin_reset, Periodic(L/v, 1.0-1e-6))\n)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Phantom{Float64}\n  name: String \"Blood\"\n  x: Array{Float64}((2829,)) [-0.002, -0.001, 0.0, 0.001, 0.002  …  -0.002, -0.001, 0.0, 0.001, 0.002]\n  y: Array{Float64}((2829,)) [-0.004, -0.004, -0.004, -0.004  …  0.004, 0.004, 0.004, 0.004, 0.004]\n  z: Array{Float64}((2829,)) [-0.02, -0.02, -0.02, -0.02, -0.02  …  0.02, 0.02, 0.02, 0.02, 0.02, 0.02]\n  ρ: Array{Float64}((2829,)) [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9  …  0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]\n  T1: Array{Float64}((2829,)) [1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2  …  1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]\n  T2: Array{Float64}((2829,)) [0.092, 0.092, 0.092, 0.092, 0.092  …  0.092, 0.092, 0.092, 0.092, 0.092]\n  T2s: Array{Float64}((2829,)) [1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6  …  1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6]\n  Δw: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: Motion{Float64}","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Last, we obtain the final obj as the sum of both phantoms:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"obj = tissue + blood\n\nplot_phantom_map(obj, :T1; time_samples=11)","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"<object type=\"text/html\" data=\"../../assets/create-your-own-phantom-flow-T1.html\" style=\"width:85%; height:470px;\"></object>","category":"page"},{"location":"how-to/3-create-your-own-phantom/#Importing/exporting-phantoms-(.phantom-file-format)","page":"Create Your Own Phantom","title":"Importing/exporting phantoms (.phantom file format)","text":"","category":"section"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"Another option to create your own phantom is to import it directly from a .phantom file. To demonstrate this, we will first create the file from the previous phantom, using the write_phantom function, and then we will read it using the read_phantom function:","category":"page"},{"location":"how-to/3-create-your-own-phantom/","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"julia> write_phantom(obj, \"flow_cylinder.phantom\")\n# Now, you could even close Julia, turn off your computer...\njulia> obj2 = read_phantom(\"flow_cylinder.phantom\")","category":"page"},{"location":"reference/5-koma-plots/#KomaMRIPlots","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"","category":"section"},{"location":"reference/5-koma-plots/#Plotting-Phantom","page":"KomaMRIPlots","title":"Plotting Phantom","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_phantom_map","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_phantom_map","text":"p = plot_phantom_map(obj::Phantom, key::Symbol; kwargs...)\n\nPlots a phantom map for a specific spin parameter given by key.\n\nArguments\n\nobj: (::Phantom) Phantom struct\nkey: (::Symbol, opts: [:ρ, :T1, :T2, :T2s, :x, :y, :z]) symbol for   displaying different parameters of the phantom spins\n\nKeywords\n\nheight: (::Integer, =600) plot height\nwidth: (::Integer, =nothing) plot width\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nview_2d: (::Bool, =false) boolean to indicate whether to use a 2D scatter plot\ncolorbar: (::Bool, =true) boolean to indicate whether to display a colorbar\nmax_spins:(::Int, =20_000) maximum number of displayed spins\ntime_samples:(::Int, =0) intermediate time samples between motion t_start and t_end\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the phantom map for a specific spin parameter\n\nReferences\n\nColormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).\n\nExamples\n\njulia> obj2D, obj3D = brain_phantom2D(), brain_phantom3D();\n\njulia> plot_phantom_map(obj2D, :ρ)\n\njulia> plot_phantom_map(obj3D, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-Sequence","page":"KomaMRIPlots","title":"Plotting Sequence","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seq","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seq","text":"p = plot_seq(seq::Sequence; kwargs...)\n\nPlots a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\nfreq_in_phase: (::Bool, =true) Include FM modulation in RF phase\ngl: (::Bool, =false) use PlotlyJS.scattergl backend (faster)\nmax_rf_samples: (::Integer, =100) maximum number of RF samples\nshow_adc: (::Bool, =false) plot ADC samples with markers\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_kspace","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_kspace","text":"p = plot_kspace(seq::Sequence; width=nothing, height=nothing, darkmode=false)\n\nPlots the k-space of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the k-space of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M0","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M0","text":"p = plot_M0(seq::Sequence; kwargs...)\n\nPlots the zero order moment (M0) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M0 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M0(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M1","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M1","text":"p = plot_M1(seq::Sequence; kwargs...)\n\nPlots the first order moment (M1) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M1 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M1(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M2","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M2","text":"p = plot_M2(seq::Sequence; kwargs...)\n\nPlots the second order moment (M2) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M2 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M2(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_eddy_currents","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_eddy_currents","text":"p = plot_eddy_currents(seq::Sequence, λ; kwargs...)\n\nPlots the eddy currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nλ: (::Real, [s]) time constant for the decay of Eddy currents\n\nKeywords\n\nα: (::Vector{Real}, =ones(size(λ))) eddy currents factors\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Eddy currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_eddy_currents(seq, 80e-3)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_slew_rate","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_slew_rate","text":"p = plot_slew_rate(seq::Sequence; kwargs...)\n\nPlots the slew rate currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the slew rate currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_slew_rate(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seqd","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seqd","text":"p = plot_seqd(seq::Sequence; sampling_params=KomaMRIBase.default_sampling_params())\n\nPlots a sampled sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nsampling_params: (::Dict{String,Any}(), =KomaMRIBase.default_sampling_params()) dictionary of   sampling parameters\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the sampled Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seqd(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-RawAcquisitionData","page":"KomaMRIPlots","title":"Plotting RawAcquisitionData","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_signal","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_signal","text":"p = plot_signal(raw::RawAcquisitionData; kwargs...)\n\nPlots a raw signal in ISMRMRD format.\n\nArguments\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct (raw signal in ISMRMRD format)\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_sim_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the raw signal\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Plotting-images","page":"KomaMRIPlots","title":"Plotting images","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_image","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_image","text":"p = plot_image(image; height, width, zmin, zmax, darkmode, title)\n\nPlots an image matrix.\n\nArguments\n\nimage: (::Matrix{Number}) image matrix\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nzmin: (::Real, =minimum(abs.(image[:]))) reference value for minimum color\nzmax: (::Real, =maximum(abs.(image[:]))) reference value for maximum color\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the image matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#Others","page":"KomaMRIPlots","title":"Others","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_dict","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_dict","text":"str = plot_dict(dict::Dict)\n\nGenerates an HTML table based on the dictionary dict.\n\nArguments\n\ndict: (::Dict) dictionary\n\nReturns\n\nstr: (::String) dictionary as an HTML table\n\n\n\n\n\n","category":"function"},{"location":"tutorial/01-FID/#Free-Induction-Decay","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"section"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"First of all, let's use the KomaMRI package and define the default scanner.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"using KomaMRI\nsys = Scanner() # default hardware definition","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The free induction decay is the simplest observable NMR signal. This signal is the one that follows a single tipping RF pulse. To recreate this experiment, we will need to define a Sequence with 2 blocks.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The first block containing an RF pulse with a flip-angle of 90 deg,","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"ampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF,durRF)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"and the second block containing the ADC.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"nADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, we concatenate the sequence blocks to create the final sequence.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"seq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\np1 = plot_seq(seq; slider=false, height=300)\nsavefig(p1, \"../assets/1-seq.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Now, we will define a Phantom with a single spin at x=0 with T_1=1000mathrmms and T_2=100mathrmms.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3])","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, to simulate we will need to use the function simulate.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"raw = simulate(obj, seq, sys)","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"To plot the results we will need to use the plot_signal function","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"p2 = plot_signal(raw; slider=false, height=300)\nsavefig(p2, \"../assets/1-signal.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Nice!, we can see that S(t) follows an exponential decay exp(-tT_2) as expected.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"For a little bit of spiciness, let's add off-resonance to our example. We will use Delta f=-100mathrmHz. For this, we will need to add a definition for Δw in our Phantom","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3], Δw=[-2π*100])# and simulate again.\n\nraw = simulate(obj, seq, sys)\np3 = plot_signal(raw; slider=false, height=300)\nsavefig(p3, \"../assets/1-signal2.html\") # hide","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal2.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The signal now follows an exponential of the form exp(-tT_2)cdotexp(-iDeltaomega t). The addition of exp(-iDeltaomega t) to the signal will generate a shift in the image space (Fourier shifting property). This effect will be better visualized and explained in later examples.","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"page"},{"location":"tutorial/01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/5-seq-events/#Sequence-Events","page":"Sequence Events","title":"Sequence Events","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As we already know, a Sequence struct contains field names that store arrays of RF, Grad, and ADC structs. In the context of MRI, we refer to RF, Grad, and ADC as \"events.\" To create a Sequence, it's essential to understand how to create these fundamental events.","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the following subsections, we will provide detailed explanations of event parameters and guide you through the process of creating a Sequence using RF, Grad, and ADC events.","category":"page"},{"location":"explanation/5-seq-events/#RF","page":"Sequence Events","title":"RF","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The RF struct is defined in the source code of KomaMRI as follows:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct RF\n    A\n    T\n    Δf\n    delay::Real\nend","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 4 field names: ''A'' defines amplitude, ''T'' defines duration time, ''delay'' is the distance between the 0 time and the first waveform sample and ''Δf'' is the displacement respect to the main field carrier frequency (this is for advanced users).","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"''A'' and ''T'' can be numbers or vectors of numbers. Depending on the length of the ''A'' and ''T'', KomaMRI interprets different waveforms: ","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Pulse Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors with the same length (zero-order-hold)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below, we provide a summary of how you can define RF events:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-rf-horizontal.svg\"/></p>","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at some basic examples of creating these RF structs and including them in a Sequence struct. The examples should be self-explanatory.","category":"page"},{"location":"explanation/5-seq-events/#RF-Pulse-Waveform","page":"Sequence Events","title":"RF Pulse Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A, T, delay =  10e-3, 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(10000.0 uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-pulse-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#RF-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"RF Uniformly-Sampled Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> tl = -3:0.2:-0.2; tr = 0.2:0.2:3;\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; sin.(π*tr)./(π*tr)];\n\njulia> T, delay = 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#RF-Time-Shaped-Waveform","page":"Sequence Events","title":"RF Time-Shaped Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> tl = -4:0.2:-0.2; tr = 0.2:0.2:4\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; 1; sin.(π*tr)./(π*tr)]\n\njulia> T = [0.05e-3*ones(length(tl)); 2e-3; 0.05e-3*ones(length(tl))]\n\njulia> delay = 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 4.0 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 4.1 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-rf-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#Gradient","page":"Sequence Events","title":"Gradient","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The Grad struct is defined as follows in the source code of KomaMRI:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct Grad\n    A\n    T\n    rise::Real\n    fall::Real\n    delay::Real\nend","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 5 field names: ''A'' defines amplitude, ''T'' defines duration time, ''delay'' is the distance between the 0 time and the first waveform sample, ''rise'' and ''fall'' are the time durations of the first and last gradient ramps.","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Just like the RF, ''A'' and ''T'' in the Grad struct can be numbers or vectors of numbers. Depending on the length of the ''A'' and ''T'', KomaMRI interprets different waveforms: ","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Trapezoidal Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors, A has one sample more the T (linear interpolation)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below, we provide a summary of how you can define Grad events:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-gr-horizontal.svg\"/></p>","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at some basic examples of creating these Grad structs and including them in a Sequence struct, focusing on the ''x'' component of the gradients. The examples should be self-explanatory.","category":"page"},{"location":"explanation/5-seq-events/#Gradient-Trapezoidal-Waveform","page":"Sequence Events","title":"Gradient Trapezoidal Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A, T, delay, rise, fall = 50*10e-6, 5e-3, 2e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←2.0 ms→ Grad(0.5 mT, 0.5 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-trapezoidal-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#Gradient-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"Gradient Uniformly-Sampled Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> t = 0:0.25:7.5\n\njulia> A = 10*10e-6 * sqrt.(π*t) .* sin.(π*t)\n\njulia> T = 10e-3;\n\njulia> delay, rise, fall = 1e-3, 0, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 10.0 ms, ↑0.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 12.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#Gradient-Time-Shaped-Waveform","page":"Sequence Events","title":"Gradient Time-Shaped Waveform","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> A = 50*10e-6*[1; 1; 0.8; 0.8; 1; 1];\n\njulia> T = 1e-3*[5; 0.2; 5; 0.2; 5];\n\njulia> delay, rise, fall = 1e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 15.4 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 10.75 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-gr-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#ADC","page":"Sequence Events","title":"ADC","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"The ADC struct is defined in the KomaMRI source code as follows:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"mutable struct ADC\n    N::Integer\n    T::Real\n    delay::Real\n    Δf::Real\n    ϕ::Real\nend","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"As you can see, it has 5 field names: ''N'' defines number of samples, ''T'' defines total acquisition duration, ''delay'' is the distance between the 0 time and the first sampled signal, ''Δf'' and ''ϕ' are factor to correct signal acquisition (for advanced users).","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"In the image below you can see how to define an ADC event:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<p align=\"center\"><img width=\"50%\" src=\"../../assets/event-shapes-adc.svg\"/></p>","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Let's look at a basic example of defining an ADC struct and including it in a Sequence struct:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> N, T, delay =  16, 5e-3, 1e-3;\n\njulia> adc = ADC(N, T, delay)\nADC(16, 0.005, 0.001, 0.0, 0.0)\n\njulia> seq = Sequence(); seq += adc\nSequence[ τ = 6.0 ms | blocks: 1 | ADC: 1 | GR: 0 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-adc.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/#Combination-of-Events","page":"Sequence Events","title":"Combination of Events","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"We can include multiple events within a single block of a sequence. The example below demonstrates how to combine an RF struct, three Grad structs for the x-y-z components, and an ADC struct in a single block of a sequence:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define an RF struct\nA, T =  1e-6*[0; -0.1; 0.2; -0.5; 1; -0.5; 0.2; -0.1; 0], 0.5e-3;\nrf = RF(A, T)\n\n# Define a Grad struct for Gx\nA, T, rise =  50*10e-6, 5e-3, 1e-3\ngx = Grad(A, T, rise)\n\n# Define a Grad struct for Gy\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT, rise = 5e-3, 2e-3;\ngy = Grad(A, T, rise)\n\n# Define a Grad struct for Gz\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT = 5e-3*[0.0; 0.1; 0.3; 0.2; 0.1; 0.2; 0.3; 0.2; 0.1]\ngz = Grad(A, T)\n\n# Define an ADC struct\nN, T, delay =  16, 5e-3, 1e-3\nadc = ADC(N, T, delay)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> seq = Sequence([gx; gy; gz;;], [rf;;], [adc])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 1 | GR: 3 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"<object type=\"text/html\" data=\"../../assets/event-combination.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Once the struct events are defined, it's important to note that to create a single block sequence, you need to provide 2D matrices of Grad and RF structs, as well as a vector of ADC structs as arguments in the Sequence constructor.","category":"page"},{"location":"explanation/5-seq-events/#Algebraic-manipulation","page":"Sequence Events","title":"Algebraic manipulation","text":"","category":"section"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Certain mathematical operations can be directly applied to events and sequence structs. This proves helpful when constructing sequences using reference structs and manipulating them algebraically to create new structs. Below, we provide a list of operations you can perform, along with examples where we check the equivalence of two different struct definitions:","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"RF scaling","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nA, T = 10e-6, 0.5e-3    # Define base RF params  \nα = (1 + im*1)/sqrt(2)  # Define a complex scaling factor\n\n# Create two equivalent RFs in different ways\nra = RF(α * A, T)\nrb = α * RF(A, T)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ra ≈ rb\ntrue","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient scaling","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nA, T = 10e-3, 0.5e-3   # Define base gradient params  \nα = 2                  # Define a scaling factor\n\n# Create two equivalent gradients in different ways\nga = Grad(α * A, T)\ngb = α * Grad(A, T)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ga ≈ gb\ntrue","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient addition","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3      # Define common duration of the gradients\nA1 = 5e-3       # Define base amplitude for gradient  \nA2 = 10e-3      # Define another base amplitude for gradient  \n\n# Create two equivalent gradients in different ways\nga = Grad(A1 + A2, T)\ngb = Grad(A1, T) + Grad(A2, T)","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> ga ≈ gb\ntrue","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Gradient array multiplication by a matrix","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent gradient vectors in different ways\nga = [gy; gz; gx]\ngb = R * [gx; gy; gz]\n\n# Create two equivalent gradient matrices in different ways\ngc = [gy 2*gy; gz 2*gz; gx 2*gx]\ngd = R * [gx 2*gx; gy 2*gy; gz 2*gz]","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> all(ga .≈ gb)\ntrue\n\njulia> all(gc .≈ gd)\ntrue","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"Sequence rotation","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent sequences in different ways\nsa = Sequence(R * [gx; gy; gz;;])\nsb = R * Sequence([gx; gy; gz;;])","category":"page"},{"location":"explanation/5-seq-events/","page":"Sequence Events","title":"Sequence Events","text":"julia> all(sa.GR .≈ sb.GR)\ntrue","category":"page"},{"location":"how-to/3-create-your-own-sequence/#Create-Your-Own-Sequence","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"","category":"section"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"warning: Warning\nThis section is currently under construction, and some details on how to construct a Sequence may be missing.","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"This is an example of how to create a Sequence struct:","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"# Export necessary modules\nusing KomaMRI\n\n# Create the function that creates a phantom\nfunction sequence_example(FOV::Real, N::Integer)\n\n    # Define initial paramters (TODO: consider when N is even)\n    sys = Scanner()\n\tΔt = sys.ADC_Δt\n\tGmax = sys.Gmax\n\tNx = Ny = N #Square acquisition\n\tΔx = FOV/(Nx-1)\n\tTa = Δt*(Nx-1) #4-8 us\n    Δτ = Ta/(Ny-1)\n\tGa = 1/(γ*Δt*FOV)\n\tζ = Ga / sys.Smax\n\tGa ≥ sys.Gmax ? error(\"Ga=$(Ga*1e3) mT/m exceeds Gmax=$(Gmax*1e3) mT/m, increase Δt to at least Δt_min=\"\n\t*string(round(1/(γ*Gmax*FOV),digits=2))*\" us.\") : 0\n\tϵ1 = Δτ/(Δτ+ζ)\n\n\t# EPI base\n\tEPI = Sequence(vcat(\n\t    [mod(i,2)==0 ? Grad(Ga*(-1)^(i/2),Ta,ζ) : Grad(0.,Δτ,ζ) for i=0:2*Ny-2],  #Gx\n\t \t[mod(i,2)==1 ? ϵ1*Grad(Ga,Δτ,ζ) :         Grad(0.,Ta,ζ) for i=0:2*Ny-2])) #Gy\n\tEPI.ADC = [mod(i,2)==1 ? ADC(0,Δτ,ζ) : ADC(N,Ta,ζ) for i=0:2*Ny-2]\n\n\t# Pre-wind and wind gradients\n\tϵ2 = Ta/(Ta+ζ)\n    PHASE =   Sequence(reshape(1/2*[Grad(      -Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # This needs to be calculated differently\n\tDEPHASE = Sequence(reshape(1/2*[Grad((-1)^N*Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # for even N\n\tseq = PHASE + EPI + DEPHASE\n\n\t# Saving parameters\n\tseq.DEF = Dict(\"Nx\"=>Nx,\"Ny\"=>Ny,\"Nz\"=>1,\"Name\"=>\"epi\")\n\n    # Return the sequence\n\treturn seq\nend\n\n# Call the function to create a sequence\nFOV, N = 23e-2, 101\nseq = sequence_example(FOV, N)\n\n# Plot the sequence in time and its kspace\nplot_seq(seq; range=[0 30])\nplot_kspace(seq)","category":"page"},{"location":"how-to/3-create-your-own-sequence/","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"<object type=\"text/html\" data=\"../../assets/create-your-own-sequence-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/create-your-own-sequence-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"reference/3-koma-core/#KomaMRICore","page":"KomaMRICore","title":"KomaMRICore","text":"","category":"section"},{"location":"reference/3-koma-core/#Simulation-functions","page":"KomaMRICore","title":"Simulation functions","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.simulate","page":"KomaMRICore","title":"KomaMRICore.simulate","text":"out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; sim_params, w)\n\nReturns the raw signal or the last state of the magnetization according to the value of the \"return_type\" key of the sim_params dictionary. \n\nThis is a wrapper function to run_sim_time_iter, which converts the inputs to the appropriate types and discretizes the sequence before simulation. The reported simulation time only considers run_sim_time_iter, as the preprocessing duration should be negligible compared to the simulation time (if this is not the case, please file a bug report). \n\nArguments\n\nobj: (::Phantom) Phantom struct\nseq: (::Sequence) Sequence struct\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameter dictionary\nw: (::Blink.AtomShell.Window, =nothing) the window within which to display a   progress bar in the Blink Window UI. If this variable is anything other than 'nothing',   the progress bar will be considered\n\nReturns\n\nout: (::Vector{Complex} or ::SpinStateRepresentation or ::RawAcquisitionData) depending   on whether \"return_type\" is \"mat\", \"state\" or \"raw\" (default), respectively\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.simulate_slice_profile","page":"KomaMRICore","title":"KomaMRICore.simulate_slice_profile","text":"mag = simulate_slice_profile(seq; z, sim_params)\n\nReturns magnetization of spins distributed along z after running the Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nz: (=range(-2e-2,2e-2,200)) range for the z axis\nsim_params: (::Dict{String, Any}, =Dict{String,Any}(\"Δt_rf\"=>1e-6)) dictionary with   simulation parameters\n\nReturns\n\nmag: (::SpinStateRepresentation) final state of the magnetization vector\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.default_sim_params","page":"KomaMRICore","title":"KomaMRICore.default_sim_params","text":"sim_params = default_sim_params(sim_params=Dict{String,Any}())\n\nThis function returns a dictionary containing default simulation parameters while also allowing the user to define some of them.\n\nArguments\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) user-defined dictionary with   simulation parameters. The following lists its keys along with their possible values:\n\"return_type\": defines the output of the simulate function. Possible values   are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco   RawAcquisitionData, the signal values, and the last magnetization state of the   simulation, respectively\n\"sim_method\": defines the type of simulation. The default value is Bloch(), but you   can alternatively use the BlochDict() simulation method. Moreover, you have the   flexibility to create your own methods without altering the KomaMRI source code\n\"Δt\": raster time for gradients\n\"Δt_rf\": raster time for RFs\n\"precision\": defines the floating-point simulation precision. You can choose between   \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively.   It's important to note that, especially for GPU operations, using \"f32\" is   generally much faster\n\"Nblocks\": divides the simulation into a specified number of time blocks. This parameter   is designed to conserve RAM resources, as KomaMRI computes a series of   simulations consecutively, each with the specified number of blocks determined by   the value of \"Nblocks\"\n\"Nthreads\": divides the Phantom into a specified number of threads. Because spins   are modeled independently of each other, KomaMRI can solve simulations in   parallel threads, speeding up the execution time\n\"gpu\": is a boolean that determines whether to use GPU or CPU hardware resources, as   long as they are available on the host computer\n\"gpu_device\": default value is 'nothing'. If set to integer or device instance, calls the   corresponding function to set the device of the available GPU in the host computer    (e.g. CUDA.device!)\n\nReturns\n\nsim_params: (::Dict{String,Any}) dictionary with simulation parameters\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#GPU-helper-functions","page":"KomaMRICore","title":"GPU helper functions","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.get_backend","page":"KomaMRICore","title":"KomaMRICore.get_backend","text":"get_backend(use_gpu)\n\nGets the simulation backend to use. If use_gpu=false or there are no available GPU backends,  returns CPU(), else, returns the GPU backend (currently either CUDABackend(), MetalBackend(),  ROCBackend(), or oneAPIBackend()).\n\nThe GPU package for the corresponding backend (CUDA.jl, Metal.jl, AMDGPU.jl, or oneAPI.jl) must be loaded and functional, otherwise KomaMRI will default to using the CPU.\n\nArguments\n\n'use_gpu': ('::Bool') If true, attempt to use GPU and check for available backends\n\nReturns\n\n'backend': (::KernelAbstractions.backend) The backend to use\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.print_devices","page":"KomaMRICore","title":"KomaMRICore.print_devices","text":"print_devices()\n\nSimple function to print available devices. Calls internal get_backend() function to get the appropriate GPU / CPU backend and prints device information.\n\nArguments\n\n'use_gpu':  ('::Bool') If true, check for loaded / functional GPU backends and print appropriate warnings if no GPU backends have been loaded\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.gpu","page":"KomaMRICore","title":"KomaMRICore.gpu","text":"gpu(x)\n\nMoves 'x' to the GPU. For this function to work, a GPU backend will need to be loaded with 'using AMDGPU / CUDA / Metal / oneAPI.\n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nusing CUDA\nx = x |> gpu\n\n\n\n\n\ngpu(x, backend)\n\nTries to move x to the GPU backend specified in the 'backend' parameter. \n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nx = gpu(x, CUDABackend())\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.cpu","page":"KomaMRICore","title":"KomaMRICore.cpu","text":"cpu(x)\n\nTries to move object to CPU. This works for functions, and any struct marked with @functor.\n\nSee also gpu.\n\nExamples\n\nx = x |> cpu\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f32","page":"KomaMRICore","title":"KomaMRICore.f32","text":"f32(m)\n\nConverts the eltype of model's parameters to Float32 Recurses into structs marked with @functor.\n\nSee also f64.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f64","page":"KomaMRICore","title":"KomaMRICore.f64","text":"f64(m)\n\nConverts the eltype of model's parameters to Float64 (which is Koma's default).. Recurses into structs marked with @functor.\n\nSee also f32.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#Signal-to-RawAquisitionData-(MRD)","page":"KomaMRICore","title":"Signal to RawAquisitionData (MRD)","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.signal_to_raw_data","page":"KomaMRICore","title":"KomaMRICore.signal_to_raw_data","text":"raw = signal_to_raw_data(signal, seq; phantom_name, sys, sim_params)\n\nTransforms the raw signal into a RawAcquisitionData struct (nearly equivalent to the ISMRMRD format) used for reconstruction with MRIReco.\n\nArguments\n\nsignal: (::Matrix{Complex}) raw signal matrix\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nphantom_name: (::String, =\"Phantom\") phantom name\nsys: (::Scanner, =Scanner()) Scanner struct\nsim_params: (::Dict{String, Any}, =Dict{String,Any}()) simulation parameter dictionary\n\nReturns\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_se.seq\")\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> sim_params = KomaMRICore.default_sim_params(); sim_params[\"return_type\"] = \"mat\"\n\njulia> signal = simulate(obj, seq, sys; sim_params)\n\njulia> raw = signal_to_raw_data(signal, seq)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#SpinRepresentationState's","page":"KomaMRICore","title":"SpinRepresentationState's","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.Mag","page":"KomaMRICore","title":"KomaMRICore.Mag","text":"mag = Mag(xy::Complex, z::Real)\n\nThe Magnetization struct.\n\nArguments\n\nxy: (::Complex{Float64}) magnetization of a spin in the xy plane\nz: (::Real) magnetization of a spin in the z plane\n\nReturns\n\nmag: (::Mag) Magnetization struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#Spinor-rotation-matrix-(RF-excitation)","page":"KomaMRICore","title":"Spinor rotation matrix (RF excitation)","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.Spinor","page":"KomaMRICore","title":"KomaMRICore.Spinor","text":"spinor = Spinor(α, β)\n\nSpinor(α, β) with Cayley-Klein parameters α and β. Based on \"Introduction to the Shinnar-Le Roux algorithm\", Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (alphabetainmathbbC):\n\nR=leftbeginarraycc\nalpha  -beta^*\nbeta  alpha^*\nendarrayright\n\nwith alpha^2+beta^2 = 1.\n\nThis later operates on the 2times2 representation of (xyz) as follows V^+ = R V R^*.\n\nArguments\n\nα: (::Complex{Float64}) Cayley-Klein parameter α\nβ: (::Complex{Float64}) Cayley-Klein parameter β\n\nReturns\n\nspinor: (::Spinor) Spinor struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#KomaMRICore.Q","page":"KomaMRICore","title":"KomaMRICore.Q","text":"s = Q(φ, nxy, nz)\n\nSpinor rotation matrix. Counter-clockwise rotation of φ with respect to the axis of rotation n=(nx, ny, nz).\n\nPauly, J., Le Roux, P., Nishimura, D., & Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611\n\nvarphi=-gammaDelta tsqrtleftB_1right^2+left(boldsymbolGcdotboldsymbolx\nright)^2=-gammaDelta tleftVert boldsymbolBrightVert\n\nboldsymboln=boldsymbolBleftVert boldsymbolBrightVert\n\nArguments\n\nφ: (::Real, [rad]) φ angle\nnxy: (::Real) nxy factor\nnz: (::Real) nz factor\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Q rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Un","page":"KomaMRICore","title":"KomaMRICore.Un","text":"Rodrigues' formula: Rotation matrix that when applied rotates with respect to \"n\" in an angle θ anti clock-wise\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rx","page":"KomaMRICore","title":"KomaMRICore.Rx","text":"s = Rx(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to x-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to x-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Rx rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Ry","page":"KomaMRICore","title":"KomaMRICore.Ry","text":"s = Ry(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to y-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to y-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Ry rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rz","page":"KomaMRICore","title":"KomaMRICore.Rz","text":"s = Rz(φ)\n\nSpinor counter-clockwise rotation matrix with angle φ with respect to z-axis.\n\nArguments\n\nφ: (::Real, [rad]) angle with respect to z-axis\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Rz rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"explanation/3-phantom-format/#Phantom-File-Format","page":"Phantom File Format","title":"Phantom File Format","text":"","category":"section"},{"location":"explanation/3-phantom-format/#Introduction","page":"Phantom File Format","title":"Introduction","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"While there is already an open and fairly standardised format for MRI sequences  such as Pulseq, this is not the case for digital phantoms. That's why we defined a new .phantom format, which relies on the HDF5 standard. HDF5 is specially designed to store large amounts of heterogeneous data and to make it readable  and writable quickly and easily. In addition, it allows the storage of metadata.  For all these reasons, it is the ideal file format for storing phantoms.","category":"page"},{"location":"explanation/3-phantom-format/#Phantom-File-I/O","page":"Phantom File Format","title":"Phantom File I/O","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"The KomaMRIFiles module provides two key functions for working with .phantom files:","category":"page"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"read_phantom loads a .phantom and converts it into a Phantom instance.\nwrite_phantom converts a Phantom instance into an HDF5-based .phantom file.","category":"page"},{"location":"explanation/3-phantom-format/#File-Format-Specification","page":"Phantom File Format","title":"File Format Specification","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"This section describes the internal structure of the .phantom file. While most users will interact with phantoms via the KomaMRI tools, this section is intended for developers who wish to implement support for the format in other applications or workflows.","category":"page"},{"location":"explanation/3-phantom-format/#Phantom-File-Tree","page":"Phantom File Format","title":"Phantom File Tree","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"<p><img width=\"80%\" src=\"../../assets/ph-file-format.svg\"/></p>","category":"page"},{"location":"explanation/3-phantom-format/#Action-types","page":"Phantom File Format","title":"Action types","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"<p><img width=\"80%\" src=\"../../assets/ph-actions.svg\"/></p>","category":"page"},{"location":"explanation/3-phantom-format/#TimeCurve","page":"Phantom File Format","title":"TimeCurve","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"<p><img width=\"80%\" src=\"../../assets/ph-timecurve.svg\"/></p>","category":"page"},{"location":"explanation/3-phantom-format/#SpinSpan-types","page":"Phantom File Format","title":"SpinSpan types","text":"","category":"section"},{"location":"explanation/3-phantom-format/","page":"Phantom File Format","title":"Phantom File Format","text":"<p><img width=\"80%\" src=\"../../assets/ph-spins.svg\"/></p>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/#Small-Tip-Angle-Approximation","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"section"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Based on the results in page 41 of the book \"Handbook of MRI Pulse Sequences\" by Bernstein et al.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"using KomaMRI # hide\nsys = Scanner() # hide\nsys.Smax = 50 # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"In this example, we will showcase a common approximation in MRI, the small tip angle approximation. For this, we will simulate a slice profile for spins with positions zin-22mathrmcm and with a gradient G_z so their frequencies are mapped to fin-55mathrmkHz. To start, we define an RF pulse with a flip angle of 30 deg and pulse duration of T_mathrmrf=32mathrmms.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"B1 = 4.92e-6\nTrf = 3.2e-3\nzmax = 2e-2\nfmax = 5e3\nz = range(-zmax, zmax, 400)\nGz = fmax / (γ * zmax)\nf = γ * Gz * z # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"The designed RF pulse is presented in the figure below, where the additional gradient refocuses the spins' phase after the excitation.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"seq = PulseDesigner.RF_sinc(B1, Trf, sys; G=[0;0;Gz], TBP=8)\np2 = plot_seq(seq; max_rf_samples=Inf, slider=false)\nsavefig(p2, \"../assets/42-seq.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/42-seq.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Now we will perform the simulation using the function simulate_slice_profile. Note that we modified Δt_rf in sim_params to match the resolution of the waveform.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"sim_params = Dict{String, Any}(\"Δt_rf\" => Trf / length(seq.RF.A[1]))\nM = simulate_slice_profile(seq; z, sim_params)\n\nusing PlotlyJS # hide\ns1 = scatter(x=f, y=real.(M.xy), name=\"Mx\") # hide\ns2 = scatter(x=f, y=imag.(M.xy), name=\"My\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns3 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B₁(t))|\", line=attr(dash=\"dash\")) # hide\npb = plot([s1,s2,s3], Layout(title=\"30 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nsavefig(pb, \"../assets/4b-profile.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This produces the following slice profile:","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4b-profile.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"As you can see, for a flip angle of 30 deg, the slice profile is very close to the small tip angle approximation (the Fourier transform of B_1(t)).","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"But what will happen if we use a flip angle of 120 deg instead?","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"α_desired = 120 + 0im               # The multiplication of a complex number scales the RF pulse of a Sequence\nα = get_flip_angles(seq)[1] # Previous FA approx 30 deg\nseq = (α_desired / α) * seq         # Scaling the pulse to have a flip angle of 120\nM = simulate_slice_profile(seq; z, sim_params)\n\ns1 = scatter(x=f, y=abs.(M.xy), name=\"|Mxy|\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns2 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B₁(t))|\", line=attr(dash=\"dash\")) # hide\npa = plot([s1,s2], Layout(title=\"120 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nsavefig(pa, \"../assets/4a-profile.html\") # hide","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4a-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"For this case, the small tip angle approximation breaks 😢, thus, the reason for its name!","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This basic sinc pulse is not designed to be B_1-insensitive.  Some adiabatic RF pulses have been proposed to achieve this. Watch out for a future example showing these adiabatic RF pulses 👀.","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"page"},{"location":"tutorial/02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/05-SimpleMotion/#Patient's-Motion-During-Acquisition","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"using KomaMRI # hide\nusing PlotlyJS # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"It can also be interesting to see the effect of the patient's motion during an MRI scan. For this, Koma provides the ability to add motion to the phantom. In this tutorial, we will show how to add a Translate motion to a 2D brain phantom.","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"First, let's load the 2D brain phantom used in the previous tutorials:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"obj = brain_phantom2D()\nobj.Δw .= 0 # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/#Head-Translation","page":"Patient's Motion During Acquisition","title":"Head Translation","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"In this example, we will add a Translate of 2 cm in x, with duration of 200 ms (v = 0.1 m/s):","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"obj.motion = Translate(2e-2, 0.0, 0.0, TimeRange(t_start=0.0, t_end=200e-3))\np1 = plot_phantom_map(obj, :T2 ; height=450, time_samples=4) # hide\n\nsavefig(p1, \"../assets/tut-5-phantom.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"# Read Sequence # hide\nseq_file1 = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\") # hide\nseq1 = read_seq(seq_file1) # hide\n\n# Simulate # hide\nraw1 = simulate(obj, seq1, sys) # hide\n\n# Recon # hide\nacq1 = AcquisitionData(raw1) # hide\nacq1.traj[1].circular = false # hide\nNx, Ny = raw1.params[\"reconSize\"][1:2] # hide\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny)) # hide\nimage1 = reconstruction(acq1, reconParams) # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"If we simulate an EPI sequence with acquisition duration (183.989 ms) comparable with the motion's duration (200 ms), we will observe motion-induced artifacts in the reconstructed image.","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"# Plotting the recon # hide\np2 = plot_image(abs.(image1[:, :, 1]); height=400) # hide\nsavefig(p2, \"../assets/tut-5-recon1.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center>\n<object type=\"text/html\" data=\"../../assets/tut-5-recon1.html\" style=\"width:65%; height:420px;\"></object>\n</center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"The severity of the artifacts can vary depending on the acquisition duration and k-space trajectory.","category":"page"},{"location":"tutorial/05-SimpleMotion/#Motion-Corrected-Reconstruction","page":"Patient's Motion During Acquisition","title":"Motion-Corrected Reconstruction","text":"","category":"section"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"To correct for the motion-induced artifacts we can perform a motion-corrected reconstruction. This can be achieved by multiplying each sample of the acquired signal  S(t) by a phase shift Deltaphi_mathrmcorr proportional to the displacement boldsymbolu(t) [Godenschweger, 2016]:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"S_mathrmMCleft(tright)=Sleft(tright)cdotmathrme^mathrmiDeltaphi_mathrmcorr=Sleft(tright)cdotmathrme^mathrmi2piboldsymbolkleft(tright)cdotboldsymboluleft(tright)","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"In practice, we would need to estimate or measure the motion before performing a motion-corrected reconstruction, but for this example, we will directly use the displacement functions boldsymbolu(boldsymbolx t) defined by obj.motion::MotionList. Since translations are rigid motions (boldsymbolu(boldsymbolx t)=boldsymbolu(t) no position dependence), we can obtain the required displacements by calculating boldsymbolu(boldsymbolx=boldsymbol0 t=t_mathrmadc).","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"sample_times = get_adc_sampling_times(seq1)\ndisplacements = hcat(get_spin_coords(obj.motion, [0.0], [0.0], [0.0], sample_times)...)\n\np3 = plot( # hide\n    sample_times, # hide\n    displacements .* 1e2, # hide\n    Layout( # hide\n        title = \"Head displacement in x, y and z\", # hide\n        xaxis_title = \"time (s)\", # hide\n        yaxis_title = \"Displacement (cm)\" # hide\n    )) # hide\nrestyle!(p3,1:3, name=[\"ux(t)\", \"uy(t)\", \"uz(t)\"]) # hide\n\nsavefig(p3, \"../assets/tut-5-displacements.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<center><object type=\"text/html\" data=\"../../assets/tut-5-displacements.html\" style=\"width:80%; height:300px;\"></object></center>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"We can now get the necessary phase shift for each sample:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"_, kspace = get_kspace(seq1)\nΔΦ = 2π*sum(kspace .* displacements, dims=2)","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"And apply it to the acquired signal to correct its phase:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"acq1.kdata[1] .*= exp.(im*ΔΦ)\n\nimage2 = reconstruction(acq1, reconParams) # hide\n\np4 = plot_image(abs.(image2[:, :, 1]); height=400) # hide\n\nsavefig(p4, \"../assets/tut-5-recon2.html\") # hide","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"Finally, we compare the original image ▶️ and the motion-corrected reconstruction ⏸️:","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"<object type=\"text/html\" data=\"../../assets/tut-5-recon1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/tut-5-recon2.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"","category":"page"},{"location":"tutorial/05-SimpleMotion/","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/6-koma-mri/#KomaMRI","page":"KomaMRI","title":"KomaMRI","text":"","category":"section"},{"location":"reference/6-koma-mri/#User-Interface","page":"KomaMRI","title":"User Interface","text":"","category":"section"},{"location":"reference/6-koma-mri/#KomaMRI.KomaUI","page":"KomaMRI","title":"KomaMRI.KomaUI","text":"out = KomaUI(; kwargs...)\n\nLaunch the Koma's UI.\n\nKeywords\n\ndarkmode: (::Bool, =true) define dark mode style for the UI\nframe: (::Bool, =true) display the upper frame of the Blink window\nphantom_mode: (::String, =\"2D\", opts=[\"2D\", \"3D\"]) load the default phantom as a   2D or 3D brain example\nsim: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameters dictionary\nrec: (::Dict{Symbol,Any}, =Dict{Symbol,Any}()) reconstruction parameters dictionary\nreturn_window: (::Bool, =false) make the out be either 'nothing' or the Blink window,   depending on whether the return_window keyword argument is set to true\nshow_window: (::Bool, =true) display the Blink window\n\nReturns\n\nout: (::Nothing or ::Blink.AtomShell.Window) returns either 'nothing' or the Blink   window, depending on whether the return_window keyword argument is set to true.\n\nExamples\n\njulia> KomaUI()\n\n\n\n\n\n","category":"function"},{"location":"tutorial/03-ChemicalShiftEPI/#Chemical-Shift-in-an-EPI-sequence","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"section"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"using KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"For a more realistic example, we will use a brain phantom.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"obj = brain_phantom2D() # a slice of a brain\np1 = plot_phantom_map(obj, :T2 ; height=400, width=400, view_2d=true)\np2 = plot_phantom_map(obj, :Δw ; height=400, width=400, view_2d=true)\nsavefig(p1, \"../assets/2-phantom1.html\") # hide\nsavefig(p2, \"../assets/2-phantom2.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"At the left, you can see the T_2 map of the phantom, and at the right, the off-resonance Deltaomega. In this example, the fat is the only source of off-resonance (with Delta f =  -220mathrmHz) and you can see it in black in the off-resonance map.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-phantom1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/2-phantom2.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Then, we will load an EPI sequence, that is well known for being affected by off-resonance. With this sequence, we will be able visualize the effect of the chemical shift.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\")\nseq = read_seq(seq_file)\np3 = plot_seq(seq; range=[0 40], slider=true, height=300)\nsavefig(p3, \"../assets/2-seq.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Feel free to explore the sequence's plot 🔍 below!","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"If we simulate this sequence we will end up with the following signal.","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"raw = simulate(obj, seq, sys)\np4 = plot_signal(raw; range=[98.4 103.4] , height=300)\nsavefig(p4, \"../assets/2-signal.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Now, we need to inspect what effect the off-resonance had in the reconstructed image. As you can see, the fat layer is now shifted to a different position 🤯, this is why the effect is called chemical shift!","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\nacq.traj[1].circular = false #This is to remove the circular mask\n\n# Setting up the reconstruction parameters\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the recon\nslice_abs = abs.(image[:, :, 1])\np5 = plot_image(slice_abs; height=400)\nsavefig(p5, \"../assets/2-recon.html\") # hide","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<center><object type=\"text/html\" data=\"../../assets/2-recon.html\" style=\"width:65%; height:420px;\"></object></center>","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"page"},{"location":"tutorial/03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"how-to/1-getting-started/#Getting-Started","page":"🏃 Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"how-to/1-getting-started/#Installing-Julia","page":"🏃 Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"KomaMRI was written in Julia, so the first thing you should do is to install it! The latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"page"},{"location":"how-to/1-getting-started/#Installing-KomaMRI","page":"🏃 Getting Started","title":"Installing KomaMRI","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Once Julia is installed, open the Julia REPL, and add the KomaMRI package by typing the following commands:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Press the ] key and then press enter to bring up Julia's package manager.\nType add KomaMRI and then press enter in the package manager session.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"This process should take about 5 minutes in a fresh Julia installation. Here is how it looks in the Julia REPL:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"julia> ]\n\n(@v1.9) pkg> add KomaMRI","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Then press Ctrl+C or backspace to return to the julia> prompt.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"","category":"page"},{"location":"how-to/1-getting-started/#My-First-MRI-Simulation","page":"🏃 Getting Started","title":"My First MRI Simulation","text":"","category":"section"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"For our first simulation we will use KomaMRI's graphical user interface (GUI). For this, you will first need to load KomaMRI by typing using KomaMRI, and then launch the GUI with the KomaUI function. Note that if you want to run simulations on the GPU (for example, using CUDA), then using CUDA is also necessary (see GPU Parallelization).  ","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"julia> using KomaMRI, CUDA\n\njulia> KomaUI()","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"The first time you use this command it may take more time than usual, but a window with the Koma GUI will pop up:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"The user interface has some basic definitions for the scanner, phantom, and sequence already preloaded. So you can immediately interact with the simulation and reconstruction processes, and then visualize the results.","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"As a simple demonstration, press the Simulate! button and wait until the simulation is ready. Now you have acquired the Raw Signal and you should see the following:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Then, press the Reconstruct! button and wait until the reconstruction ends. Now you have reconstructed an Image from the Raw Signal and you should see the following in the GUI:","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"(Image: )","category":"page"},{"location":"how-to/1-getting-started/","page":"🏃 Getting Started","title":"🏃 Getting Started","text":"Congratulations, you successfully simulated an MRI acquisition! 🎊","category":"page"},{"location":"tutorial/07-RRVariability/#Cardiac-Cine-MRI-with-Arrhythmias","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"","category":"section"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"using KomaMRI, PlotlyJS, Plots, Printf #hide\n\ninclude(joinpath(dirname(pathof(KomaMRI)), \"../examples/3.tutorials/utils/RRVariability.jl\")) #hide\n\nsys = Scanner() #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"This tutorial shows how to simulate cardiac cine MRI using Koma, including cases with variable RR intervals (i.e., arrhythmias). You'll learn how to:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Simulate a clean cine acquisition with constant RR intervals.\nIntroduce arrhythmias (variable RR intervals) into the cardiac phantom.\nObserve how this desynchronization degrades image quality.\nCorrect the acquisition by synchronizing the sequence with the phantom’s RR variability (manual triggering).","category":"page"},{"location":"tutorial/07-RRVariability/#1.-Constant-RR-for-Phantom-and-Sequence","page":"Cardiac Cine MRI with Arrhythmias","title":"1. Constant RR for Phantom and Sequence","text":"","category":"section"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"We will begin by simulating a cardiac cine on a myocardial phantom with a constant RR interval. We'll use the heart_phantom function to create a ring-shaped phantom filled with blood, resembling the left ventricle:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"obj = heart_phantom()","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"By default, this phantom exhibits periodic contraction and rotation with a 1-second period:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"p1 = plot_phantom_map(obj, :T1 ; height=450, time_samples=21) #hide\nPlotlyJS.savefig(p1, \"../assets/tut-6-phantom1.html\") #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"<center><object type=\"text/html\" data=\"../../assets/tut-6-phantom1.html\" style=\"width:90%; height:470px;\"></object></center>","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"As shown in previous tutorials, the phantom's motion is defined by its motion field. Until now, this motion has typically consisted of a single Motion component. In this case, however, it consists of two independent motions: a contraction (HeartBeat) and a Rotation. These two are grouped together in a MotionList structure:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"julia> obj.motion\nMotionList{Float64}(Motion{Float64}[Motion{Float64}\n  action: HeartBeat{Float64}\n  time: TimeCurve{Float64}\n  spins: AllSpins AllSpins()\n, Motion{Float64}\n  action: Rotate{Float64}\n  time: TimeCurve{Float64}\n  spins: AllSpins AllSpins()\n])","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Now, we will create a bSSFP cine sequence with the following parameters:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"RRs          = [1.0]       # [s] constant RR interval\nN_matrix     = 50          # image size = N x N\nN_phases     = 30          # Number of cardiac phases\nFOV          = 0.11        # [m]\nTR           = 25e-3       # [s]\nflip_angle   = 10          # [º]\nadc_duration = 0.2e-3      # [s]","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"seq = bSSFP_cine(\n    FOV, N_matrix, TR, flip_angle, RRs, N_phases, sys;\n    N_dummy_cycles = 40, adc_duration = adc_duration,\n)\n\n# Simulation  #hide\nraw1 = simulate(obj, seq, sys) #hide\n# Reconstruction #hide\nframes1 = reconstruct_cine(raw1, seq, N_matrix, N_phases) #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"The simulation and subsequent reconstruction produces the following cine frames, which look clean and temporally coherent:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"fps = 25 #hide\np2 = plot_cine(frames1, fps; Δt=TR, filename=\"../assets/tut-7-frames1.gif\"); #hide\nnothing #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"<center><object data=\"../../assets/tut-7-frames1.gif\" style=\"height:375px\"></object></center>","category":"page"},{"location":"tutorial/07-RRVariability/#2.-Arrhythmic-Phantom:-Variable-RR,-Constant-Sequence","page":"Cardiac Cine MRI with Arrhythmias","title":"2. Arrhythmic Phantom: Variable RR, Constant Sequence","text":"","category":"section"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Now, we will introduce arrhythmias into the phantom by varying its RR intervals. However, the sequence will still assume a constant RR interval of 1 second.","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"RRs = [900, 1100, 1000, 1000, 1000, 800] .* 1e-3","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"note: Note\nThe RRs array contains scaling factors relative to the original duration of the phantom’s motion cycle.In this example, the base duration of the cardiac motion is 1 second, which is defined within the t field of its TimeCurve structure. Consequently, the elements in RRs directly represent the actual RR intervals in seconds (e.g., 0.9 s, 1.1 s, etc.).","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Let's apply the new RRs to the phantom:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"# Take the time curve from the contraction motion:\nt_curve = obj.motion.motions[1].time\n# Generate a new time curve:\nt_curve_new = TimeCurve(\n    t = t_curve.t,\n    t_unit = t_curve.t_unit,\n    periodic = true,\n    periods = RRs\n)\n# Assign the new time curve to both the contraction and the rotation:\nobj.motion.motions[1].time = obj.motion.motions[2].time = t_curve_new","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Let’s visualize how the motion pattern has changed, now with variable-duration RR intervals:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"p3 = plot_phantom_map(obj, :T1 ; height=450, time_samples=41) #hide\nPlotlyJS.savefig(p3, \"../assets/tut-6-phantom2.html\") #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"<center><object type=\"text/html\" data=\"../../assets/tut-6-phantom2.html\" style=\"width:90%; height:470px;\"></object></center>","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Since the sequence still assumes a constant RR interval, it becomes unsynchronized with the phantom. This results in artifacts and temporal inconsistencies in the cine images. We will showcase these images in the next section.","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"# Simulation  #hide\nraw2 = simulate(obj, seq, sys) #hide\n# Reconstruction #hide\nframes2 = reconstruct_cine(raw2, seq, N_matrix, N_phases) #hide","category":"page"},{"location":"tutorial/07-RRVariability/#3.-Prospective-Triggering:-Resynchronized-Acquisition","page":"Cardiac Cine MRI with Arrhythmias","title":"3. Prospective Triggering: Resynchronized Acquisition","text":"","category":"section"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"To correct this, we synchronize the sequence manually by providing it the same RR intervals as the phantom:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"seq = bSSFP_cine(\n    FOV, N_matrix, TR, flip_angle, RRs, N_phases, sys;\n    N_dummy_cycles = 40, adc_duration = adc_duration,\n)","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"This approach manually mimics cardiac triggering. The resulting cine is once again correctly aligned, despite the underlying arrhythmia.","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"In the future, this synchronization will be handled automatically through upcoming support for trigger extensions in the sequence framework.","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"# Simulation  #hide\nraw3 = simulate(obj, seq, sys) #hide\n# Reconstruction #hide\nframes3 = reconstruct_cine(raw3, seq, N_matrix, N_phases) #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"Below, we compare the results of the desynchronized 👎 acquisition simulated in the previous section with the resynchronized 🕐 acquisition:","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"plot_cine([frames2 ;; frames3], fps; Δt=TR, filename=\"../assets/tut-7-frames_comparison.gif\"); #hide\nnothing #hide","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"<center><object data=\"../../assets/tut-7-frames_comparison.gif\" style=\"width:100%\"></object></center>","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"","category":"page"},{"location":"tutorial/07-RRVariability/","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/#Low-Field-CMRA-Optimization","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"","category":"section"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"<iframe type=\"text/html\" src=\"../02-low-field-cmra-optimization.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. ","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"Files matching the lit-*.jl pattern anywhere in examples/3.tutorials will be included.","category":"page"},{"location":"tutorial/README/","page":"-","title":"-","text":"All files included in this folder will be ignored.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Use-Koma's-User-Interface","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"This section provides a comprehensive guide on using the User Interface of the KomaMRI package and delves into the internal processes that occur during interaction. By the end of this section, you will be equipped to execute a complete workflow even without any prior programming experience.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-simulation.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Basic-Workflow","page":"Use Koma's User Interface","title":"Basic Workflow","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"As a general overview, remember the following workflow steps when using KomaMRI:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Loading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"In the following subsections, we will cover all the mentioned steps. First, open the Julia REPL and enter the following commands to include the KomaMRI package and launch the user interface:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-dashboard.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Loading-Simulation-Inputs","page":"Use Koma's User Interface","title":"Loading Simulation Inputs","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The user interface has preloaded certain inputs into RAM, including the Scanner, Phantom, and Sequence structs. In the following subsections, we will demonstrate how to visualize these inputs.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Scanner","page":"Use Koma's User Interface","title":"Scanner","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"You can visualize the preloaded Scanner struct by clicking on the Scanner dropdown and then pressing the View Scanner button. The Scanner struct contains hardware-related information, such as the main magnetic field's magnitude:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-scanner-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Phantom","page":"Use Koma's User Interface","title":"Phantom","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To see the phantom already stored in RAM, simply click on the Phantom dropdown an then press the View Phantom button. The preloaded phantom is a slice of a brain:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"It is also possible to load .h5 phantom files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/2.phantoms/. For instance, let's load the sphere_chemical_shift.h5 file:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Note that you can select different spin parameters to visualize like ρ, T1, T2, among others. ","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Sequence","page":"Use Koma's User Interface","title":"Sequence","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"For visualization of the sequence in the time domain, click on the Sequence dropdown and then press the Sequence (MPS) button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"For visualization of the sequence in the k-space, click on the Sequence dropdown and then press the k-space button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"You can also display the Moments related to the Sequence by pressing the View Moments and then pressing the buttons for zero, first and second moments.","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"It is also possible to load Pulseq compatible .seq sequence files. The KomaMRI has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/1.sequences/. For instance, let's load the spiral.seq file and view it the time domain and k-space:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-load.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"And remember, you are free to interact with the plots:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-seq.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Running-Simulation","page":"Use Koma's User Interface","title":"Running Simulation","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Once the inputs are loaded in RAM, it is possible to perform the simulation to get the Raw Signal.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Simulation-Parameters","page":"Use Koma's User Interface","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To visualize the default simulation parameters, click on the Simulate! dropdown and then press the View Options button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-sim-params-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Raw-Signal","page":"Use Koma's User Interface","title":"Visualization of the Raw Signal","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Press the Simulate! button to perform the simulation (this may take a while). Automatically the generated Raw Signal should be displayed or you can click on the Raw Data dropdown and then press the View Raw Data button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-rawsignal-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Reconstructing-Image-using-MRIReco","page":"Use Koma's User Interface","title":"Reconstructing Image using MRIReco","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Once the Raw Signal is loaded in RAM, it is possible to reconstruct the image.","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Reconstruction-Parameters","page":"Use Koma's User Interface","title":"Reconstruction Parameters","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"To visualize the default reconstruction parameters, click on the Reconstruct! dropdown and then press the View Options button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-recon-params-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Image","page":"Use Koma's User Interface","title":"Visualization of the Image","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Press the Reconstruct! button to perform the reconstruction (this may take a while).  Automatically the generated Image should be displayed or you can click on the he Reconstruct! dropdown and then press the |Image| button:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-image-view.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#Exporting-Results-to-.mat-File","page":"Use Koma's User Interface","title":"Exporting Results to .mat File","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"(You can also go to analog steps using Scripts)","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The user interface has the option to save the results in .mat format. Simply click on the Export to .mat and you have the alternatives to get data independently or you can press the All button to have all the results given by the simulator:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-export-to-mat.png\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"So far, and due to limitations of the user interface dependencies, the .mat files are saved in the temporal directory of your computer OS, which can be found by typing the tempdir() command in the Julia REPL:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-export-data.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/#REPL-and-UI-communication","page":"Use Koma's User Interface","title":"REPL and UI communication","text":"","category":"section"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"An amazing feature of KomaMRI is that it allows you to modify certain variables in the Julia REPL, and then the user interface automatically updates its plots in real-time:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-observables.gif\"/></p>","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"The variables that update the interface are:","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"seq_ui[] for the Sequence\nobj_ui[] for the Phantom\nsys_ui[] for the Scanner\nraw_ui[] for the Raw Signal\nimg_ui[] for the Image","category":"page"},{"location":"how-to/2-1-use-koma-ui/","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"Don't forget to add the brackets [] to these variables, otherwise it won't work.","category":"page"},{"location":"tutorial-pluto/03-low-field-boost-optimization/#Low-Field-BOOST-Optimization","page":"Low-Field BOOST Optimization","title":"Low-Field BOOST Optimization","text":"","category":"section"},{"location":"tutorial-pluto/03-low-field-boost-optimization/","page":"Low-Field BOOST Optimization","title":"Low-Field BOOST Optimization","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial-pluto/03-low-field-boost-optimization/","page":"Low-Field BOOST Optimization","title":"Low-Field BOOST Optimization","text":"<iframe type=\"text/html\" src=\"../03-low-field-boost-optimization.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Use-Koma-in-Julia-Scripts","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You should already be familiar with the  Graphical User Interface of KomaMRI. However, you can also use this package directly from the Julia REPL or write your own Julia scripts. This allows you to unlock the full potential of KomaMRI, enabling you to utilize more of its functionalities and even test your own MRI ideas.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"This section demonstrates a basic workflow with KomaMRI through writing your own scripts or entering commands directly into the Julia REPL. Let's begin.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Basic-Workflow","page":"Use Koma in Julia Scripts","title":"Basic Workflow","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"As a general overview, remember the following workflow steps when using KomaMRI:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Loading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Let's replicate these previous steps in a Julia script. You will obtain the following code, which you can copy and paste into the Julia REPL:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Import the package\nusing KomaMRI\n\n# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)\n\n# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Let's go through this script step by step.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Loading-Simulation-Inputs","page":"Use Koma in Julia Scripts","title":"Loading Simulation Inputs","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The inputs of the simulation are created in the following part of the script: ","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Scanner","page":"Use Koma in Julia Scripts","title":"Scanner","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The previously created Scanner struct contains default parameters. In your initial simulations, you will likely use this default struct without making any modifications. You can view all the parameters by displaying the struct variable in the Julia REPL. The Scanner's parameters include hardware limitations such as the main magnetic field, maximum gradient values, minimum raster times, and more. You may want to adjust these values for your future custom simulations.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> sys\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Δt: Float64 2.0e-6\n  seq_Δt: Float64 1.0e-5\n  GR_Δt: Float64 1.0e-5\n  RF_Δt: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Phantom","page":"Use Koma in Julia Scripts","title":"Phantom","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Phantom struct created in this example represents a slice of a brain. To create it, we use the function brain_phantom2D, which is part of the subdependency KomaMRICore. While KomaMRI provides some phantom examples for experimentation, you may also want to create your custom Phantom struct tailored to your specific requirements.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Phantom struct contains MRI parameters related to the magnetization properties of an object. These parameters include magnetization positions, proton density, relaxation times, off-resonance, among others. For more information about Koma's Phantom and what it can do, as well as how to store and share it, check out the Phantom section. To view all the keys and values of the object, you can do so in the Julia REPL as follows:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> obj\nPhantom{Float64}\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084,  …  0.086, 0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028,  …  0.0, 0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0,  …  0.0, 0.0]\n  ρ: Array{Float64}((6506,)) [0.7, 0.7,  …  0.7, 0.7]\n  T1: Array{Float64}((6506,)) [0.569, 0.569,  …  0.569, 0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329,  …  0.329, 0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058,  …  0.058, 0.058]\n  Δw: Array{Float64}((6506,)) [-0.0, -0.0,  …  -0.0, -0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  motion: NoMotion{Float64} NoMotion{Float64}()\n...","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can also visualize the Phantom struct using the plot_phantom_map function:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_phantom_map(obj, :ρ)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/phantom-rho.html\" style=\"width:100%; height:620px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To utilize test phantoms included with KomaMRI, navigate to the \"examples\" folder and use the read_phantom_jemris  function to read a phantom in .h5 format. The following steps outline how to do this in Julia:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_sphere = joinpath(path_koma, \"examples\", \"2.phantoms\", \"sphere_chemical_shift.h5\")\njulia> sphere = read_phantom_jemris(path_sphere)\njulia> plot_phantom_map(sphere, :T2)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/phantom-T2-circle.html\" style=\"width:100%; height:620px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Sequence","page":"Use Koma in Julia Scripts","title":"Sequence","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The Sequence struct in the example represents one of the most basic MRI sequences. It excites the object with a 90° RF pulse and then uses EPI gradients to fill the k-space in a \"square\" manner. While you may want to create your sequences for experiments, you can always use some of the examples already available in KomaMRI.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In MRI, the sequence must be carefully designed with precise timing to obtain an image. It includes subcomponents such as gradients, radio-frequency excitation signals, and sample acquisition. For more information on constructing a Sequence struct, refer to the Sequence section.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can view general information about a Sequence struct by displaying it in the Julia REPL:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> seq\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"For more precise timing checks, you can use the plot_seq function:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_seq(seq; range=[0 30])","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/plot-seq-epi.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"It is important to consider how the sequence traverses through k-space. The plot_kspace function does precisely that:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_kspace(seq)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/kspace-epi.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Additionally, there are helpful sequence construction functions within a submodule of KomaMRI called PulseDesigner. These functions include PulseDesigner.RF_hard, PulseDesigner.RF_sinc, PulseDesigner.EPI, PulseDesigner.radial_base and PulseDesigner.spiral_base. For more details on how to use them, refer to the API documentation.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"KomaMRI is also compatible with Pulseq. The package installation includes some .seq files in Pulseq format, which can be read and used as a Sequence struct. Here's how to read a spiral Pulseq file stored in the \"examples\" folder of KomaMRI:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_spiral = joinpath(path_koma, \"examples\", \"1.sequences\", \"spiral.seq\")\njulia> spiral = read_seq(path_spiral)\njulia> plot_seq(spiral)\njulia> plot_kspace(spiral)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Running-Simulation","page":"Use Koma in Julia Scripts","title":"Running Simulation","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The following lines in the example script configure and perform the simulation:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Simulation-Parameters","page":"Use Koma in Julia Scripts","title":"Simulation Parameters","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To perform simulations, KomaMRI requires certain parameters. You can use the default parameters for testing, but you also have the option to customize specific simulation aspects. In the example, we use the KomaMRICore.default_sim_params function to create a dictionary with default simulation parameters. You can view the keys that can be modified by displaying the sim_params variable:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> sim_params\nDict{String, Any} with 9 entries:\n  \"return_type\" => \"raw\"\n  \"Nblocks\"     => 20\n  \"gpu\"         => true\n  \"Nthreads\"    => 1\n  \"gpu_device\"  => 0\n  \"sim_method\"  => Bloch()\n  \"precision\"   => \"f32\"\n  \"Δt\"          => 0.001\n  \"Δt_rf\"       => 5.0e-5","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"All of these parameters deserve special attention. We will explain some of the most important ones here. For instance, \"Δt\" and \"Δt_rf\" represent the raster times for the gradients and RFs. \"return_type\" specifies the type of variable returned by the simulator (by default, it returns an object ready for use with MRIReco for reconstruction, but you can use the value \"mat\" to return a simple vector). \"gpu\" indicates whether you want to use your GPU device for simulations, and \"precision\" sets the floating-point precision. For more details on how to set these parameters, please refer to the Simulation Parameters Section.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Raw-Signal","page":"Use Koma in Julia Scripts","title":"Raw Signal","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"The simulation is performed using the simulate function, which requires three arguments: a Scanner struct, a Phantom struct, and a Sequence struct. Optionally, you can include the keyword argument sim_params if you wish to use custom simulation parameters.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In the example, we can see that the output of the simulation is a special struct:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> typeof(raw)\nRawAcquisitionData\n\njulia> raw\nRawAcquisitionData[SeqName: epi | 101 Profile(s) of 101×1]","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You can plot the simulation result with the plot_signal function like so:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_signal(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<object type=\"text/html\" data=\"../../assets/raw-epi-brain-default.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Reconstructing-Image-using-MRIReco","page":"Use Koma in Julia Scripts","title":"Reconstructing Image using MRIReco","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"KomaMRI does not handle reconstruction; instead, you should utilize the MRIReco package to generate an image. For convenience, when you install KomaMRI, you also install MRIReco, allowing you to access functions from that package. You should pay special attention to the RawAcquisitionData and AcquisitionData structs, as well as the reconstruction function.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"In the example below, we define an auxiliary function, reconstruct_2d_image, which takes a raw signal struct, RawAcquisitionData, as input and returns a 2D Array representing an image. Within this function, we create an AcquisitionData struct and set some reconstruction parameters, which serve as inputs for the reconstruction function. The latter function is responsible for the image generation process.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"If you need more information about how to use the AcquisitionData and the how to fill the reconstruction parameters, you need to visit the MRIReco webpage).","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"To display the image, you can use the plot_image function which is part of the KomaMRIPlots subpackage:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"julia> plot_image(image)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"<center><object type=\"text/html\" data=\"../../assets/image-default-brain.html\" style=\"width:100%; height:620px;\"></object></center>","category":"page"},{"location":"how-to/2-3-use-koma-scripts/#Exporting-Results-to-.mat-File","page":"Use Koma in Julia Scripts","title":"Exporting Results to .mat File","text":"","category":"section"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"(You can also go to analog steps using UI)","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Many people in the MRI community uses MATLAB, probably you are one of them and you want to process the raw signal in the MATLAB environment after simulation is done with KomaMRI. Here we show you an example of how to save a .mat file with the information of the raw signal thank to the help of the MAT package:","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Many people in the MRI community use MATLAB; you might be one of them and may want to process the Raw Signal in the MATLAB environment after simulation is completed with KomaMRI. Here, we provide an example of how to save a .mat file containing the  Raw Signal information using the MAT package.","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"# Use the MAT package\nusing MAT\n\n# Perform simulation to return an Array type\nsim_params[\"return_type\"] = \"mat\"\nraw = simulate(obj, seq, sys; sim_params)\n\n# Save the .mat file in the temp directory\nmatwrite(joinpath(tempdir(), \"koma-raw.mat\"), Dict(\"raw\" => raw))","category":"page"},{"location":"how-to/2-3-use-koma-scripts/","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"Note that we need to simulate to return an array type (not the default RawAcquisitionData), and then we utilize the matwrite function to save a file named \"koma-raw.mat\" in your computer's temporary directory. Now, you can navigate to your temporary directory (which you can find by displaying the result of tempdir() in the Julia REPL) and locate the \"koma-raw.mat\" file.","category":"page"},{"location":"reference/4-koma-files/#KomaMRIFiles","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"","category":"section"},{"location":"reference/4-koma-files/#Sequence","page":"KomaMRIFiles","title":"Sequence","text":"","category":"section"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_seq","page":"KomaMRIFiles","title":"KomaMRIFiles.read_seq","text":"seq = read_seq(filename)\n\nReturns the Sequence struct from a Pulseq file with .seq extension.\n\nArguments\n\nfilename: (::String) absolute or relative path of the sequence file .seq\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#Phantom","page":"KomaMRIFiles","title":"Phantom","text":"","category":"section"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_jemris","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_jemris","text":"obj = read_phantom_jemris(filename)\n\nReturns the Phantom struct from a JEMRIS phantom file .h5.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .h5\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.h5\")\n\njulia> obj = read_phantom_jemris(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_MRiLab","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_MRiLab","text":"obj = read_phantom_MRiLab(filename)\n\nReturns the Phantom struct from a MRiLab phantom file .mat.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .mat\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.mat\")\n\njulia> obj = read_phantom_MRiLab(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom","text":"phantom = read_phantom(filename)\n\nReads a (.phantom) file and creates a Phantom structure from it\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.write_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.write_phantom","text":"phantom = write_phantom(ph,filename)\n\nWrites a (.phantom) file from a Phantom struct.\n\n\n\n\n\n","category":"function"},{"location":"how-to/5-contribute-to-koma/#Contribute-to-Koma","page":"Contribute to Koma","title":"Contribute to Koma","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you're interested in contributing to Koma, this document will guide you through configuring everything you need to get started. By contributing, you help enhance the functionality, usability, and performance of the Koma ecosystem. Your efforts are welcomed because it help us to advancing the project. Before you begin, it's necessary to install and configure a few essential tools on your machine to ensure a smooth development experience:","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Git\nGitHub\nVScode\nVScode Plugins: \nJulia \nGitHub Pull Requests","category":"page"},{"location":"how-to/5-contribute-to-koma/#Installing-KomaMRI-as-a-developer","page":"Contribute to Koma","title":"Installing KomaMRI as a developer","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/#1.-Clone-KomaMRI-repository","page":"Contribute to Koma","title":"1. Clone KomaMRI repository","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To install the dev version of Koma, we will use the Julia REPL:","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"pkg> dev KomaMRI","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"This command will clone KomaMRI.jl's repository (dev version) to your ~/.julia/dev/KomaMRI/ directory if you are in a MacOS or Linux operative system, or C:\\Users\\<user-name>\\.julia\\dev\\KomaMRI\\ if you are using Windows, where <user-name> should be replaced with your Windows user.","category":"page"},{"location":"how-to/5-contribute-to-koma/#2.-Create-your-fork-of-KomaMRI","page":"Contribute to Koma","title":"2. Create your fork of KomaMRI","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you try to commit or generate a pull request at this point, you will get an Access denied error. This is because you need to create a fork before you can contribute to this repository directly (unless you are included as a collaborator!).","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To create this fork, go to the official KomaMRI repository and follow the steps below:","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"(Image: ) (Image: )","category":"page"},{"location":"how-to/5-contribute-to-koma/#3.-Access-your-GitHub-account-in-VSCode","page":"Contribute to Koma","title":"3. Access your GitHub account in VSCode","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Now, you need to ensure that your GitHub account is connected to VSCode. This allows you to clone repositories, create branches, and manage pull request directrly within VSCode.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Open VSCode.\nGo to the Source Control tab.\nSign in to your GitHub account if you're not already signed in.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"💡You can also check if your git credentials are correctlly added to your machine by writing in the VScode terminal:git config --global user.name\ngit config --global user.email","category":"page"},{"location":"how-to/5-contribute-to-koma/#4.-Open-your-forked-repository-in-VSCode","page":"Contribute to Koma","title":"4. Open your forked repository in VSCode","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"In VSCode, click on File -> Open Folder... and select your ~/.julia/dev/KomaMRI/ directory (C:\\Users\\<user-name>\\.julia\\dev\\KomaMRI\\ if you are using Windows).","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Now add the fork URL by clicking Source Control -> ... -> Remote -> Add Remote...","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"    <img width=\"80%\" src=\"../../assets/add-remote.png\">","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"This will create the option to provide a repository URL. Here is where you will paste your fork URL and give it the name my-fork.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"(Image: ) (Image: )","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"💡Press Yes when prompted to constantly fetch in the future.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"The Julia extension should automatically detect the KomaMRI environment. To check this, look at the status bar (bottom) end you should see Julia env: KomaMRI. If this is not the case, click the option in the menu bar and select KomaMRI.jl.","category":"page"},{"location":"how-to/5-contribute-to-koma/#5.-KomaMRI-monorepo-setup","page":"Contribute to Koma","title":"5. KomaMRI monorepo setup","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"As KomaMRI.jl contains multiple packages in one GitHub repository, you need to specify that you want to use your local copies (instead of the ones available on the Julia registries) and using the instantiate command to install all the required packages (specified in Project.toml) with the following script:","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"using Pkg  \n# Koma sub-packages dev setup  \nkoma_subpkgs = [\"KomaMRICore\", \"KomaMRIFiles\", \"KomaMRIPlots\"]  \nfor pkg in koma_subpkgs  \n    Pkg.activate(pkg)  \n    Pkg.develop(path = \"./KomaMRIBase\")  \nend  \n# Main package (KomaMRI) dev setup  \nPkg.activate(\".\")  \nfor pkg in koma_subpkgs  \n    Pkg.develop(path = \"./$pkg\")  \nend\nPkg.instantiate()","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"In case you want to contribute specifically in documentation, you will need to use the docs enviroment with the following script:","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Pkg.activate(\"docs\")\nPkg.develop(path = \".\")\nPkg.instantiate()","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"This will also include all the specific package versions into the Manifest.toml. The Manifest.toml should not be updated to the repo when making a commit or pull request. Thus, it is present in the .gitignore.","category":"page"},{"location":"how-to/5-contribute-to-koma/#6.-Create-a-new-branch-for-your-feature","page":"Contribute to Koma","title":"6. Create a new branch for your feature","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you did correctly follow the previous steps you will have correctly created your fork connected to the original Koma repository. Now, if you want to create your own changes, you will need to create a new branch from your fork.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To create this new branch, go to Source Control -> ... -> Branch -> Create Branch form...","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"    <img width=\"80%\" src=\"../../assets/add-branch.png\">","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"This will open a menu to select an starting point for your branch. Select my-fork/master as your starting point, and give it the name my-new-feature.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"(Image: ) (Image: )","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"💡In your VScode terminal use git status to check if your branch is correctly created. Your branch should be listed at the top of the output.","category":"page"},{"location":"how-to/5-contribute-to-koma/#How-to-commit","page":"Contribute to Koma","title":"How to commit","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you have already created your first modifications in your local version of the repository, you will want to commit your changes in your public branch.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To do this, in VScode go to the Source Control panel in the Activity Bar.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Assuming you are currently in your my-new-feature branch, the Source Control panel should show your changes to the project and the option to create a commit message.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"    <img width=\"40%\" src=\"../../assets/how-to-commit.png\">","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you hove over the Changes tab, it should show a + icon. Press it to stage all changes in the project.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Write down a message that describes your changes you are stageing to the project, and press the Commit button.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"Press Sync Changes to push your commit into your branch.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"💡 If you want to make sure if the commit was correctly done, check your GitHub repository and see if the changes you commited are present.","category":"page"},{"location":"how-to/5-contribute-to-koma/#How-to-create-a-pull-request","page":"Contribute to Koma","title":"How to create a pull request","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you want to send your commited new version of the repository, you can create a pull request that will be reviewed by a Koma certified developer.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To create this pull request, in VScode, go to the GitHub Pull Request panel in the Activity Bar and hove over the Pull request tab. This should show a Create pull request icon to press.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"    <img width=\"50%\" src=\"../../assets/create-pull-request.png\">","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"In the Create tab that appears, select JuliaHealth/master as the base and the branch you are working with to merge.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"To finish your pull request, give it a name with a clear mention of the  subject of the contribution you made, and a description that explains the issue or feature you are addresing in your branch, and press the Create button.","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"    <img width=\"50%\" src=\"../../assets/fill-pull-request.png\">","category":"page"},{"location":"how-to/5-contribute-to-koma/","page":"Contribute to Koma","title":"Contribute to Koma","text":"💡 Tips for a successful Pull Request:Try to address one issue or feature per pull request to make it easier for reviewers.\nProvide all the context necesary, including all the information of the related issue or added feature.\nRespond to feedback and suggestions to make adjustments based on the reviewers comments.","category":"page"},{"location":"explanation/4-sequence/#Sequence","page":"Sequence","title":"Sequence","text":"","category":"section"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"This section delves into some details about how a sequence is constructed. The sequence definition in KomaMRI is strongly related to the Pulseq definition. After reading this section, you should be able to create your own Sequence structs for conducting custom simulations using the KomaMRI package.","category":"page"},{"location":"explanation/4-sequence/#KomaMRI-Sequence-Overview","page":"Sequence","title":"KomaMRI Sequence Overview","text":"","category":"section"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"Let's introduce the following simple sequence figure to expand from a visual example to a more general sequence definition:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"<p align=\"center\"><img width=\"80%\" src=\"../../assets/sequence-diagram.svg\"/></p>","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"A sequence can be thought of as an ordered concatenation of blocks over time. Each block is essentially a sequence with a length of 1. Every block consists of an RF pulse, the (xyz) gradients, and the acquisition of samples. Each block also has an associated time duration. To simplify, we will refer to these components as follows:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"beginmatrix*l\ntextseqi        textblock i of the sequence \ntextseqRFi     textRF pulse at the i block \ntextseqGRxi   textgradient x at the i block \ntextseqGRyi   textgradient y at the i block \ntextseqGRzi   textgradient z at the i block \ntextseqADCi    textacquisition at the i block \ntextseqDURi    textduration at the i block\nendmatrix*","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"The best way to understand the Sequence struct in KomaMRI is by examining the source code where this struct is defined:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"mutable struct Sequence\n    GR::Array{Grad,2}\n    RF::Array{RF,2}\n    ADC::Array{ADC,1}\n    DUR::Array{Any,1}\n    DEF::Dict{String,Any}\nend","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"As you can see, a Sequence struct contains 5 field names: ''DEF'' contains information for reconstruction steps (so it is not mandatory to fill it), ''DUR'' is a vector that contains the time durations of each block, ''ADC'' is also a vector with the acquisition samples for every block (an vector of ADC structs), ''GR'' is a 2D matrix which 3 rows representing the x-y-z gradients and columns having the samples of each block (a matrix of Grad structs) and ''RF'' is also a 2D matrix where each row represents a different coil and the columns are for different block samples too (a matrix of RF structs). The RF, Grad and ADC are MRI events that will be explained in the section Events Definitions.","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"warning: Warning\nSo far, KomaMRI can only manage one coil for RF excitations. However, in future versions, parallel transmit pTX will be managed by adding more ``rows'' to the RF matrix of the Sequence field name.","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"In order to understand how a Sequence struct can be manipulated in Julia, let's use the EPI sequence example. You can display basic information of the Sequence variable in the Julia REPL:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq = PulseDesigner.EPI_example()\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"As you can see, this Sequence has 204 blocks, 1 of these blocks has an RF struct with values different from zero, there are 205 number of Grad structs considering the x-y-z components, 101 ADC structs acquire samples of some blocks and 62.846 ms is the total time duration of the complete Sequence.","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"To display the sequence in an graph, we can use the plot_seq function:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"julia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-epi-example-full.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"This way, you can see exactly where the RF, Grad and ADC structs are located in time.","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"You can access and filter information for the RF, Grad, ADC, and DUR field names of a Sequence using the dot notation. This allows you to display helpful information about the organization of the Sequence struct:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq.RF\n1×204 Matrix{RF}:\n ⊓(0.5872 ms)  ⇿(0.0 ms)  ⇿(0.0 ms)  …  ⇿(0.0 ms)  ⇿(0.0 ms)   \n\njulia> seq.GR\n3×204 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)  …  ⇿(0.2062 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)     ⊓(0.2062 ms)  ⇿(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> seq.ADC\n204-element Vector{ADC}:\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ⋮\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n\njulia> seq.DUR\n204-element Vector{Float64}:\n 0.0005871650124959989\n 0.0004042313086942605\n 0.0004042313086942605\n ⋮\n 0.0004042313086942605\n 0.0004042313086942605","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"Additionally, you can access a subset of blocks in a Sequence by slicing or indexing. The result will also be a Sequence struct, allowing you to perform the same operations as you would with a full Sequence (just a heads-up: this is analogous for the Phantom structure). For example, if you want to analyze the first 11 blocks, you can do the following:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"julia> seq[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq[1:11].GR\n3×11 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)   …  ⊓(0.4042 ms)  ⇿(0.2062 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)      ⇿(0.4042 ms)  ⊓(0.2062 ms)  ⇿(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> plot_seq(seq[1:11]; slider=false)","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-epi-example-some-blocks.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/4-sequence/#Concatenation-of-Sequences","page":"Sequence","title":"Concatenation of Sequences","text":"","category":"section"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"Sequences can be concatenated side by side. The example below demonstrates how to concatenate sequences:","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"julia> s = PulseDesigner.EPI_example()[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq = s + s + s\nSequence[ τ = 11.512 ms | blocks: 33 | ADC: 15 | GR: 33 | RF: 3 | DEF: 5 ]\n\njulia> plot_seq(seq; slider=false)","category":"page"},{"location":"explanation/4-sequence/","page":"Sequence","title":"Sequence","text":"<object type=\"text/html\" data=\"../../assets/seq-concatenation.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"explanation/2-motion/#Motion","page":"Motion","title":"Motion","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"using KomaMRI # hide\nobj = brain_phantom2D() # hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Koma can easily simulate the effects of motion during acquisitions. As introduced in the previous section, the motion-related information of the phantom is stored in the motion field of its structure.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Koma's motion model has been designed to accomodate a variety of real-world scenarios, including:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Patient motion inside a scanner, which may involve simultaneous or sequential translations and rotations of body parts during the acquisition.\nMyocardial motion, including simulataneous contraction, rotation, torsion, and translation motion within the cardiac cycle.\nPseudo-periodic heart patterns, caused by variations in heart rate or arrhythmias that prevent the heart's motion from being perfectly periodic.\nFlow through blood vessels, where the spin trajectories or fluid fields may have been obtained from Computational Fluid Dynamics (CFD) simulations.\nDiffusion, which can be modeled, among many other ways, as microscopic Brownian spin trajectories.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"... And, ultimately, any type of motion you can think of, no matter how complex!","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"To handle these scenarios, Koma represents motion as a collection of elementary movements that can be independently configured and combined. This approach allows for the definition of any complex motion pattern, with the ability to specify overlapping time intervals and even model bidirectional motions along predefined trajectories.","category":"page"},{"location":"explanation/2-motion/#Understanding-the-motion-field-and-its-possible-values","page":"Motion","title":"Understanding the motion field and its possible values","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"The motion field within the Phantom struct can take different values depending on whether the phantom is static or dynamic. For static phantoms, the field is set to NoMotion. For dynamic phantoms, the field can be either a Motion or a MotionList struct. A Motion represents a single movement, characterized by an action, a time curve, and a range of affected spins. Regarding the MotionList struct, it is simply a collection of Motion instances, which is useful for defining motion compositions.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"struct Phantom{T<:Real}\n    (...)\n    #Motion\n    motion::Union{NoMotion, Motion{T}, MotionList{T}} = NoMotion()\nend","category":"page"},{"location":"explanation/2-motion/#NoMotion-struct","page":"Motion","title":"NoMotion struct","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"NoMotion is the default type for static phantoms. Since its structure has no fields, making a phantom static is as simple as:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = NoMotion()","category":"page"},{"location":"explanation/2-motion/#Motion-struct","page":"Motion","title":"Motion struct","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"The Motion struct contains information about a basic motion, understood as the combination of an action, a time curve and a spins span. This three fields will be described in detail later. Here is an example of how to assign a motion to a phantom in this case:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = Motion(Translate(0.0, 0.1, 0.2), TimeRange(0.0, 1.0), AllSpins())","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"note: Note\nThere are Motion constructors that simplify its definition:obj.motion = Translate(0.0, 0.1, 0.2, TimeRange(0.0, 1.0), AllSpins())","category":"page"},{"location":"explanation/2-motion/#MotionList-struct","page":"Motion","title":"MotionList struct","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"The MotionList struct contains a single field called motions, which is a vector of Motion instances. This design makes it possible to define both sequential and simultaneous concatenations of motions over time. An example of how this would be used is:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = MotionList(\n    Motion(Translate(0.0, 0.1, 0.2), TimeRange(0.0, 1.0), AllSpins()),\n    Motion(Rotate(0.0, 0.0, 45.0), Periodic(1.0, 0.5), SpinRange(1:1000))\n)","category":"page"},{"location":"explanation/2-motion/#The-Motion-structure-and-its-fields","page":"Motion","title":"The Motion structure and its fields","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"The Motion struct is the basic building block for defining motion in Koma. As we mentioned earlier, it has three main fields: action, time, and spins. Together, these fields define what the motion is, when it happens, and which spins are involved:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"struct Motion{T<:Real}\n    action::AbstractAction{T}\n    time  ::TimeCurve{T}\n    spins ::AbstractSpinSpan\nend","category":"page"},{"location":"explanation/2-motion/#The-action-field","page":"Motion","title":"The action field","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Let's start with the action field, which defines the type and magnitude (i.e., the final state) of the motion. Currently, Koma supports five actions: Translate, Rotate, HeartBeat, Path, and FlowPath. The first three fall under the category of SimpleActions, while the last two belong to the ArbitraryActions. SimpleActions are defined by parameters that are easy to understand and use, such as translation distance, rotation angles, or contraction rates. ArbitraryActions, on the other hand, are more complex and can be defined by a set of spin trajectories.","category":"page"},{"location":"explanation/2-motion/#The-time-field","page":"Motion","title":"The time field","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"The time field defines how the motion behaves over time and must be an instance of the TimeCurve struct, which works similarly to animation curves in video editing, 3D design, or video games. Essentially, it allows you to adjust the \"timing\" of the motion without affecting its magnitude or other characteristics.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Given an initial and final state (see the action field), time curves allow you to define how the transition between those states should occur. The TimeCurve structure lets you define an animation curve by specifying the coordinates of its points, along with two additional parameters that control its periodicity and pseudo-periodicity:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"struct TimeCurve{T<:Real}\n    t::AbstractVector{T}\n    t_unit::AbstractVector{T}\n    periodic::Bool\n    periods::Union{T,AbstractVector{T}}\nend","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"This enables you to create any type of curve, and thus, any kind of motion pattern over time.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"A full description of this structure, including examples and constructors, can be found in the TimeCurve API reference.","category":"page"},{"location":"explanation/2-motion/#The-spins-field","page":"Motion","title":"The spins field","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Finally, the spins field must be an instance of the AbstractSpinSpan type. It defines which spins in the phantom are affected by the motion, and which of them remain static. This allows you to define motions that only affect a subset of spins, while keeping others unaffected.","category":"page"},{"location":"explanation/2-motion/#See-it-in-action","page":"Motion","title":"See it in action","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Now that we have a basic understanding of the motion field and its components, let's see some usage examples. In all cases, we start with the same phantom: a hollow cube with 1 mm side length and 20 µm spin spacing, centered at the origin and aligned with the coordinate axes. To make the motion easier to visualize, each face of the cube is given a different T1 value:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"L = 1e-3 # hide\nΔx = 20e-6 # hide\nx = y = z = -L/2:Δx:L/2 # hide\nxx = reshape(x, (length(x),1,1)) # hide\nyy = reshape(y, (1,length(y),1)) # hide\nzz = reshape(z, (1,1,length(z))) # hide\nx = 1*xx .+ 0*yy .+ 0*zz # hide\ny = 0*xx .+ 1*yy .+ 0*zz # hide\nz = 0*xx .+ 0*yy .+ 1*zz # hide\n◼(L) =((abs.(x) .<= L/2) .& (abs.(y) .<= L/2) .& (abs.(z) .<= L/2)) # hide\ncube = ◼(L) - ◼(L - Δx) # Hollow cube # hide\nρ = 1.0*cube #proton density # hide\nT1 = copy(ρ) # hide\nT1s = [100, 500, 1000, 2500, 2000, 1500] .* 1e-3 # hide\nidx_T1 = 1 # hide\nϵ = 1e-5 # hide\nfor (i, x) in enumerate([x,y,z]) # hide\n    for (j, L) in enumerate([-L/2, L/2]) # hide\n        T1[(L - ϵ) .<= x .<= (L + ϵ)] .= T1s[idx_T1] # hide\n        global idx_T1 += 1 # hide\n    end # hide\nend # hide\nobj = Phantom( x=x[ρ .!= 0], y=y[ρ .!= 0], z=z[ρ .!= 0], T1 = T1[ρ .!= 0] ) # hide\n\np = plot_phantom_map(obj, :T1; height=440) #hide\n\nsavefig(p, \"../assets/doc-2-phantom.html\") #hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"<center><object type=\"text/html\" data=\"../../assets/doc-2-phantom.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/2-motion/#Translation-motion","page":"Motion","title":"Translation motion","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"In this first example, we've added a translational motion of -0.5, 0.6, and 0.7 mm along the three spatial directions. The motion lasts for 1 second and affects the entire phantom:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = Translate(-5e-4, 6e-4, 7e-4, TimeRange(0.0, 1.0), AllSpins())","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Let’s plot this phantom and see how it moves. The time_samples argument specifies the number of time samples to be plotted. You can use the bottom slider to scroll through time and check its exact position at each moment:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"p1 = plot_phantom_map(obj, :T1; time_samples=11, height=440)\n\nsavefig(p1, \"../assets/doc-2-translate.html\") #hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"<center><object type=\"text/html\" data=\"../../assets/doc-2-translate.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/2-motion/#Rotation-motion","page":"Motion","title":"Rotation motion","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"In this case, we add a rotational motion to the phantom: 90º around the y-axis and 75º around the z-axis. Like before, the motion lasts for 1 second and affects all spins in the phantom:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = Rotate(0.0, 90.0, 75.0, TimeRange(0.0, 1.0), AllSpins())\n\np2 = plot_phantom_map(obj, :T1; time_samples=11, height=440) #hide\n\nsavefig(p2, \"../assets/doc-2-rotate.html\") #hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"<center><object type=\"text/html\" data=\"../../assets/doc-2-rotate.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/2-motion/#Adding-motion-to-a-phantom-subset","page":"Motion","title":"Adding motion to a phantom subset","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"Sometimes, you may want to assign motion to just a part of the phantom instead of the whole thing. This can be done using the SpinRange structure, where you specify the indices of the spins that should be affected. In this example, we apply a translational motion to the upper half of the phantom:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj.motion = Translate(-5e-4, 6e-4, 7e-4, TimeRange(0.0, 1.0), SpinRange(7500:15002))\n\np3 = plot_phantom_map(obj, :T1; time_samples=11, height=440) #hide\n\nsavefig(p3, \"../assets/doc-2-subset.html\") #hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"<center><object type=\"text/html\" data=\"../../assets/doc-2-subset.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/2-motion/#Motion-combination","page":"Motion","title":"Motion combination","text":"","category":"section"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"You can freely add multiple motions to a phantom, each with its own type, time span, and affected spin range. These motions can overlap in time (affecting the phantom simultaneously) or happen one after another. Both cases are fully supported, so you're free to combine different effects across various parts of the phantom and time intervals, creating as complex a motion pattern as you need.","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"This final example shows two brain phantoms undergoing the same translational and rotational motions, but with different time spans. In the top phantom, the translation takes place from 0 to 0.5 seconds, followed by the rotation from 0.5 to 1 second. In the bottom phantom, both motions happen over the same time span, from 0 to 1 second:","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"obj1 = brain_phantom2D() #hide\nobj2 = copy(obj1) #hide\nobj1.x .-= 20e-2; obj2.x .-= 20e-2 #hide\nobj1.y .+= 12e-2; obj2.y .-= 12e-2 #hide\n\nobj1.motion = MotionList(\n    Translate(40e-2, 0.0, 0.0, TimeRange(0.0, 0.5),AllSpins()),\n    Rotate(0.0, 0.0, 90.0, TimeRange(0.5, 1.0),AllSpins()),\n)\n\nobj2.motion = MotionList(\n    Translate(40e-2, 0.0, 0.0, TimeRange(0.0, 1.0),AllSpins()),\n    Rotate(0.0, 0.0, 90.0, TimeRange(0.0, 1.0),AllSpins()),\n)\n\nobj = obj1 + obj2\n\np4 = plot_phantom_map(obj, :T1; time_samples=11, view_2d=true, height=440) # hide\n\nsavefig(p4, \"../assets/doc-2-combination.html\") #hide","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"<center><object type=\"text/html\" data=\"../../assets/doc-2-combination.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"","category":"page"},{"location":"explanation/2-motion/","page":"Motion","title":"Motion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/7-gpu-explanation/#GPU-Parallelization","page":"GPU Parallelization","title":"GPU Parallelization","text":"","category":"section"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"KomaMRI uses a vendor agnostic approach to GPU parallelization in order to support multiple GPU backends. Currently, the following backends are supported:","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"CUDA.jl (Nvidia)\nMetal.jl (Apple)\nAMDGPU.jl (AMD)\noneAPI.jl (Intel)","category":"page"},{"location":"explanation/7-gpu-explanation/#Choosing-a-GPU-Backend","page":"GPU Parallelization","title":"Choosing a GPU Backend","text":"","category":"section"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"To determine which backend to use, KomaMRI uses package extensions (introduced in Julia 1.9) to avoid having the packages for each GPU backend as explicit dependencies. This means that the user is responsible for loading the backend package (e.g. using CUDA) at the beginning of their code, or prior to calling KomaUI(), otherwise, Koma will default back to the CPU:","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"using KomaMRI\nusing CUDA # loading CUDA will load KomaMRICoreCUDAExt, selecting the backend","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Once this is done, no further action is needed! The simulation objects will automatically be moved to the GPU and back once the simulation is finished. When the simulation is run a message will be shown with either the GPU device being used or the number of CPU threads if running on the CPU.","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Of course, it is still possible to move objects to the GPU manually, and control precision using the f32 and f64 functions:","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"x = rand(100)\nx |> f32 |> gpu # Float32 CuArray","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"To change the precision level used for the entire simulation, the sim_params[\"precision\"] parameter can be set to either f32 or f64 (Note that for most GPUs, Float32 operations are considerably faster compared with Float64). In addition, the sim_params[\"gpu\"] option can be set to true or false to enable / disable the gpu functionality (if set to true, the backend package will still need to be loaded beforehand):","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Two other simulation parameters, gpu_groupsize_precession and gpu_groupsize_excitation are exposed to allow adjusting the number of threads in each threadgroup within the run_spin_precession! and run_spin_excitation! gpu kernels. By default, they are both 256, however, on some devices other values may result in faster performance. The gpu groupsize must be a multiple of 32 between 32 and no higher than 1024, otherwise the simulation will throw an error.","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"using KomaMRI\nusing CUDA\nsys = Scanner\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n#Simulate on the GPU using 32-bit floating point values\nsim_params = Dict{String,Any}(\n  \"Nblocks\" => 20,\n  \"gpu\" => true,\n  \"precision\" => \"f32\"\n  \"sim_method\" => Bloch(),\n)\nsimulate(obj, seq, sys; sim_params)","category":"page"},{"location":"explanation/7-gpu-explanation/#How-Objects-are-moved-to-the-GPU","page":"GPU Parallelization","title":"How Objects are moved to the GPU","text":"","category":"section"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Koma's gpu function implementation calls a separate gpu function with a backend parameter of type <:KernelAbstractions.GPU for the backend it is using. This function then calls the fmap function from package Functors.jl to recursively call adapt from package Adapt.jl on each field of the object being transferred. This is similar to how many other Julia packages, such as Flux.jl, transfer data to the GPU. However, an important difference is that KomaMRI adapts directly to the KernelAbstractions.Backend type in order to use the adapt_storage functions defined in each backend package, rather than defining custom adapters, resulting in an implementation with fewer lines of code.","category":"page"},{"location":"explanation/7-gpu-explanation/#Inside-the-Simulation","page":"GPU Parallelization","title":"Inside the Simulation","text":"","category":"section"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"KomaMRI has three different simulation methods, all of which can run on the GPU: ","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochSimple: BlochSimple.jl\nBlochDict: BlochDict.jl\nBloch: BlochCPU.jl / BlochGPU.jl","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochSimple uses array-based methods which are simpler to understand compared with the more optimized Bloch implementation.","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"BlochDict can be understood as an extension to BlochSimple that outputs a more detailed signal.","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Bloch is equivalent to BlochSimple in the operations it performs, but has separate implementations optimized for both the CPU and GPU. The CPU implementation uses array broadcasting for computation and preallocates all simulation arrays to conserve memory. The simulation arrays are 1-dimensional with length equal to the number of spins in the phantom and are updated at each time step. The GPU implementation also uses preallocation and a similar loop-based computation strategy, but does so using kernels for spin precession and excitation implemented using the KernelAbstractions.jl package. A key advantage of using kernel-based methods is that intermediate values compuated based on phantom and sequence properties can be stored in registers without having to write back to GPU global memory, which has much higher memory latency compared with the CPU. Other optimizations within the kernels include:","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"Reducing the output signal value at each time step within the kernel so that the first thread for each thread group writes the sum of the signal values for each thread in the threadgroup to GPU global memory. This reduces the number of GPU global memory reads + writes needed for the output signal from Number of Spins x Number of Time Points to Number of Spins x Number of Time Points / Number of Threads in Threadgroup, improving scalability for large phantom objects.\nUsing julia's Val type to specialize at compile-time on properties unique to the simulation inputs. For example, whether the phantom exibits spin motion is passed as either Val(true) or Val(false) to the precession kernel so that different kernels will be compiled for phantoms with or without motion. For the kernel compiled for phantoms without motion, there will be no runtime check of the motion type of the phantom, and everything inside the if MOTION statements in the kernel will be compiled out, saving register space and enabling further compiler optimizations. This strategy enables adding support in the future for less common use cases without negatively impacting performance for simulations not using these features.\nSince GPU registers are limited and can hurt GPU occupancy if a kernel uses a high number, their use is minimized by working with real and imaginary components directly rather than abstracting complex number math, using unsigned int32 literal values instead of Julia's default Int64, and inlining all functions called from within the kernels.","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"The performance differences between Bloch and BlochSimple can be seen on the KomaMRI benchmarks page. The first data point is from when Bloch was what is now BlochSimple, before a more optimized implementation was created. The following pull requests are primarily responsible for the performance differences between Bloch and BlochSimple:","category":"page"},{"location":"explanation/7-gpu-explanation/","page":"GPU Parallelization","title":"GPU Parallelization","text":"(443) Optimize runspinprecession! and runspinexcitation! for CPU\n(459) Optimize runspinprecession! for GPU\n(462) Optimize runspinexcitation! for GPU\n(537) Faster Bloch GPU","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/#Use-Koma-in-Notebooks","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"You can use KomaMRI with popular programming environments such as Pluto and Jupyter notebooks. The following sections show how to set up these notebooks and test KomaMRI with them.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/#Pluto","page":"Use Koma in Notebooks","title":"Pluto","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"First, install the Pluto module in your Julia environment. Remember to press the ] button to open the Package Manager Session:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia>\n\n@(1.9) pkg> add Pluto","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Afterward, return to the Julia Session by pressing the backspace button, and then execute the Pluto.run() function:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia> using Pluto\n\njulia> Pluto.run()","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"This should automatically open the Pluto dashboard in your default web browser:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/pluto-dashboard.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, create a new notebook by clicking on + Create a new notebook:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/pluto-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Write and run the following code, which is identical to the Free Induction Decay example. Pluto automatically installs the required modules if they are not present on your system. Additionally, note that we do not directly use KomaMRI since we won't be utilizing the KomaUI function. Instead, we rely on the KomaMRICore and KomaMRIPlots dependencies. To display plots in Pluto, ensure that you import the PlutoPlotly package, as KomaMRIPlots requires its backend to display figures in Pluto:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<embed type=\"text/html\" src=\"../../assets/pluto-fid-example.html\" style=\"height:1024px;width:100%;\">","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"One of the most outstanding features of Pluto is its ability to ensure reproducibility by storing the information necessary to recreate the package environment in the notebook file. When others open your notebook with Pluto, it automatically ensures they use the exact same package environment, guaranteeing seamless functionality on their computers.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/#Jupyter","page":"Use Koma in Notebooks","title":"Jupyter","text":"","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Ensure you have Jupyter installed on your computer. Follow this tutorial for installation using Anaconda.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, install the IJulia module in your Julia environment. Remember to press the ] key to open the Package Manager Session:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"julia>\n\n(@v1.9) pkg> add IJulia","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"For this example, make sure to install KomaMRICore and KomaMRIPlots (we do not use KomaMRI directly since we won't be utilizing the KomaUI() function):","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"(@v1.9) pkg> add KomaMRICore\n\n(@v1.9) pkg> add KomaMRIPlots","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Next, open Jupyter, navigate to a working folder, and create a new notebook by clicking on New, then Julia 1.9.3.\"","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-create-new-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"A new, empty notebook will appear:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Proceed to write and execute the provided example:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<details><summary>View code</summary>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"# Import modules\nusing KomaMRICore, KomaMRIPlots\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\n\n# Plot the sequence\nplot_seq(seq; slider=false, height=300)","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"</details>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-test-notebook.png\" alt=\"\" style=\"width:100%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"This should be sufficient, and now you can start working with KomaMRI using Jupyter notebooks.","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"If you encounter the issue of WebIO not being detected:","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"<center><img src=\"../../assets/jupyter-webio-problem.png\" alt=\"\" style=\"width:75%;\"></center>","category":"page"},{"location":"how-to/2-2-use-koma-notebooks/","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"Refer to this IJulia documentation and this troubleshooting guide for details. Essentially, you need to install a WebIO extension depending on your Jupyter installation.","category":"page"},{"location":"how-to/4-run-distributed-simulations/#Run-Distributed-Simulations","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"While KomaMRI provides built-in support for CPU and GPU parallelization, it is sometimes desirable to distribute simulation work even further across multiple GPUs or compute nodes. This can be done by using Distributed.jl and making use of the independent spin property: each spin in the system is independent from the rest, so the phantom spins can be subdivided into separate simulations and results recombined, as in the diagram below:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNode.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"The following two examples demonstrate how to use Distributed.jl to run a simulation using multiple GPUS, and using multiple nodes in an HPC cluster.","category":"page"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-GPUs","page":"Run Distributed Simulations","title":"Using Multiple GPUs","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"To run a simulation using multiple GPUs, the phantom object can be divided using the kfoldperm function. Distributed.jl can then be used to start one Julia worker process per available device so that each device simulates a different part of the object. The results can then be fetched asynchronously by the main process and combined to produce a final signal. This is shown in the following diagram: ","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiGPU.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"The SLURM SBATCH script below requests 4 GPUs, all on a single computer. The Julia code then distributes work among each GPU:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"details: SLURM Script Requesting Multiple GPUs\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --ntasks=1                                 # 1 task\n#SBATCH --cpus-per-task=1                          # Request 1 CPU\n#SBATCH --gpus=4                                   # Request 4 GPUs\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"using Distributed\nusing CUDA\n\n#Add workers based on the number of available devices\naddprocs(length(devices()))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI, CUDA\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    #Divide phantom\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    KomaMRICore.set_device!(i-1) #Sets device for this worker, note that CUDA devices are indexed from 0\n    simulate(obj[parts[i]], seq, sys)\nend","category":"page"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-Nodes-in-an-HPC-Cluster","page":"Run Distributed Simulations","title":"Using Multiple Nodes in an HPC Cluster","text":"","category":"section"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"This example uses the package ClusterManagers.jl to initialize worker processes on a SLURM cluster based on the number of tasks specified in the #SBATCH –ntasks directive. This can be useful to divide simulation work among multiple compute nodes if the problem is too large to fit into memory for a single computer, or if the number of desired workers is greater than the typical number of CPU cores available. An illustration of this is shown below:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNodeCPU.svg\"/></p>","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"This SBATCH script requests 20 separate nodes, with each taking a single task. The Julia code is similar to the example for multiple GPUs, but initializes the processes slightly differently:","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"details: SLURM Script Requesting Multiple Nodes\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --nodes=20                                 # 20 nodes\n#SBATCH --ntasks=20                                # 20 tasks\n#SBATCH --ntasks-per-node=1                        # 1 task per node\n#SBATCH --cpus-per-task=4                          # 4 CPUs per task\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl","category":"page"},{"location":"how-to/4-run-distributed-simulations/","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"using Distributed\nusing ClusterManagers\n\n#Add workers based on the specified number of SLURM tasks\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    simulate(obj[parts[i]], seq, sys)\nend","category":"page"},{"location":"explanation/1-phantom/#Phantom","page":"Phantom","title":"Phantom","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"using KomaMRI #hide","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"The first input argument that KomaMRI needs for simulating is the phantom.","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"This section goes over the concept of digital phantom and shows how it applies to the specific case of KomaMRI. We'll go into detail about the Phantom structure and its supported operations.","category":"page"},{"location":"explanation/1-phantom/#Digital-Phantom","page":"Phantom","title":"Digital Phantom","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"A digital phantom is basically a computer model of a physical object (like the human body or a body part) which is used  in simulations to mimic the characteristics and behaviour that would be obtained from real MRI. Instead of using a physical object for testing, the digital phantom allows for virtual experiments.","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"This computer model should essentially contain information about the position and/or displacements of the tissues, as well as their MRI-related (T1, T2, PD, off-resonance...) values.","category":"page"},{"location":"explanation/1-phantom/#KomaMRI-Phantom-Overview","page":"Phantom","title":"KomaMRI Phantom Overview","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"In Koma, a phantom is made up of a set of spins (which in many cases are also known as ''isochromats''). Each spin is independent of the others in terms of properties, position and state. This is a key feature of KomaMRI, as it is explained in the Simulation section.","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"Let's take a look at the definition of the Phantom struct inside Koma's source code to see what it looks like:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"@with_kw mutable struct Phantom{T<:Real}\n    name::String = \"spins\"\n    x::AbstractVector{T}\n    y::AbstractVector{T}   = zeros(eltype(x), size(x))\n    z::AbstractVector{T}   = zeros(eltype(x), size(x))\n    ρ::AbstractVector{T}   = ones(eltype(x), size(x))\n    T1::AbstractVector{T}  = ones(eltype(x), size(x)) * 1_000_000\n    T2::AbstractVector{T}  = ones(eltype(x), size(x)) * 1_000_000\n    T2s::AbstractVector{T} = ones(eltype(x), size(x)) * 1_000_000\n    #Off-resonance related\n    Δw::AbstractVector{T}  = zeros(eltype(x), size(x))\n    #Diffusion\n    Dλ1::AbstractVector{T} = zeros(eltype(x), size(x))\n    Dλ2::AbstractVector{T} = zeros(eltype(x), size(x))\n    Dθ::AbstractVector{T}  = zeros(eltype(x), size(x))\n    #Motion\n    motion::Union{NoMotion, Motion{T}, MotionList{T}} = NoMotion()\nend","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"This structure consists of several elements. Most of them are vectors, except for the name (self-explanatory) and motion (explained below) fields. These vectors represent object properties, with each element holding a value associated with a single magnetization (i.e. a single spin). Specifically, x, y and z are the initial spatial coordinates of each spin. ρ stands for the proton density, and T1, T2 and T2s (standing for T2*) are the well-known relaxation times. Δw accounts for off-resonance effects. Dλ1, Dλ2 and Dθ are diffusion-related fields which are not in use at the moment. Last, the motion field stands for spin displacements, which are added to x, y and z when simulating in order to obtain the spin positions at each time step. For more information about motion, refer to Motion section.","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"To get an even better understanding on how this structure works, let's look at an example of a brain phantom:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"obj = brain_phantom2D()","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"Phantom{Float64}\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084  …  0.084, 0.084, 0.084, 0.084, 0.086, 0.086, 0.086, 0.086, 0.086, 0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028, -0.026, -0.024, -0.022, -0.02, -0.018, -0.016, -0.014, -0.012  …  0.006, 0.008, 0.01, 0.012, -0.008, -0.006, -0.004, -0.002, 0.0, 0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0  …  0.0, 0.0, 0.0, 0.0, -0.0, -0.0, -0.0, -0.0, 0.0, 0.0]\n  ρ: Array{Float64}((6506,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  T1: Array{Float64}((6506,)) [0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569  …  0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329  …  0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058  …  0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058]\n  Δw: Array{Float64}((6506,)) [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0  …  -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: NoMotion NoMotion()","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"You can visualize the Phantom struct using the plot_phantom_map function, which is part of the KomaMRIPlots subdependency. This function plots the magnitude of a property for each magnetization at a specific spatial position. You can observe properties such as proton density and relaxation times, so feel free to replace the :T1 symbol with another property of the phantom in the example below:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"p1 = plot_phantom_map(obj, :T1; height=450)\n\nsavefig(p1, \"../assets/doc-1-phantom.html\") #hide","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/doc-1-phantom.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"You can access and filter information for the all the field names of a Phantom using the dot notation:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"julia> obj.name\n\"brain2D_axial\"","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"julia> obj.x\n6506-element Vector{Float64}:\n -0.084\n -0.084\n -0.084\n  ⋮\n  0.086\n  0.086\n  0.086","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"julia> obj.motion\nNoMotion()","category":"page"},{"location":"explanation/1-phantom/#Phantom-Operations","page":"Phantom","title":"Phantom Operations","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"In addition, KomaMRI supports some phantom operations:","category":"page"},{"location":"explanation/1-phantom/#Phantom-Subset","page":"Phantom","title":"Phantom Subset","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"It is possible to access a subset of spins in a Phantom by slicing or indexing. The result will also be a Phantom struct, allowing you to perform the same operations as you would with a full Phantom:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"obj[1:2000]\np2 = plot_phantom_map(obj[1:1000], :T2 ; height=450) #hide\n\nsavefig(p2, \"../assets/tut-5-phantom-subset.html\") #hide","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom-subset.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/1-phantom/#Combination-of-Phantoms","page":"Phantom","title":"Combination of Phantoms","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"In the same way, we can add two or more phantoms, resulting in another Phantom struct:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"obj2 = pelvis_phantom2D()\nobj2.x .+= 0.1; obj.x.-= 0.1 #hide\nobj_sum = obj + obj2\np3 = plot_phantom_map(obj_sum, :T1 ; height=450) #hide\n\nsavefig(p3, \"../assets/tut-5-phantom-sum.html\") #hide","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom-sum.html\" style=\"width:85%; height:470px;\"></object></center>","category":"page"},{"location":"explanation/1-phantom/#Scalar-multiplication-of-a-Phantom","page":"Phantom","title":"Scalar multiplication of a Phantom","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"Finally, multiplying a phantom by a scalar multiplies its proton density (ρ) by that amount:","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"obj_mul = 3*obj","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"julia> obj.ρ\n6506-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n ⋮\n 1.0\n 1.0\n 1.0\n\njulia> obj_mul.ρ\n6506-element Vector{Float64}:\n 3.0\n 3.0\n 3.0\n ⋮\n 3.0\n 3.0\n 3.0","category":"page"},{"location":"explanation/1-phantom/#Phantom-Storage-and-Sharing","page":"Phantom","title":"Phantom Storage and Sharing","text":"","category":"section"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"Phantoms can be stored and shared thanks to our new Phantom File Format.","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"","category":"page"},{"location":"explanation/1-phantom/","page":"Phantom","title":"Phantom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/2-koma-base/#KomaMRIBase","page":"KomaMRIBase","title":"KomaMRIBase","text":"","category":"section"},{"location":"reference/2-koma-base/#Scanner-related-functions","page":"KomaMRIBase","title":"Scanner-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Scanner","page":"KomaMRIBase","title":"KomaMRIBase.Scanner","text":"sys = Scanner(B0, B1, Gmax, Smax, ADC_Δt, seq_Δt, GR_Δt, RF_Δt,\n    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)\n\nThe Scanner struct. It contains hardware limitations of the MRI resonator. It is an input for the simulation.\n\nArguments\n\nB0: (::Real, =1.5, [T]) main magnetic field strength\nB1: (::Real, =10e-6, [T]) maximum RF amplitude\nGmax: (::Real, =60e-3, [T/m]) maximum gradient amplitude\nSmax: (::Real, =500, [mT/m/ms]) gradient's maximum slew-rate\nADC_Δt: (::Real, =2e-6, [s]) ADC raster time\nseq_Δt: (::Real, =1e-5, [s]) sequence-block raster time\nGR_Δt: (::Real, =1e-5, [s]) gradient raster time\nRF_Δt: (::Real, =1e-6, [s]) RF raster time\nRF_ring_down_T: (::Real, =20e-6, [s]) RF ring down time\nRF_dead_time_T: (::Real, =100e-6, [s]) RF dead time\nADC_dead_time_T: (::Real, =10e-6, [s]) ADC dead time\n\nReturns\n\nsys: (::Scanner) Scanner struct\n\nExamples\n\njulia> sys = Scanner()\n\njulia> sys.B0\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Phantom-related-functions","page":"KomaMRIBase","title":"Phantom-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Phantom","page":"KomaMRIBase","title":"KomaMRIBase.Phantom","text":"obj = Phantom(name, x, y, z, ρ, T1, T2, T2s, Δw, Dλ1, Dλ2, Dθ, motion)\n\nThe Phantom struct. Most of its field names are vectors, with each element associated with a property value representing a spin. This struct serves as an input for the simulation.\n\nArguments\n\nname: (::String) phantom name\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nρ: (::AbstractVector{T<:Real}) spin proton density vector\nT1: (::AbstractVector{T<:Real}, [s]) spin T1 parameter vector\nT2: (::AbstractVector{T<:Real}, [s]) spin T2 parameter vector\nT2s: (::AbstractVector{T<:Real}, [s]) spin T2s parameter vector\nΔw: (::AbstractVector{T<:Real}, [rad/s]) spin off-resonance parameter vector\nDλ1: (::AbstractVector{T<:Real}) spin Dλ1 (diffusion) parameter vector\nDλ2: (::AbstractVector{T<:Real}) spin Dλ2 (diffusion) parameter vector\nDθ: (::AbstractVector{T<:Real}) spin Dθ (diffusion) parameter vector\nmotion: (::Union{NoMotion, Motion{T<:Real} MotionList{T<:Real}}) motion\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = Phantom(x=[0.0])\n\njulia> obj.ρ\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom2D","text":"phantom = brain_phantom2D(;axis=\"axial\", ss=4)\n\nCreates a two-dimensional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\naxis: (::String, =\"axial\", opts=[\"axial\", \"coronal\", \"sagittal\"]) orientation of the phantom\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy], if used ss is set to ss=1\ntissue_properties: (::Dict, =Dict()) phantom tissue properties in SI units considering the available tissues\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = brain_phantom2D(; axis=\"sagittal\", ss=1)\n\njulia> obj = brain_phantom2D(; axis=\"axial\", us=[1, 2])\n\njulia> phantom_values = \n    Dict(\n        # ρ, T1, T2, T2*, Δw\n        \"CSF\"           => [1,      2.569,  0.329,  0.058,  0],\n        \"GM\"            => [0.86,   0.833,  0.083,  0.069,  0],\n        \"WM\"            => [0.77,   0.500,  0.070,  0.061,  0],\n        \"FAT1\"          => [0,      0,      0,      0,      0],\n        \"MUSCLE\"        => [0,      0,      0,      0,      0],\n        \"SKIN/MUSCLE\"   => [0,      0,      0,      0,      0],\n        \"SKULL\"         => [0,      0,      0,      0,      0],\n        \"VESSELS\"       => [0,      0,      0,      0,      0],\n        \"FAT2\"          => [0,      0,      0,      0,      0],\n        \"DURA\"          => [0,      0,      0,      0,      0],\n        \"MARROW\"        => [0,      0,      0,      0,      0])\njulia> obj = brain_phantom2D(; tissue_properties=phantom_values)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom3D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom3D","text":"obj = brain_phantom3D(; ss=4, us=1, start_end=[160,200])\n\nCreates a three-dimentional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm. \n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 3 element vector [ssx, ssy, ssz]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 3 element vector [usx, usy, usz]\nstart_end: (::Vector{Integer}, =[160,200]) z index range of presampled phantom, 180 is center\ntissue_properties: (::Dict, =Dict()) phantom tissue properties in SI units considering the available tissues\n\nReturns\n\nobj: (::Phantom) 3D Phantom struct\n\nExamples\n\njulia> obj = brain_phantom3D(; ss=5)\n\njulia> obj = brain_phantom3D(; us=[2, 2, 1])\n\njulia> phantom_values = \n    Dict(\n        # ρ, T1, T2, T2*, Δw\n        \"CSF\"           => [1,      2.569,  0.329,  0.058,  0],\n        \"GM\"            => [0.86,   0.833,  0.083,  0.069,  0],\n        \"WM\"            => [0.77,   0.500,  0.070,  0.061,  0],\n        \"FAT1\"          => [0,      0,      0,      0,      0],\n        \"MUSCLE\"        => [0,      0,      0,      0,      0],\n        \"SKIN/MUSCLE\"   => [0,      0,      0,      0,      0],\n        \"SKULL\"         => [0,      0,      0,      0,      0],\n        \"VESSELS\"       => [0,      0,      0,      0,      0],\n        \"FAT2\"          => [0,      0,      0,      0,      0],\n        \"DURA\"          => [0,      0,      0,      0,      0],\n        \"MARROW\"        => [0,      0,      0,      0,      0])\njulia> obj = brain_phantom3D(; tissue_properties=phantom_values)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.pelvis_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.pelvis_phantom2D","text":"obj = pelvis_phantom2D(; ss=4, us=1)\n\nCreates a two-dimensional pelvis Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy]\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = pelvis_phantom2D(; ss=2])\n\njulia> obj = pelvis_phantom2D(; us=[1, 2])\n\njulia> pelvis_phantom2D(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.heart_phantom","page":"KomaMRIBase","title":"KomaMRIBase.heart_phantom","text":"obj = heart_phantom(\n    circumferential_strain, radial_strain, rotation_angle; \n    heart_rate, asymmetry\n)\n\nHeart-like LV 2D phantom. The variable circumferential_strain and radial_strain are for streching (if positive)  or contraction (if negative). rotation_angle is for rotation.\n\nKeywords\n\ncircumferential_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nradial_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nrotation_angle: (::Real, =15.0, [º]) maximum rotation angle\nheart_rate: (::Real, =60, [bpm]) heartbeat frequency\ntemporal_asymmetry: (::Real, =0.2) time fraction of the period in which the systole occurs. Therefore, diastole lasts for period * (1 - temporal_asymmetry)\n\nReturns\n\nobj: (::Phantom) Heart-like LV phantom struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Motion-related-functions","page":"KomaMRIBase","title":"Motion-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.NoMotion","page":"KomaMRIBase","title":"KomaMRIBase.NoMotion","text":"nomotion = NoMotion()\n\nNoMotion struct. It is used to create static phantoms.\n\nReturns\n\nnomotion: (::NoMotion) NoMotion struct\n\nExamples\n\njulia> nomotion = NoMotion()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Motion","page":"KomaMRIBase","title":"KomaMRIBase.Motion","text":"motion = Motion(action)\nmotion = Motion(action, time)\nmotion = Motion(action, time, spins)\n\nMotion struct. It defines the motion, during a certain time interval, of a given group of spins. It is composed by three fields: action, which  defines the motion itself, time, which accounts for the time during which the motion takes place, and spins, which indicates the spins  that are affected by that motion.\n\nArguments\n\naction: (::AbstractAction{T<:Real}) action, such as Translate or Rotate\ntime: (::TimeCurve{T<:Real}, =TimeRange(0.0)) time information about the motion\nspins: (::AbstractSpinSpan, =AllSpins()) spin indexes affected by the motion\n\nReturns\n\nmotion: (::Motion) Motion struct\n\nExamples\n\njulia> motion =  Motion(\n            action = Translate(0.01, 0.0, 0.02),\n            time = TimeRange(0.0, 1.0),\n            spins = SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.MotionList","page":"KomaMRIBase","title":"KomaMRIBase.MotionList","text":"motionlist = MotionList(motions...)\n\nMotionList struct. The other option, instead of NoMotion,  is to define a dynamic phantom by means of the MotionList struct. It is composed by one or more Motion instances. \n\nArguments\n\nmotions: (::Vector{Motion{T<:Real}}) vector of Motion instances\n\nReturns\n\nmotionlist: (::MotionList) MotionList struct\n\nExamples\n\njulia>  motionlist = MotionList(\n            Motion(\n                action = Translate(0.01, 0.0, 0.02),\n                time = TimeRange(0.0, 1.0),\n                spins = AllSpins()\n            ),\n            Motion(\n                action = Rotate(0.0, 0.0, 45.0),\n                time = Periodic(1.0),\n                spins = SpinRange(1:10)\n            )\n        )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_spin_coords","page":"KomaMRIBase","title":"KomaMRIBase.get_spin_coords","text":"x, y, z = get_spin_coords(motion, x, y, z, t)\n\n\n\n\n\nx, y, z = get_spin_coords(motionset, x, y, z, t)\n\nCalculates the position of each spin at a set of arbitrary time instants, i.e. the time steps of the simulation.  For each dimension (x, y, z), the output matrix has N_\tspins rows and length(t) columns.\n\nArguments\n\nmotion: (::Union{NoMotion, MotionList{T<:Real}}) phantom motion\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nt: horizontal array of time instants\n\nReturns\n\nx, y, z: (::Tuple{AbstractArray, AbstractArray, AbstractArray}) spin positions over time\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#AbstractAction-types","page":"KomaMRIBase","title":"AbstractAction types","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Translate","page":"KomaMRIBase","title":"KomaMRIBase.Translate","text":"translate = Translate(dx, dy, dz)\n\nTranslate struct. It produces a linear translation. Its fields are the final displacements in the three axes (dx, dy, dz).\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\n\nReturns\n\ntranslate: (::Translate) Translate struct\n\nExamples\n\njulia> translate = Translate(dx=0.01, dy=0.02, dz=0.03)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Translate-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Translate","text":"translate = Translate(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\ntranslate: (::Motion) Motion struct\n\nExamples\n\njulia> translate = Translate(0.01, 0.02, 0.03, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.Rotate","page":"KomaMRIBase","title":"KomaMRIBase.Rotate","text":"rotate = Rotate(pitch, roll, yaw)\n\nRotate struct. It produces a rotation in the three axes:  x (pitch), y (roll), and z (yaw). We follow the RAS (Right-Anterior-Superior) orientation,  and the rotations are applied following the right-hand rule (counter-clockwise):\n\n(Image: Head Rotation Axis)\n\nThe applied rotation matrix is obtained as follows: \n\nbeginequation\nbeginaligned\nR = R_z(alpha) R_y(beta) R_x(gamma) \n  = beginbmatrix\ncos alpha  -sin alpha  0 \nsin alpha  cos alpha  0 \n0  0  1\nendbmatrix\nbeginbmatrix\ncos beta  0  sin beta \n0  1  0 \n-sin beta  0  cos beta\nendbmatrix\nbeginbmatrix\n1  0  0 \n0  cos gamma  -sin gamma \n0  sin gamma  cos gamma\nendbmatrix \n  = beginbmatrix\ncos alpha cos beta  cos alpha sin beta sin gamma - sin alpha cos gamma  cos alpha sin beta cos gamma + sin alpha sin gamma \nsin alpha cos beta  sin alpha sin beta sin gamma + cos alpha cos gamma  sin alpha sin beta cos gamma - cos alpha sin gamma \n-sin beta  cos beta sin gamma  cos beta cos gamma\nendbmatrix\nendaligned\nendequation\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\n\nReturns\n\nrotate: (::Rotate) Rotate struct\n\nExamples\n\njulia> rotate = Rotate(pitch=15.0, roll=0.0, yaw=20.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Rotate-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Rotate","text":"rotate = Rotate(pitch, roll, yaw, spins)\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nrotate: (::Motion) Motion struct with Rotate action\n\nExamples\n\njulia> rotate = Rotate(15.0, 0.0, 20.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.HeartBeat","page":"KomaMRIBase","title":"KomaMRIBase.HeartBeat","text":"heartbeat = HeartBeat(circumferential_strain, radial_strain, longitudinal_strain)\n\nHeartBeat struct. It produces a heartbeat-like motion, characterised by three types of strain: circumferential, radial and longitudinal\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\n\nReturns\n\nheartbeat: (::HeartBeat) HeartBeat struct\n\nExamples\n\njulia> heartbeat = HeartBeat(circumferential_strain=-0.3, radial_strain=-0.2, longitudinal_strain=0.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.HeartBeat-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.HeartBeat","text":"heartbeat = HeartBeat(circumferential_strain, radial_strain, longitudinal_strainl, time, spins)\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nheartbeat: (::Motion) Motion struct with HeartBeat action\n\nExamples\n\njulia> heartbeat = HeartBeat(-0.3, -0.2, 0.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.Path","page":"KomaMRIBase","title":"KomaMRIBase.Path","text":"path = Path(dx, dy, dz)\n\nPath struct. For this action (and for FlowPath), motion is not defined solely on the basis of  three numerical parameters, one for each spatial direction, as occurs for the Translate, Rotate and HeartBeat actions.\n\nFor this action, it is necessary to define  motion for each spin independently, in x (dx), y (dy) and z (dz). dx, dy and dz are now three matrixes, of (N_spins* times  N_discretetimes) each. This means that each row corresponds to a spin trajectory over a set of discrete time instants.\n\nnote: Note\n*When creating a motion with Flow or FlowPath, you must make sure that  the number of rows of the matrices dx, dy and dz matches the number  of spins that are affected by the motion. Remember that the range of spins affected by a motion  is defined by the spins field of the Motion structexample:julia> motion = Motion(\n    action = Path(\n        dx=[0.01 0.02; 0.02 0.03],  # 2 rows\n        dy=[0.02 0.03; 0.03 0.04], \n        dz=[0.03 0.04; 0.04 0.05]),\n    time = TimeRange(0.0, 1.0),\n    spins = SpinRange(1:2)          # 2 spins\n)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\n\nReturns\n\npath: (::Path) Path struct\n\nExamples\n\njulia> path = Path(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 0.05]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Path-NTuple{5, Any}","page":"KomaMRIBase","title":"KomaMRIBase.Path","text":"path = Path(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\npath: (::Motion) Motion struct with Path action\n\nExamples\n\njulia> path = Path(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.FlowPath","page":"KomaMRIBase","title":"KomaMRIBase.FlowPath","text":"flowpath = FlowPath(dx, dy, dz, spin_reset)\n\nFlowPath struct. This action is the same as Path,  except that it includes an additional field, called spin_reset,  which accounts for spins leaving the volume and being remapped  to another input position. When this happens, the magnetization  state of these spins must be reset during the simulation. \n\nAs with the dx, dy and dz matrices, spin_reset has a size of (N_spins times  N_discretetimes).\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\n\nReturns\n\nflowpath: (::FlowPath) FlowPath struct\n\nExamples\n\njulia> flowpath = FlowPath(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 -0.04],\n           spin_reset=[false false; false true]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.FlowPath-NTuple{6, Any}","page":"KomaMRIBase","title":"KomaMRIBase.FlowPath","text":"flowpath = FlowPath(dx, dy, dz, spin_reset, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nflowpath: (::Motion) Motion struct with FlowPath action\n\nExamples\n\njulia> flowpath = FlowPath(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          [false false; false true],\n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#TimeCurve-types-and-related-functions","page":"KomaMRIBase","title":"TimeCurve types and related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.TimeCurve","page":"KomaMRIBase","title":"KomaMRIBase.TimeCurve","text":"timecurve = TimeCurve(t, t_unit, periodic, periods)\n\nTimeCurve struct. It is a specialized type that defines a time curve, which represents  the temporal behavior of motion. This curve is defined by two vectors:  t and t_unit, which represent the horizontal (x-axis) and vertical (y-axis) axes  of the curve, respectively. To some extent, this curve can be associated with animation curves, commonly found in software for video editing, 3D scene creation, or video game development.\n\nAdditionally, the TimeCurve struct contains two more fields, independent of each other: periodic is a Boolean that indicates whether the time curve should be repeated periodically. periods contains as many elements as repetitions are desired in the time curve.  Each element specifies the scaling factor for that repetition.\n\nArguments\n\nt: (::AbstractVector{<:Real}, [s]) time vector\nt_unit: (::AbstractVector{<:Real}) y vector, it needs to be scaled between 0 and 1. 0    represents the start of the motion, while 1 represents the end.    The values in between represent the intermediate states of the motion.\nperiodic: (::Bool, =false) indicates whether the time curve should be periodically repeated\nperiods: (::Union{<:Real,AbstractVector{<:Real}}, =1.0): represents the relative duration    of each period with respect to the baseline duration defined by t[end] - t[1].    In other words, it acts as a scaling factor to lengthen or shorten specific periods.    This allows for the creation of patterns such as arrhythmias or other variations in periodicity.\n\nReturns\n\ntimecurve: (::TimeCurve) TimeCurve struct\n\nExamples\n\n1. Non-periodic motion with a single repetition: \n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 0.2, 0.5, 1.0])\n\n(Image: Time Curve 1)\n\n2. Periodic motion with a single repetition:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periodic=true)\n\n(Image: Time Curve 2)\n\n3. Non-periodic motion with multiple repetitions:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5])\n\n(Image: Time Curve 3)\n\n4. Periodic motion with multiple repetitions:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5], periodic=true)\n\n(Image: Time Curve 4)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.TimeRange","page":"KomaMRIBase","title":"KomaMRIBase.TimeRange","text":"timerange = TimeRange(t_start, t_end)\n\nThe TimeRange function is a custom constructor for the TimeCurve struct.  It allows defining a simple time interval, with start and end times.\n\nArguments\n\nt_start: (::Real, [s], =0.0) start time\nt_end: (::Real, [s], =1.0) end time\n\nReturns\n\ntimerange: (::TimeCurve) TimeCurve struct\n\nExamples\n\njulia> timerange = TimeRange(t_start=0.6, t_end=1.4)\n\n(Image: Time Range)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.Periodic","page":"KomaMRIBase","title":"KomaMRIBase.Periodic","text":"periodic = Periodic(period, asymmetry)\n\nThe Periodic function is a custom constructor for the TimeCurve struct. It allows defining time intervals that repeat periodically with a triangular period.  It includes a measure of asymmetry in order to recreate a asymmetric period.\n\nArguments\n\nperiod: (::Real, [s], =1.0) period duration\nasymmetry: (::Real, =0.5) temporal asymmetry factor. Between 0 and 1.\n\nReturns\n\nperiodic: (::TimeCurve) TimeCurve struct\n\nExamples\n\njulia> periodic = Periodic(period=1.0, asymmetry=0.2)\n\n(Image: Periodic)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#AbstractSpinSpan-types","page":"KomaMRIBase","title":"AbstractSpinSpan types","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.AllSpins","page":"KomaMRIBase","title":"KomaMRIBase.AllSpins","text":"allspins = AllSpins()\n\nAllSpins struct. It is a specialized type that inherits from AbstractSpinSpan and is used to cover all the spins of a phantom.\n\nReturns\n\nallspins: (::AllSpins) AllSpins struct\n\nExamples\n\njulia> allspins = AllSpins()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.SpinRange","page":"KomaMRIBase","title":"KomaMRIBase.SpinRange","text":"spinrange = SpinRange(range)\n\nSpinRange struct. It is a specialized type that inherits from AbstractSpinSpan and is used to select a certain range and number of spins.\n\nArguments\n\nrange: (::AbstractVector) spin id's. This argument can be a Range, a Vector or a BitVector\n\nReturns\n\nspinrange: (::SpinRange) SpinRange struct\n\nExamples\n\njulia> spinrange = SpinRange(1:10)\njulia> spinrange = SpinRange([1, 3, 5, 7])\njulia> spinrange = SpinRange(obj.x .> 0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Sequence-related-functions","page":"KomaMRIBase","title":"Sequence-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Sequence","page":"KomaMRIBase","title":"KomaMRIBase.Sequence","text":"seq = Sequence()\nseq = Sequence(GR)\nseq = Sequence(GR, RF)\nseq = Sequence(GR, RF, ADC)\nseq = Sequence(GR, RF, ADC, DUR)\nseq = Sequence(GR::Array{Grad,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)\n\nThe Sequence struct. It contains events of an MRI sequence. Most field names (except for the DEF field) consist of matrices or vectors, where each column index represents a sequence block. This struct serves as an input for the simulation.\n\nArguments\n\nGR: (::Matrix{Grad}) gradient matrix. Rows for x-y-z amplitudes and columns are for blocks\nRF: (::Matrix{RF}) RF matrix. The 1 row is for the coil and columns are for blocks\nADC: (::Array{ADC,1}) ADC block vector\nDUR: (::Vector, [s]) duration block vector\nDEF: (::Dict{String, Any}) dictionary with relevant information of the sequence.   Possible keys could be [\"AdcRasterTime\", \"GradientRasterTime\", \"Name\", \"Nz\",   \"Num_Blocks\", \"Nx\", \"Ny\", \"PulseqVersion\", \"BlockDurationRaster\",   \"FileName\", \"RadiofrequencyRasterTime\"]\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.dur","page":"KomaMRIBase","title":"KomaMRIBase.dur","text":"y = dur(x::Grad)\ny = dur(x::Vector{Grad})\ny = dur(x::Matrix{Grad})\n\nDuration time in [s] of Grad struct or Grad Array.\n\nArguments\n\nx: (::Grad or ::Vector{Grad} or ::Matrix{Grad}) Grad struct or Grad Array\n\nReturns\n\ny: (::Float64, [s]) duration of the Grad struct or Grad Array\n\n\n\n\n\ny = dur(x::RF)\ny = dur(x::Vector{RF})\ny = dur(x::Matrix{RF})\n\nDuration time in [s] of RF struct or RF Array.\n\nArguments\n\nx: (::RF or ::Vector{RF} or ::Matrix{RF}) RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) duration of the RF struct or RF array\n\n\n\n\n\nT = dur(x::Sequence)\n\nThe total duration of the sequence in [s].\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\nT: (::Real, [s]) total duration of the sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_block_start_times","page":"KomaMRIBase","title":"KomaMRIBase.get_block_start_times","text":"T0 = get_block_start_times(seq::Sequence)\n\nReturns a vector containing the start times of blocks in a sequence. The initial time is always zero, and the final time corresponds to the duration of the sequence.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nReturns\n\nT0: (::Vector, [s]) start times of the blocks in a sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angles","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angles","text":"y = get_flip_angles(x::Sequence)\n\nReturns all the flip angles of the RF pulses in the sequence x.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Vector{Float64}, [deg]) flip angles\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Grad","page":"KomaMRIBase","title":"Grad","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(A, T)\ngr = Grad(A, T, rise)\ngr = Grad(A, T, rise, delay)\ngr = Grad(A, T, rise, fall, delay)\ngr = Grad(A, T, rise, fall, delay, first, last)\n\nThe Grad struct represents a gradient of a sequence event.\n\nArguments\n\nA: (::Real or ::Vector, [T/m]) amplitude of the gradient\nT: (::Real or ::Vector, [s]) duration of the flat-top\nrise: (::Real, [s]) duration of the rise\nfall: (::Real, [s]) duration of the fall\ndelay: (::Real, [s]) duration of the delay\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gr = Grad(1, 1, 0.1, 0.1, 0.2)\n\njulia> seq = Sequence([gr]); plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(f::Function, T::Real, N::Integer; delay::Real)\n\nGenerates an arbitrary gradient waveform defined by the function f in the interval t ∈ [0,T]. The time separation between two consecutive samples is given by T/(N-1).\n\nArguments\n\nf: (::Function) function that describes the gradient waveform\nT: (::Real, [s]) duration of the gradient waveform\nN: (::Integer, =300) number of samples of the gradient waveform\n\nKeywords\n\ndelay: (::Real, =0, [s]) delay time of the waveform\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gx = Grad(t -> sin(π*t / 0.8), 0.8)\n\njulia> seq = Sequence([gx]); plot_seq(seq)\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#RF","page":"KomaMRIBase","title":"RF","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.RF","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF(A, T)\nrf = RF(A, T, Δf)\nrf = RF(A, T, Δf, delay)\n\nThe RF struct represents a Radio Frequency excitation of a sequence event.\n\nArguments\n\nA: (::Complex, [T]) RF complex amplitud modulation (AM), B_1(t) = B_1(t)   e^iphi(t) = B_1(t) + iB_1y(t)\nT: (::Real, [s]) RF duration\nΔf: (::Real or ::Vector, [Hz]) RF frequency difference with respect to the Larmor frequency.   This can be a number but also a vector to represent frequency modulated signals (FM).\ndelay: (::Real, [s]) RF delay time\n\nReturns\n\nrf: (::RF) the RF struct\n\nExamples\n\njulia> rf = RF(1, 1, 0, 0.2)\n\njulia> seq = Sequence(); seq += rf; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.RF-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF_fun(f::Function, T::Real, N::Int64)\n\nGenerate an RF sequence with amplitudes sampled from a function waveform.\n\nnote: Note\nThis function is not being used in this KomaMRI version.\n\nArguments\n\nf: (::Function, [T]) function for the RF amplitud waveform\nT: (::Real, [s]) duration of the RF pulse\nN: (::Int64) number of samples of the RF pulse\n\nReturns\n\nrf:(::RF) RF struct with amplitud defined by the function f\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angle","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angle","text":"α = get_flip_angle(x::RF)\n\nCalculates the flip angle α [deg] of an RF struct. α = γ ∫ B1(τ) dτ\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nα: (::Int64, [deg]) flip angle RF struct x\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#ADC","page":"KomaMRIBase","title":"ADC","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.ADC","page":"KomaMRIBase","title":"KomaMRIBase.ADC","text":"adc = ADC(N, T)\nadc = ADC(N, T, delay)\nadc = ADC(N, T, delay, Δf, ϕ)\n\nThe ADC struct represents the Analog to Digital Converter (ADC) of a sequence event.\n\nArguments\n\nN: (::Int64) number of acquired samples\nT: (::Float64, [s]) duration to acquire the samples\ndelay: (::Float64, [s]) delay time to start the acquisition\nΔf: (::Float64, [Hz]) delta frequency. It is meant to compensate RF pulse phases\nϕ: (::Float64, [rad]) phase. It is meant to compensate RF pulse phases\n\nReturns\n\nadc: (::ADC) ADC struct\n\nExamples\n\njulia> adc = ADC(16, 1, 0.1)\n\njulia> seq = Sequence(); seq += adc; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_sampling_times","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_sampling_times","text":"times = get_adc_sampling_times(seq)\n\nReturns an array of times when the samples of the sequence seq are acquired.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ntimes: (::Vector{Float64}, [s]) time array when samples are acquired\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_phase_compensation","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_phase_compensation","text":"comp = get_adc_phase_compensation(seq)\n\nReturns an array of phase compensation factors, exp(-mathrmivarphi), which are used to compensate the acquired signal S by applying the operation S_mathrmcomp = S exp(-mathrmivarphi) after the simulation. This compensation is necessary because the signal typically exhibits a phase offset of varphi following RF excitation with a phase of varphi. Such pulses are commonly employed in sequences involving RF spoiling.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ncomp: (::Vector{Complex}, [rad]) array of phase compensations for every acquired sample\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Delay","page":"KomaMRIBase","title":"Delay","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Delay","page":"KomaMRIBase","title":"KomaMRIBase.Delay","text":"delay = Delay(T)\n\nThe Delay struct is meant to add a delay to a sequence by using a sum operator.\n\nArguments\n\nT: (::Real, [s]) time delay value\n\nReturns\n\ndelay: (::Delay) delay struct\n\nExamples\n\njulia> delay = Delay(0.5)\n\njulia> s = Sequence([Grad(1, 1, 0.1)])\n\njulia> seq = delay + s; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#Rotation-matrices","page":"KomaMRIBase","title":"Rotation matrices","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.rotx","page":"KomaMRIBase","title":"KomaMRIBase.rotx","text":"Rx = rotx(θ::Real)\n\nRotates vector counter-clockwise with respect to the x-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRx: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.roty","page":"KomaMRIBase","title":"KomaMRIBase.roty","text":"Ry = roty(θ::Real)\n\nRotates vector counter-clockwise with respect to the y-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRy: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.rotz","page":"KomaMRIBase","title":"KomaMRIBase.rotz","text":"Rz = rotz(θ::Real)\n\nRotates vector counter-clockwise with respect to the z-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRz: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Moments","page":"KomaMRIBase","title":"Moments","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.get_Mk","page":"KomaMRIBase","title":"KomaMRIBase.get_Mk","text":"Mk, Mk_adc = get_Mk(seq::Sequence, k; Δt=1, skip_rf=zeros(Bool, sum(is_RF_on.(seq))))\n\nComputes the kth-order moment of the Sequence seq given by the formula int_0^T t^k G(t) dt.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nk: (::Integer) order of the moment to be computed\nΔt: (::Real, =1, [s]) nominal delta time separation between two time samples   for ADC acquisition and Gradients\nskip_rf: (::Vector{Bool}, =zeros(Bool, sum(is_RF_on.(seq)))) boolean vector which   indicates whether to skip the computation for resetting the integral for excitation or   refocusing RF type\n\nReturns\n\nMk: (3-column ::Matrix{Real}) kth-order moment\nMk_adc: (3-column ::Matrix{Real}) kth-order moment sampled at ADC times\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_kspace","page":"KomaMRIBase","title":"KomaMRIBase.get_kspace","text":"Computes the k-space trajectory of the Sequence seq. Refer to get_Mk and get_M0\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M0","page":"KomaMRIBase","title":"KomaMRIBase.get_M0","text":"Computes the zero-order moment of the Sequence seq. Refer to get_Mk and get_kspace\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M1","page":"KomaMRIBase","title":"KomaMRIBase.get_M1","text":"Computes the 1st-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M2","page":"KomaMRIBase","title":"KomaMRIBase.get_M2","text":"Computes the 2nd-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Event-checks","page":"KomaMRIBase","title":"Event checks","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.is_RF_on","page":"KomaMRIBase","title":"KomaMRIBase.is_RF_on","text":"y = is_RF_on(x::Sequence)\ny = is_RF_on(x::Sequence, t::Vector{Float64})\n\nTells if the sequence seq has elements with RF active, or active during time t.\n\nArguments\n\nx: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the RF in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_GR_on","page":"KomaMRIBase","title":"KomaMRIBase.is_GR_on","text":"y = is_GR_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GR in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gx_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gx_on","text":"y = is_Gx_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in x direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRx in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gy_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gy_on","text":"y = is_Gy_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in y direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRy in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gz_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gz_on","text":"y = is_Gz_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in z direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRz in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_ADC_on","page":"KomaMRIBase","title":"KomaMRIBase.is_ADC_on","text":"y = is_ADC_on(x::Sequence)\ny = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})\n\nTells if the sequence seq has elements with ADC active, or active during time t.\n\nArguments\n\nx: (::Sequence) sequence struct\nt: (::Union{Array{Float64,1}, Array{Float64,2}}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the ADC in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#DiscreteSequence","page":"KomaMRIBase","title":"DiscreteSequence","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.DiscreteSequence","page":"KomaMRIBase","title":"KomaMRIBase.DiscreteSequence","text":"seqd = DiscreteSequence(Gx, Gy, Gz, B1, Δf, ADC, t, Δt)\n\nA sampled version of a Sequence struct, containing vectors for event amplitudes at specified times. DiscreteSequence is the struct used for simulation.\n\nArguments\n\nGx: (::AbstractVector{T<:Real}, [T/m]) x-gradient vector\nGy: (::AbstractVector{T<:Real}, [T/m]) y-gradient vector\nGz: (::AbstractVector{T<:Real}, [T/m]) z-gradient vector\nB1: (::AbstractVector{Complex{T<:Real}}, [T]) RF amplitude vector\nΔf: (::AbstractVector{T<:Real}, [Hz]) RF carrier frequency displacement vector\nADC: (::AbstractVector{Bool}) ADC sample vector\nt: (::AbstractVector{T<:Real}, [s]) time vector\nΔt: (::AbstractVector{T<:Real}, [s]) delta time vector\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.discretize","page":"KomaMRIBase","title":"KomaMRIBase.discretize","text":"seqd = discretize(seq::Sequence; sampling_params=default_sampling_params())\n\nThis function returns a sampled Sequence struct with RF and gradient time refinements based on simulation parameters.\n\nArguments\n\nseq: (::Sequence) sequence\n\nKeywords\n\nsampling_params: (::Dict{String, Any}, =default_sampling_params()) sampling   parameter dictionary\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_samples","page":"KomaMRIBase","title":"KomaMRIBase.get_samples","text":"samples = get_samples(seq::Sequence; off_val=0, max_rf_samples=Inf)\n\nReturns the samples of the events in seq.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\noff_val: (::Number, =0) offset value for amplitude. Typically used to hide points in   plots by setting it to Inf\nmax_rf_samples: (::Integer, =Inf) maximum number of samples for the RF struct\n\nReturns\n\nsamples: (::NamedTuple) contains samples for gx, gy, gz, rf, and adc events.   Each event, represented by e::NamedTuple, includes time samples (e.t) and amplitude   samples (e.A)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.times","page":"KomaMRIBase","title":"KomaMRIBase.times","text":"t = times(gr::Grad)\nt = times(rf::RF)\nt = times(adc::ADC)\n\nGet time samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nt: (::Vector{Number}) vector with time samples\n\n\n\n\n\ntimes = times(motion)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.ampls","page":"KomaMRIBase","title":"KomaMRIBase.ampls","text":"A = ampls(g::Grad)\nA = ampls(r::RF)\nA = ampls(d::ADC)\n\nGet amplitude samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nA: (::Vector{Number}) vector with amplitude samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.freqs","page":"KomaMRIBase","title":"KomaMRIBase.freqs","text":"f = freqs(r::RF)\n\nGet frequency samples of MRI sequence event.\n\nArguments\n\nrf: (::RF) RF struct\n\nReturns\n\nf: (::Vector{Number}) vector with frequency samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Other-functions","page":"KomaMRIBase","title":"Other functions","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.trapz","page":"KomaMRIBase","title":"KomaMRIBase.trapz","text":"y = trapz(Δt, x)\n\nTrapezoidal integration for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Δt for all the spins. NΔt is the length of Δt. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x 1 ::Matrix{Float64}, [T*s]) vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.cumtrapz","page":"KomaMRIBase","title":"KomaMRIBase.cumtrapz","text":"y = cumtrapz(Δt, x)\n\nTrapezoidal cumulative integration over time for every spin of a phantom.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x NΔt ::Matrix{Float64}, [T*s]) matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a   phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.kfoldperm","page":"KomaMRIBase","title":"KomaMRIBase.kfoldperm","text":"array_of_ranges = kfoldperm(N, k; breaks=[])\n\nDivides a list of indices from 1 to N into k groups.\n\nArguments\n\nN: (::Integer) number of elements to be ordered\nk: (::Integer) number of groups to divide the N elements.\n\nKeywords\n\nbreaks: (::Vector{<:Integer}, =[]) array of indices where predefined breakpoints are   placed.\n\nReturns\n\narray_of_ranges: (::Vector{UnitRange{<:Integer}}) array containing ranges of different   groups. The target is k groups, but this could increase by adding elements to the   breaks input array\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#Sequence-Building-Blocks-(SBB)","page":"KomaMRIBase","title":"Sequence Building Blocks (SBB)","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner","text":"PulseDesigner\n\nA module to define different pulse sequences.\n\n\n\n\n\n","category":"module"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_hard","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_hard","text":"seq = RF_hard(B1, T, sys; G=[0, 0, 0], Δf=0)\n\nReturns a sequence with a RF excitation pulse.\n\nArguments\n\nB1: (::Number, [T]) RF pulse amplitude\nT: (::Real, [s]) RF pulse duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_hard(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_sinc","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_sinc","text":"seq = RF_sinc(B1, T, sys; G=[0, 0, 0], Δf=0, a=0.46, TBP=4)\n\nReturns a sequence with a RF sinc waveform.\n\nReferences\n\nMatt A. Bernstein, Kevin F. King, Xiaohong Joe Zhou, Chapter 2 - Radiofrequency Pulse\n\nShapes, Handbook of MRI Pulse Sequences, 2004, Pages 35-66, https://doi.org/10.1016/B978-012092861-3/50006-6.\n\nArguments\n\nB1: (::Number, [T]) RF sinc amplitude\nT: (::Real, [s]) RF sinc duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\na: (::Real, =0.46) height appodization window parameter\nTBP: (::Real, =4) width appodization window parameter\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_sinc(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI","text":"seq = EPI(FOV::Real, N::Integer, sys::Scanner)\n\nReturns a sequence with EPI gradients.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels in the x and y axis\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct with EPI gradients\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.EPI(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.radial_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.radial_base","text":"seq = radial_base(FOV::Real, Nr::Integer, sys::Scanner)\n\nReturns a sequence with radial gradients for a single trajectory.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the diameter\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct of a single radial trajectory\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.radial_base(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.spiral_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.spiral_base","text":"spiral = spiral_base(FOV, N, sys; S0=sys.Smax*2/3, Nint=8, λ=Nint/FOV, BW=60e3)\n\nDefinition of a spiral base sequence.\n\nReferences\n\nGlover, G.H. (1999), Simple analytic spiral K-space algorithm. Magn. Reson. Med.,\n\n42: 412-415. https://doi.org/10.1002/(SICI)1522-2594(199908)42:2<412::AID-MRM25>3.0.CO;2-U\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the radious\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nS0: (::Vector{Real}, =sys.Smax*2/3, [T/m/s]) slew rate reference\nNint: (::Integer, =8) number of interleaves\nλ: (::Real, =Nint/FOV, [1/m]) kspace spiral parameter\nBW: (::Real, =60e3, [Hz]) adquisition parameter\n\nReturns\n\nspiral: (::Function) function that returns a Sequence struct when evaluated\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> spiral = PulseDesigner.spiral_base(FOV, N, sys)\n\njulia> seq = spiral(0)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI_example","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI_example","text":"seq = EPI_example(; sys=Scanner())\n\nReturns a sequence suitable for acquiring the 2D brain example in the provided examples.\n\nKeywords\n\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) EPI example Sequence struct\n\nExamples\n\njulia> seq = PulseDesigner.EPI_example();\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"🏠 Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"KomaMRI is a Julia package meant to simulate general Magnetic Resonance Imaging (MRI) scenarios. Its name comes from the Japanese word for spinning-top こま (ko-ma) as they precess due to gravity like spins in a magnetic field.","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"KomaMRI generates raw data by solving the Bloch equations using the specified scanner, phantom and sequence. It also provides a Graphical User Interface (GUI) that encapsulates the whole imaging pipeline (simulation and reconstruction).","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"<p align=\"center\"><img class=\"docs-light-only\" width=\"100%\" src=\"assets/koma-schema.svg\"/></p>\n<p align=\"center\"><img class=\"docs-dark-only\"  width=\"100%\" src=\"assets/koma-schema-dark.svg\"/></p>","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"We organized the documentation following the philosophy presented by David Laing.","category":"page"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"details: How to Cite Koma\nIf you use Koma, please cite our paper:Plain Text:Castillo-Passi, C, Coronado, R, Varela-Mattatall, G, Alberola-López, C, Botnar, R, Irarrazaval, P. KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration. Magn Reson Med. 2023; 1- 14. doi: 10.1002/mrm.29635BibTex:@article{https://doi.org/10.1002/mrm.29635,\n        author = {Castillo-Passi, Carlos and Coronado, Ronal and Varela-Mattatall, Gabriel and Alberola-López, Carlos and Botnar, René and Irarrazaval, Pablo},\n        title = {KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration},\n        journal = {Magnetic Resonance in Medicine},\n        keywords = {Bloch equations, GPU, GUI, Julia, open source, simulation},\n        doi = {https://doi.org/10.1002/mrm.29635},\n        url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.29635},\n        eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/mrm.29635},\n}","category":"page"},{"location":"#Features","page":"🏠 Home","title":"Features","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"Fast simulations by using CPU and GPU parallelization 🏃💨.\nOpen Source, so anyone can include additional features 🆙.\nCompatibility with community-standards 🤝 like Pulseq .seq and ISMRMRD .mrd.\nCompatibility with Pluto and Jupyter notebooks 🎈\nInteractive visualizations using PlotlyJS.jl 📲\nCross-platform 🌐 thanks to the use of the Julia programming language.\nFriendly user interface for people with no programming skills 😌.\nFlexible API for advanced users 👨‍💻.","category":"page"},{"location":"#Potential-Use-Cases","page":"🏠 Home","title":"Potential Use Cases","text":"","category":"section"},{"location":"","page":"🏠 Home","title":"🏠 Home","text":"The generation of synthetic data to train Machine Learning models.\nTo test novel pulse sequences before implementing them directly in a real scanner (with a Pulseq sequence).\nTeaching exercises for MRI acquisition or reconstruction.","category":"page"},{"location":"reference/1-api/#API-Overview","page":"API Overview","title":"API Overview","text":"","category":"section"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/koma-schema-subdirs.svg\"/></p>","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"KomaMRI is divided into the following sub-packages:","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"KomaMRIBase: Custom types and functions\nKomaMRICore: Simulation functions\nKomaMRIFiles: File I/O functions\nKomaMRIPlots: Plotting functions\nKomaMRI: User Interface","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"The idea of separating the package into sub-packages is to make it easier to maintain and to allow users to use only the parts they need. Two common use-cases can be:","category":"page"},{"location":"reference/1-api/","page":"API Overview","title":"API Overview","text":"GUI users: They will use the KomaMRI package to interact with the GUI. Internally this includes al the others.\nAdvanced users: They will use the sub-packages directly to build their own scripts or notebooks, for simulation only KomaMRICore is required.","category":"page"},{"location":"tutorial/04-3DSliceSelective/#Slice-Selective-Acquisition-of-3D-Phantom","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"","category":"section"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"using KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"While in the previous examples we simulated using hard RF pulses, in this demonstration we will illustrate the principles of slice selection. First, let's import a 3D phantom, in this case a brain slab (thickness of 2mathrmcm), by calling the function brain_phantom3D.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"obj = brain_phantom3D()\nobj.Δw .= 0 # Removes the off-resonance\np1 = plot_phantom_map(obj, :T2 ; height=400)\nsavefig(p1, \"../assets/3-phantom.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-phantom.html\" style=\"width:50%; height:420px;\"></object></center>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Now, we are going to import a sequence which acquires 3 slices in the longitudinal axis. Note that the sequence contains three EPIs to acquire 3 slices of the phantom.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_multislice.seq\")\nseq = read_seq(seq_file)\np2 = plot_seq(seq; range=[0,10], height=400)\nsavefig(p2, \"../assets/3-seq.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"We can take a look to the slice profiles by using the function simulate_slice_profile:","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"z = range(-2., 2., 200) * 1e-2; # -2 to 2 cm\nrf1, rf2, rf3 = findall(is_RF_on.(seq))\nM1 = simulate_slice_profile(seq[rf1]; z)\nM2 = simulate_slice_profile(seq[rf2]; z)\nM3 = simulate_slice_profile(seq[rf3]; z)\n\nusing PlotlyJS # hide\npa = scatter(x=z*1e2, y=abs.(M1.xy), name=\"Slice 1\") # hide\npb = scatter(x=z*1e2, y=abs.(M2.xy), name=\"Slice 2\") # hide\npc = scatter(x=z*1e2, y=abs.(M3.xy), name=\"Slice 3\") # hide\npd = plot([pa,pb,pc], Layout(xaxis=attr(title=\"z [cm]\"), height=300,margin=attr(t=40,l=0,r=0), title=\"Slice profiles for the slice-selective sequence\")) # hide\nsavefig(pd, \"../assets/3-profile.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Now let's simulate the acquisition. Notice the three echoes, one for every slice excitation.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"raw = simulate(obj, seq, sys; sim_params=Dict{String,Any}(\"Nblocks\"=>20))\np3 = plot_signal(raw; slider=false, height=300)\nsavefig(p3, \"../assets/3-signal.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"Finally, we reconstruct the acquiered images.","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\n\n# Setting up the reconstruction parameters and perform reconstruction\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the slices\np4 = plot_image(abs.(image[:, :, 1]); height=360, title=\"Slice 1\")\np5 = plot_image(abs.(image[:, :, 2]); height=360, title=\"Slice 2\")\np6 = plot_image(abs.(image[:, :, 3]); height=360, title=\"Slice 3\")\nsavefig(p4, \"../assets/3-recon1.html\") # hide\nsavefig(p5, \"../assets/3-recon2.html\") # hide\nsavefig(p6, \"../assets/3-recon3.html\") # hide","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-recon1.html\" style=\"width:50%; height:380px;\"></object><object type=\"text/html\" data=\"../../assets/3-recon2.html\" style=\"width:50%; height:380px;\"></object>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-recon3.html\" style=\"width:50%; height:380px;\"></object></center>","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"","category":"page"},{"location":"tutorial/04-3DSliceSelective/","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"This page was generated using Literate.jl.","category":"page"}]
}
