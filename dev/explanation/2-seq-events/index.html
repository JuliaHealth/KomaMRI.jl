<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sequence Events · KomaMRI.jl</title><meta name="title" content="Sequence Events · KomaMRI.jl"/><meta property="og:title" content="Sequence Events · KomaMRI.jl"/><meta property="twitter:title" content="Sequence Events · KomaMRI.jl"/><meta name="description" content="Documentation for KomaMRI.jl."/><meta property="og:description" content="Documentation for KomaMRI.jl."/><meta property="twitter:description" content="Documentation for KomaMRI.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/hide-documenter-example-output.css" rel="stylesheet" type="text/css"/><link href="../../assets/center-images.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="KomaMRI.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="KomaMRI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">🏠 Home</a></li><li><a class="tocitem" href="../../how-to/1-getting-started/">🏃 Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">🏋️ Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/01-FID/">Free Induction Decay</a></li><li><a class="tocitem" href="../../tutorial/02-SmallTipApproximation/">Small Tip Angle Approximation</a></li><li><a class="tocitem" href="../../tutorial/03-ChemicalShiftEPI/">Chemical Shift in an EPI sequence</a></li><li><a class="tocitem" href="../../tutorial/04-3DSliceSelective/">Slice-Selective Acquisition of 3D Phantom</a></li><li><a class="tocitem" href="../../tutorial/05-SimpleMotion/">Patient&#39;s Motion During Acquisition</a></li><li><a class="tocitem" href="../../tutorial/06-DiffusionMotion/">Diffusion-induced Signal Attenuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">🧑‍🔬 Reproducible Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial-pluto/01-gradient-echo-spin-echo/">Understanding basic MRI sequences</a></li><li><a class="tocitem" href="../../tutorial-pluto/02-low-field-cmra-optimization/">Low-Field CMRA Optimization</a></li><li><a class="tocitem" href="../../tutorial-pluto/03-low-field-boost-optimization/">Low-Field BOOST Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">👨‍🍳 How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how-to/2-1-use-koma-ui/">Use Koma&#39;s User Interface</a></li><li><a class="tocitem" href="../../how-to/2-2-use-koma-notebooks/">Use Koma in Notebooks</a></li><li><a class="tocitem" href="../../how-to/2-3-use-koma-scripts/">Use Koma in Julia Scripts</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-phantom/">Create Your Own Phantom</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-sequence/">Create Your Own Sequence</a></li><li><a class="tocitem" href="../../how-to/4-run-distributed-simulations/">Run Distributed Simulations</a></li><li><a class="tocitem" href="../../how-to/5-contribute-to-koma/">Contribute to Koma</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">🤔 Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../1-sequence/">Sequence</a></li><li class="is-active"><a class="tocitem" href>Sequence Events</a><ul class="internal"><li><a class="tocitem" href="#RF"><span>RF</span></a></li><li><a class="tocitem" href="#Gradient"><span>Gradient</span></a></li><li><a class="tocitem" href="#ADC"><span>ADC</span></a></li><li><a class="tocitem" href="#Combination-of-Events"><span>Combination of Events</span></a></li><li><a class="tocitem" href="#Algebraic-manipulation"><span>Algebraic manipulation</span></a></li></ul></li><li><a class="tocitem" href="../3-simulation/">Simulation</a></li><li><a class="tocitem" href="../4-gpu-explanation/">GPU Parallelization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">👨‍💻 Reference Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/1-api/">API Overview</a></li><li><a class="tocitem" href="../../reference/2-koma-base/">KomaMRIBase</a></li><li><a class="tocitem" href="../../reference/3-koma-core/">KomaMRICore</a></li><li><a class="tocitem" href="../../reference/4-koma-files/">KomaMRIFiles</a></li><li><a class="tocitem" href="../../reference/5-koma-plots/">KomaMRIPlots</a></li><li><a class="tocitem" href="../../reference/6-koma-mri/">KomaMRI</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">🤔 Explanations</a></li><li class="is-active"><a href>Sequence Events</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sequence Events</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/master/docs/src/explanation/2-seq-events.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sequence-Events"><a class="docs-heading-anchor" href="#Sequence-Events">Sequence Events</a><a id="Sequence-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence-Events" title="Permalink"></a></h1><p>As we already know, a <strong>Sequence</strong> struct contains field names that store arrays of <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> structs. In the context of <strong>MRI</strong>, we refer to <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> as &quot;events.&quot; To create a <strong>Sequence</strong>, it&#39;s essential to understand how to create these fundamental events.</p><p>In the following subsections, we will provide detailed explanations of event parameters and guide you through the process of creating a <strong>Sequence</strong> using <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> events.</p><h2 id="RF"><a class="docs-heading-anchor" href="#RF">RF</a><a id="RF-1"></a><a class="docs-heading-anchor-permalink" href="#RF" title="Permalink"></a></h2><p>The <strong>RF</strong> struct is defined in the source code of <strong>KomaMRI</strong> as follows:</p><pre><code class="language-julia hljs">mutable struct RF
    A
    T
    Δf
    delay::Real
end</code></pre><p>As you can see, it has 4 field names: &#39;&#39;A&#39;&#39; defines amplitude, &#39;&#39;T&#39;&#39; defines duration time, &#39;&#39;delay&#39;&#39; is the distance between the 0 time and the first waveform sample and &#39;&#39;Δf&#39;&#39; is the displacement respect to the main field carrier frequency (this is for advanced users).</p><p>&#39;&#39;A&#39;&#39; and &#39;&#39;T&#39;&#39; can be numbers or vectors of numbers. Depending on the length of the &#39;&#39;A&#39;&#39; and &#39;&#39;T&#39;&#39;, <strong>KomaMRI</strong> interprets different waveforms: </p><ul><li>Pulse Waveform: A and T are numbers</li><li>Uniformly-Sampled Waveform: A is a vector and T is a number</li><li>Time-Shaped Waveform: A and T are both vectors with the same length (zero-order-hold)</li></ul><p>In the image below, we provide a summary of how you can define <strong>RF</strong> events:</p><p align="center"><img width="100%" src="../../assets/event-shapes-rf-horizontal.svg"/></p><p>Let&#39;s look at some basic examples of creating these <strong>RF</strong> structs and including them in a <strong>Sequence</strong> struct. The examples should be self-explanatory.</p><h3 id="RF-Pulse-Waveform"><a class="docs-heading-anchor" href="#RF-Pulse-Waveform">RF Pulse Waveform</a><a id="RF-Pulse-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Pulse-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A, T, delay =  10e-3, 0.5e-3, 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
←0.1 ms→ RF(10000.0 uT, 0.5 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-pulse-waveform.html" style="width:100%; height:420px;"></object><h3 id="RF-Uniformly-Sampled-Waveform"><a class="docs-heading-anchor" href="#RF-Uniformly-Sampled-Waveform">RF Uniformly-Sampled Waveform</a><a id="RF-Uniformly-Sampled-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Uniformly-Sampled-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; tl = -3:0.2:-0.2; tr = 0.2:0.2:3;

julia&gt; A = (10e-3)*[sin.(π*tl)./(π*tl); 1; sin.(π*tr)./(π*tr)];

julia&gt; T, delay = 0.5e-3, 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
←0.1 ms→ RF(∿ uT, 0.5 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-uniformly-sampled-waveform.html" style="width:100%; height:420px;"></object><h3 id="RF-Time-Shaped-Waveform"><a class="docs-heading-anchor" href="#RF-Time-Shaped-Waveform">RF Time-Shaped Waveform</a><a id="RF-Time-Shaped-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Time-Shaped-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; tl = -4:0.2:-0.2; tr = 0.2:0.2:4

julia&gt; A = (10e-3)*[sin.(π*tl)./(π*tl); 1; 1; sin.(π*tr)./(π*tr)]

julia&gt; T = [0.05e-3*ones(length(tl)); 2e-3; 0.05e-3*ones(length(tl))]

julia&gt; delay = 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
←0.1 ms→ RF(∿ uT, 4.0 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ τ = 4.1 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-time-shaped-waveform.html" style="width:100%; height:420px;"></object><h2 id="Gradient"><a class="docs-heading-anchor" href="#Gradient">Gradient</a><a id="Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient" title="Permalink"></a></h2><p>The <strong>Grad</strong> struct is defined as follows in the source code of <strong>KomaMRI</strong>:</p><pre><code class="language-julia hljs">mutable struct Grad
    A
    T
    rise::Real
    fall::Real
    delay::Real
end</code></pre><p>As you can see, it has 5 field names: &#39;&#39;A&#39;&#39; defines amplitude, &#39;&#39;T&#39;&#39; defines duration time, &#39;&#39;delay&#39;&#39; is the distance between the 0 time and the first waveform sample, &#39;&#39;rise&#39;&#39; and &#39;&#39;fall&#39;&#39; are the time durations of the first and last gradient ramps.</p><p>Just like the <strong>RF</strong>, &#39;&#39;A&#39;&#39; and &#39;&#39;T&#39;&#39; in the <strong>Grad</strong> struct can be numbers or vectors of numbers. Depending on the length of the &#39;&#39;A&#39;&#39; and &#39;&#39;T&#39;&#39;, <strong>KomaMRI</strong> interprets different waveforms: </p><ul><li>Trapezoidal Waveform: A and T are numbers</li><li>Uniformly-Sampled Waveform: A is a vector and T is a number</li><li>Time-Shaped Waveform: A and T are both vectors, A has one sample more the T (linear interpolation)</li></ul><p>In the image below, we provide a summary of how you can define <strong>Grad</strong> events:</p><p align="center"><img width="100%" src="../../assets/event-shapes-gr-horizontal.svg"/></p><p>Let&#39;s look at some basic examples of creating these <strong>Grad</strong> structs and including them in a <strong>Sequence</strong> struct, focusing on the &#39;&#39;x&#39;&#39; component of the gradients. The examples should be self-explanatory.</p><h3 id="Gradient-Trapezoidal-Waveform"><a class="docs-heading-anchor" href="#Gradient-Trapezoidal-Waveform">Gradient Trapezoidal Waveform</a><a id="Gradient-Trapezoidal-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Trapezoidal-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A, T, delay, rise, fall = 50*10e-6, 5e-3, 2e-3, 1e-3, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
←2.0 ms→ Grad(0.5 mT, 0.5 ms, ↑1.0 ms, ↓1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ τ = 9.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-trapezoidal-waveform.html" style="width:100%; height:420px;"></object><h3 id="Gradient-Uniformly-Sampled-Waveform"><a class="docs-heading-anchor" href="#Gradient-Uniformly-Sampled-Waveform">Gradient Uniformly-Sampled Waveform</a><a id="Gradient-Uniformly-Sampled-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Uniformly-Sampled-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; t = 0:0.25:7.5

julia&gt; A = 10*10e-6 * sqrt.(π*t) .* sin.(π*t)

julia&gt; T = 10e-3;

julia&gt; delay, rise, fall = 1e-3, 0, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
←1.0 ms→ Grad(∿ mT, 10.0 ms, ↑0.0 ms, ↓1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ τ = 12.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-uniformly-sampled-waveform.html" style="width:100%; height:420px;"></object><h3 id="Gradient-Time-Shaped-Waveform"><a class="docs-heading-anchor" href="#Gradient-Time-Shaped-Waveform">Gradient Time-Shaped Waveform</a><a id="Gradient-Time-Shaped-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Time-Shaped-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A = 50*10e-6*[1; 1; 0.8; 0.8; 1; 1];

julia&gt; T = 1e-3*[5; 0.2; 5; 0.2; 5];

julia&gt; delay, rise, fall = 1e-3, 1e-3, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
←1.0 ms→ Grad(∿ mT, 15.4 ms, ↑1.0 ms, ↓1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ τ = 10.75 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-time-shaped-waveform.html" style="width:100%; height:420px;"></object><h2 id="ADC"><a class="docs-heading-anchor" href="#ADC">ADC</a><a id="ADC-1"></a><a class="docs-heading-anchor-permalink" href="#ADC" title="Permalink"></a></h2><p>The <strong>ADC</strong> struct is defined in the <strong>KomaMRI</strong> source code as follows:</p><pre><code class="language-julia hljs">mutable struct ADC
    N::Integer
    T::Real
    delay::Real
    Δf::Real
    ϕ::Real
end</code></pre><p>As you can see, it has 5 field names: &#39;&#39;N&#39;&#39; defines number of samples, &#39;&#39;T&#39;&#39; defines total acquisition duration, &#39;&#39;delay&#39;&#39; is the distance between the 0 time and the first sampled signal, &#39;&#39;Δf&#39;&#39; and &#39;&#39;ϕ&#39; are factor to correct signal acquisition (for advanced users).</p><p>In the image below you can see how to define an <strong>ADC</strong> event:</p><p align="center"><img width="50%" src="../../assets/event-shapes-adc.svg"/></p><p>Let&#39;s look at a basic example of defining an <strong>ADC</strong> struct and including it in a <strong>Sequence</strong> struct:</p><pre><code class="language-julia-repl hljs">julia&gt; N, T, delay =  16, 5e-3, 1e-3;

julia&gt; adc = ADC(N, T, delay)
ADC(16, 0.005, 0.001, 0.0, 0.0)

julia&gt; seq = Sequence(); seq += adc
Sequence[ τ = 6.0 ms | blocks: 1 | ADC: 1 | GR: 0 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-adc.html" style="width:100%; height:420px;"></object><h2 id="Combination-of-Events"><a class="docs-heading-anchor" href="#Combination-of-Events">Combination of Events</a><a id="Combination-of-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Combination-of-Events" title="Permalink"></a></h2><p>We can include multiple events within a single block of a sequence. The example below demonstrates how to combine an <strong>RF</strong> struct, three <strong>Grad</strong> structs for the x-y-z components, and an <strong>ADC</strong> struct in a single block of a sequence:</p><pre><code class="language-julia hljs"># Define an RF struct
A, T =  1e-6*[0; -0.1; 0.2; -0.5; 1; -0.5; 0.2; -0.1; 0], 0.5e-3;
rf = RF(A, T)

# Define a Grad struct for Gx
A, T, rise =  50*10e-6, 5e-3, 1e-3
gx = Grad(A, T, rise)

# Define a Grad struct for Gy
A = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]
T, rise = 5e-3, 2e-3;
gy = Grad(A, T, rise)

# Define a Grad struct for Gz
A = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]
T = 5e-3*[0.0; 0.1; 0.3; 0.2; 0.1; 0.2; 0.3; 0.2; 0.1]
gz = Grad(A, T)

# Define an ADC struct
N, T, delay =  16, 5e-3, 1e-3
adc = ADC(N, T, delay)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; seq = Sequence([gx; gy; gz;;], [rf;;], [adc])
Sequence[ τ = 9.0 ms | blocks: 1 | ADC: 1 | GR: 3 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-combination.html" style="width:100%; height:420px;"></object><p>Once the struct events are defined, it&#39;s important to note that to create a single block sequence, you need to provide 2D matrices of <strong>Grad</strong> and <strong>RF</strong> structs, as well as a vector of <strong>ADC</strong> structs as arguments in the <a href="../../reference/2-koma-base/#KomaMRIBase.Sequence"><code>Sequence</code></a> constructor.</p><h2 id="Algebraic-manipulation"><a class="docs-heading-anchor" href="#Algebraic-manipulation">Algebraic manipulation</a><a id="Algebraic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-manipulation" title="Permalink"></a></h2><p>Certain mathematical operations can be directly applied to events and sequence structs. This proves helpful when constructing sequences using reference structs and manipulating them algebraically to create new structs. Below, we provide a list of operations you can perform, along with examples where we check the equivalence of two different struct definitions:</p><ul><li>RF scaling</li></ul><pre><code class="language-julia hljs"># Define params
A, T = 10e-6, 0.5e-3    # Define base RF params  
α = (1 + im*1)/sqrt(2)  # Define a complex scaling factor

# Create two equivalent RFs in different ways
ra = RF(α * A, T)
rb = α * RF(A, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ra ≈ rb
true</code></pre><ul><li>Gradient scaling</li></ul><pre><code class="language-julia hljs"># Define params
A, T = 10e-3, 0.5e-3   # Define base gradient params  
α = 2                  # Define a scaling factor

# Create two equivalent gradients in different ways
ga = Grad(α * A, T)
gb = α * Grad(A, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ga ≈ gb
true</code></pre><ul><li>Gradient addition</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3      # Define common duration of the gradients
A1 = 5e-3       # Define base amplitude for gradient  
A2 = 10e-3      # Define another base amplitude for gradient  

# Create two equivalent gradients in different ways
ga = Grad(A1 + A2, T)
gb = Grad(A1, T) + Grad(A2, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ga ≈ gb
true</code></pre><ul><li>Gradient array multiplication by a matrix</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3                          # Define common duration of the gradients
Ax, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  
gx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients
R = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)

# Create two equivalent gradient vectors in different ways
ga = [gy; gz; gx]
gb = R * [gx; gy; gz]

# Create two equivalent gradient matrices in different ways
gc = [gy 2*gy; gz 2*gz; gx 2*gx]
gd = R * [gx 2*gx; gy 2*gy; gz 2*gz]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; all(ga .≈ gb)
true

julia&gt; all(gc .≈ gd)
true</code></pre><ul><li>Sequence rotation</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3                          # Define common duration of the gradients
Ax, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  
gx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients
R = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)

# Create two equivalent sequences in different ways
sa = Sequence(R * [gx; gy; gz;;])
sb = R * Sequence([gx; gy; gz;;])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; all(sa.GR .≈ sb.GR)
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1-sequence/">« Sequence</a><a class="docs-footer-nextpage" href="../3-simulation/">Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 10 December 2024 21:40">Tuesday 10 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
