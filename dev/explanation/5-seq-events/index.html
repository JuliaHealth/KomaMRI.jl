<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sequence Events ¬∑ KomaMRI.jl</title><meta name="title" content="Sequence Events ¬∑ KomaMRI.jl"/><meta property="og:title" content="Sequence Events ¬∑ KomaMRI.jl"/><meta property="twitter:title" content="Sequence Events ¬∑ KomaMRI.jl"/><meta name="description" content="Documentation for KomaMRI.jl."/><meta property="og:description" content="Documentation for KomaMRI.jl."/><meta property="twitter:description" content="Documentation for KomaMRI.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/hide-documenter-example-output.css" rel="stylesheet" type="text/css"/><link href="../../assets/center-images.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="KomaMRI.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="KomaMRI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">üè† Home</a></li><li><a class="tocitem" href="../../how-to/1-getting-started/">üèÉ Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">üèãÔ∏è Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/01-FID/">Free Induction Decay</a></li><li><a class="tocitem" href="../../tutorial/02-SmallTipApproximation/">Small Tip Angle Approximation</a></li><li><a class="tocitem" href="../../tutorial/03-ChemicalShiftEPI/">Chemical Shift in an EPI sequence</a></li><li><a class="tocitem" href="../../tutorial/04-3DSliceSelective/">Slice-Selective Acquisition of 3D Phantom</a></li><li><a class="tocitem" href="../../tutorial/05-SimpleMotion/">Patient&#39;s Motion During Acquisition</a></li><li><a class="tocitem" href="../../tutorial/06-DiffusionMotion/">Diffusion-induced Signal Attenuation</a></li><li><a class="tocitem" href="../../tutorial/07-RRVariability/">Cardiac Cine MRI with Arrhythmias</a></li><li><a class="tocitem" href="../../tutorial/07-label/">Using Labels to reconstruct multi-slice / multi-contrast sequences</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">üßë‚Äçüî¨ Reproducible Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial-pluto/01-gradient-echo-spin-echo/">Understanding basic MRI sequences</a></li><li><a class="tocitem" href="../../tutorial-pluto/02-low-field-cmra-optimization/">Low-Field CMRA Optimization</a></li><li><a class="tocitem" href="../../tutorial-pluto/03-low-field-boost-optimization/">Low-Field BOOST Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">üë®‚Äçüç≥ How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how-to/2-1-use-koma-ui/">Use Koma&#39;s User Interface</a></li><li><a class="tocitem" href="../../how-to/2-2-use-koma-notebooks/">Use Koma in Notebooks</a></li><li><a class="tocitem" href="../../how-to/2-3-use-koma-scripts/">Use Koma in Julia Scripts</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-phantom/">Create Your Own Phantom</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-sequence/">Create Your Own Sequence</a></li><li><a class="tocitem" href="../../how-to/4-run-distributed-simulations/">Run Distributed Simulations</a></li><li><a class="tocitem" href="../../how-to/5-contribute-to-koma/">Contribute to Koma</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">ü§î Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../1-phantom/">Phantom</a></li><li><a class="tocitem" href="../2-motion/">Motion</a></li><li><a class="tocitem" href="../3-phantom-format/">Phantom File Format</a></li><li><a class="tocitem" href="../4-sequence/">Sequence</a></li><li class="is-active"><a class="tocitem" href>Sequence Events</a><ul class="internal"><li><a class="tocitem" href="#RF"><span>RF</span></a></li><li><a class="tocitem" href="#Gradient"><span>Gradient</span></a></li><li><a class="tocitem" href="#ADC"><span>ADC</span></a></li><li><a class="tocitem" href="#Extensions-and-Labels"><span>Extensions and Labels</span></a></li><li><a class="tocitem" href="#Combination-of-Events"><span>Combination of Events</span></a></li><li><a class="tocitem" href="#Algebraic-manipulation"><span>Algebraic manipulation</span></a></li></ul></li><li><a class="tocitem" href="../6-simulation/">Simulation</a></li><li><a class="tocitem" href="../7-gpu-explanation/">GPU Parallelization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">üë®‚Äçüíª Reference Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/1-api/">API Overview</a></li><li><a class="tocitem" href="../../reference/2-koma-base/">KomaMRIBase</a></li><li><a class="tocitem" href="../../reference/3-koma-core/">KomaMRICore</a></li><li><a class="tocitem" href="../../reference/4-koma-files/">KomaMRIFiles</a></li><li><a class="tocitem" href="../../reference/5-koma-plots/">KomaMRIPlots</a></li><li><a class="tocitem" href="../../reference/6-koma-mri/">KomaMRI</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ü§î Explanations</a></li><li class="is-active"><a href>Sequence Events</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sequence Events</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/master/docs/src/explanation/5-seq-events.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sequence-Events"><a class="docs-heading-anchor" href="#Sequence-Events">Sequence Events</a><a id="Sequence-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence-Events" title="Permalink"></a></h1><p>As we already know, a <strong>Sequence</strong> struct contains field names that store arrays of <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> structs. In the context of <strong>MRI</strong>, we refer to <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> as &quot;events.&quot; To create a <strong>Sequence</strong>, it&#39;s essential to understand how to create these fundamental events.</p><p>In the following subsections, we will provide detailed explanations of event parameters and guide you through the process of creating a <strong>Sequence</strong> using <strong>RF</strong>, <strong>Grad</strong>, and <strong>ADC</strong> events.</p><h2 id="RF"><a class="docs-heading-anchor" href="#RF">RF</a><a id="RF-1"></a><a class="docs-heading-anchor-permalink" href="#RF" title="Permalink"></a></h2><p>The <strong>RF</strong> struct is defined in the source code of <strong>KomaMRI</strong> as follows:</p><pre><code class="language-julia hljs">mutable struct RF
    A
    T
    Œîf
    delay::Real
end</code></pre><p>As you can see, it has 4 field names: <code>A</code> defines amplitude, <code>T</code> defines duration time, <code>delay</code> is the distance between the 0 time and the first waveform sample and <code>Œîf</code> is the displacement respect to the main field carrier frequency (this is for advanced users).</p><p><code>A</code> and <code>T</code> can be numbers or vectors of numbers. Depending on the length of the <code>A</code> and <code>T</code>, <strong>KomaMRI</strong> interprets different waveforms: </p><ul><li>Pulse Waveform: <code>A</code> and <code>T</code> are numbers</li><li>Uniformly-Sampled Waveform: <code>A</code> is a vector and <code>T</code> is a number</li><li>Time-Shaped Waveform: <code>A</code> and <code>T</code> are both vectors; <code>T</code> stores interval durations so <code>length(A) = length(T) + 1</code>, and the waveform is reconstructed by connecting consecutive <code>A</code> entries with piecewise-linear segments</li></ul><p>In the image below, we provide a summary of how you can define <strong>RF</strong> events:</p><p align="center"><img width="100%" src="../../assets/event-shapes-rf-horizontal.svg"/></p><p>Let&#39;s look at some basic examples of creating these <strong>RF</strong> structs and including them in a <strong>Sequence</strong> struct. The examples should be self-explanatory.</p><h3 id="RF-Pulse-Waveform"><a class="docs-heading-anchor" href="#RF-Pulse-Waveform">RF Pulse Waveform</a><a id="RF-Pulse-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Pulse-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A, T, delay =  10e-3, 0.5e-3, 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
‚Üê0.1 ms‚Üí RF(10000.0 uT, 0.5 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ œÑ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-pulse-waveform.html" style="width:100%; height:420px;"></object><h3 id="RF-Uniformly-Sampled-Waveform"><a class="docs-heading-anchor" href="#RF-Uniformly-Sampled-Waveform">RF Uniformly-Sampled Waveform</a><a id="RF-Uniformly-Sampled-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Uniformly-Sampled-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; tl = -3:0.2:-0.2; tr = 0.2:0.2:3;

julia&gt; A = (10e-3)*[sin.(œÄ*tl)./(œÄ*tl); 1; sin.(œÄ*tr)./(œÄ*tr)];

julia&gt; T, delay = 0.5e-3, 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
‚Üê0.1 ms‚Üí RF(‚àø uT, 0.5 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ œÑ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-uniformly-sampled-waveform.html" style="width:100%; height:420px;"></object><h3 id="RF-Time-Shaped-Waveform"><a class="docs-heading-anchor" href="#RF-Time-Shaped-Waveform">RF Time-Shaped Waveform</a><a id="RF-Time-Shaped-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#RF-Time-Shaped-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; tl = -4:0.2:-0.2; tr = 0.2:0.2:4

julia&gt; A = (10e-3)*[sin.(œÄ*tl)./(œÄ*tl); 1; 1; sin.(œÄ*tr)./(œÄ*tr)]

julia&gt; T = [0.05e-3*ones(length(tl)); 2e-3; 0.05e-3*ones(length(tl))]

julia&gt; delay = 0.1e-3;

julia&gt; rf = RF(A, T, 0, delay)
‚Üê0.1 ms‚Üí RF(‚àø uT, 4.0 ms, 0.0 Hz)

julia&gt; seq = Sequence(); seq += rf
Sequence[ œÑ = 4.1 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-rf-time-shaped-waveform.html" style="width:100%; height:420px;"></object><h2 id="Gradient"><a class="docs-heading-anchor" href="#Gradient">Gradient</a><a id="Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient" title="Permalink"></a></h2><p>The <strong>Grad</strong> struct is defined as follows in the source code of <strong>KomaMRI</strong>:</p><pre><code class="language-julia hljs">mutable struct Grad
    A
    T
    rise::Real
    fall::Real
    delay::Real
end</code></pre><p>As you can see, it has 5 field names: <code>A</code> defines amplitude, <code>T</code> defines duration time, <code>delay</code> is the distance between the 0 time and the first waveform sample, <code>rise</code> and <code>fall</code> are the time durations of the first and last gradient ramps.</p><p>Just like the <strong>RF</strong>, <code>A</code> and <code>T</code> in the <strong>Grad</strong> struct can be numbers or vectors of numbers. Depending on the length of the <code>A</code> and <code>T</code>, <strong>KomaMRI</strong> interprets different waveforms: </p><ul><li>Trapezoidal Waveform: <code>A</code> and <code>T</code> are numbers</li><li>Uniformly-Sampled Waveform: <code>A</code> is a vector and <code>T</code> is a number</li><li>Time-Shaped Waveform: <code>A</code> and <code>T</code> are both vectors; <code>T</code> stores interval durations so <code>length(A) = length(T) + 1</code>, and the waveform is reconstructed by connecting consecutive <code>A</code> entries with piecewise-linear segments</li></ul><p>In the image below, we provide a summary of how you can define <strong>Grad</strong> events:</p><p align="center"><img width="100%" src="../../assets/event-shapes-gr-horizontal.svg"/></p><p>Let&#39;s look at some basic examples of creating these <strong>Grad</strong> structs and including them in a <strong>Sequence</strong> struct, focusing on the <code>x</code> component of the gradients. The examples should be self-explanatory.</p><h3 id="Gradient-Trapezoidal-Waveform"><a class="docs-heading-anchor" href="#Gradient-Trapezoidal-Waveform">Gradient Trapezoidal Waveform</a><a id="Gradient-Trapezoidal-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Trapezoidal-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A, T, delay, rise, fall = 50*10e-6, 5e-3, 2e-3, 1e-3, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
‚Üê2.0 ms‚Üí Grad(0.5 mT, 0.5 ms, ‚Üë1.0 ms, ‚Üì1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ œÑ = 9.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-trapezoidal-waveform.html" style="width:100%; height:420px;"></object><h3 id="Gradient-Uniformly-Sampled-Waveform"><a class="docs-heading-anchor" href="#Gradient-Uniformly-Sampled-Waveform">Gradient Uniformly-Sampled Waveform</a><a id="Gradient-Uniformly-Sampled-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Uniformly-Sampled-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; t = 0:0.25:7.5

julia&gt; A = 10*10e-6 * sqrt.(œÄ*t) .* sin.(œÄ*t)

julia&gt; T = 10e-3;

julia&gt; delay, rise, fall = 1e-3, 0, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
‚Üê1.0 ms‚Üí Grad(‚àø mT, 10.0 ms, ‚Üë0.0 ms, ‚Üì1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ œÑ = 12.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-uniformly-sampled-waveform.html" style="width:100%; height:420px;"></object><h3 id="Gradient-Time-Shaped-Waveform"><a class="docs-heading-anchor" href="#Gradient-Time-Shaped-Waveform">Gradient Time-Shaped Waveform</a><a id="Gradient-Time-Shaped-Waveform-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Time-Shaped-Waveform" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; A = 50*10e-6*[1; 1; 0.8; 0.8; 1; 1];

julia&gt; T = 1e-3*[5; 0.2; 5; 0.2; 5];

julia&gt; delay, rise, fall = 1e-3, 1e-3, 1e-3;

julia&gt; gr = Grad(A, T, rise, fall, delay)
‚Üê1.0 ms‚Üí Grad(‚àø mT, 15.4 ms, ‚Üë1.0 ms, ‚Üì1.0 ms)

julia&gt; seq = Sequence([gr])
Sequence[ œÑ = 10.75 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-gr-time-shaped-waveform.html" style="width:100%; height:420px;"></object><h2 id="ADC"><a class="docs-heading-anchor" href="#ADC">ADC</a><a id="ADC-1"></a><a class="docs-heading-anchor-permalink" href="#ADC" title="Permalink"></a></h2><p>The <strong>ADC</strong> struct is defined in the <strong>KomaMRI</strong> source code as follows:</p><pre><code class="language-julia hljs">mutable struct ADC
    N::Integer
    T::Real
    delay::Real
    Œîf::Real
    œï::Real
end</code></pre><p>As you can see, it has 5 field names: <code>N</code> defines number of samples, <code>T</code> defines total acquisition duration, <code>delay</code> is the distance between the 0 time and the first sampled signal, <code>Œîf</code> and <code>œï</code> are factor to correct signal acquisition (for advanced users).</p><p>In the image below you can see how to define an <strong>ADC</strong> event:</p><p align="center"><img width="50%" src="../../assets/event-shapes-adc.svg"/></p><p>Let&#39;s look at a basic example of defining an <strong>ADC</strong> struct and including it in a <strong>Sequence</strong> struct:</p><pre><code class="language-julia-repl hljs">julia&gt; N, T, delay =  16, 5e-3, 1e-3;

julia&gt; adc = ADC(N, T, delay)
ADC(16, 0.005, 0.001, 0.0, 0.0)

julia&gt; seq = Sequence(); seq += adc
Sequence[ œÑ = 6.0 ms | blocks: 1 | ADC: 1 | GR: 0 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-adc.html" style="width:100%; height:420px;"></object><h2 id="Extensions-and-Labels"><a class="docs-heading-anchor" href="#Extensions-and-Labels">Extensions and Labels</a><a id="Extensions-and-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions-and-Labels" title="Permalink"></a></h2><p>The <code>EXTENSION</code> field in the <code>Sequence</code> struct is used to store additional metadata or labels for each block in the sequence. This can be particularly useful for adding metadata headers required for formats like ISMRMRD. Labels can be used to manage sequence metadata, such as line numbers or echo numbers, which are essential for certain reconstruction algorithms.</p><h3 id="LabelInc-and-LabelSet-extension"><a class="docs-heading-anchor" href="#LabelInc-and-LabelSet-extension">LabelInc and LabelSet extension</a><a id="LabelInc-and-LabelSet-extension-1"></a><a class="docs-heading-anchor-permalink" href="#LabelInc-and-LabelSet-extension" title="Permalink"></a></h3><p>The <code>LabelInc</code> and <code>LabelSet</code> functions are used to create labels that can be added to the <code>EXTENSION</code> field of a <code>Sequence</code>. These labels help in managing ADC metada.</p><p>Only Pulseq labels are availables. <a href="https://ismrmrd.readthedocs.io/en/stable/mrd_raw_data.html#mrd-acquisitionflags">MRD also stores other FLAGS currently not available in KomaMRI</a>:</p><pre><code class="language-julia hljs">mutable struct AdcLabels
  LIN::Int
  PAR::Int
  SLC::Int
  SEG::Int
  REP::Int
  AVG::Int
  SET::Int
  ECO::Int
  PHS::Int
  NAV::Int
  REV::Int
  SMS::Int
end</code></pre><h4 id="LabelInc"><a class="docs-heading-anchor" href="#LabelInc">LabelInc</a><a id="LabelInc-1"></a><a class="docs-heading-anchor-permalink" href="#LabelInc" title="Permalink"></a></h4><p>The <code>LabelInc</code> function creates a label that increments a specific metadata field by a given value. This is useful for managing fields like line numbers or echo numbers.</p><pre><code class="language-julia hljs">LabelInc(value::Int, label::String)</code></pre><ul><li><code>value</code>: The increment value.</li><li><code>label</code>: The name of the metadata field to increment.</li></ul><h4 id="LabelSet"><a class="docs-heading-anchor" href="#LabelSet">LabelSet</a><a id="LabelSet-1"></a><a class="docs-heading-anchor-permalink" href="#LabelSet" title="Permalink"></a></h4><p>The <code>LabelSet</code> function creates a label that sets a specific metadata field to a given value. This is useful for managing fields like line numbers or echo numbers.</p><pre><code class="language-julia hljs">LabelSet(value::Int, label::String)</code></pre><ul><li><code>value</code>: The value to set.</li><li><code>label</code>: The name of the metadata field to set.</li></ul><h3 id="Trigger-extension"><a class="docs-heading-anchor" href="#Trigger-extension">Trigger extension</a><a id="Trigger-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Trigger-extension" title="Permalink"></a></h3><p>As described by the <a href="https://pulseq.github.io/specification.pdf">Pulseq specifications</a> : <code>TRIGGERS extension, which is not a part of the core Pulseq format and MAY be subject to rapid changes</code>. The usage of the type / channel is system dependent and must be checked beforehand.</p><div class="admonition is-info" id="Note-2baf9f88792250b7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2baf9f88792250b7" title="Permalink"></a></header><div class="admonition-body"><p>Trigger extension is implemented but currently not taken into account during the simulation </p></div></div><pre><code class="language-julia hljs">mutable struct Trigger &lt;: Extension 
  type::Int # Type of trigger (system dependent). 0: undefined / unused
  channel::Int # channel of trigger (system dependent). 0: undefined / unused
  d1::Float64 # Delay prior to the trigger event (us)
  d2::Float64 # Duration of trigger event (us)
end</code></pre><h3 id="Example-Usage"><a class="docs-heading-anchor" href="#Example-Usage">Example Usage</a><a id="Example-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Usage" title="Permalink"></a></h3><p>Below is an example of how to use <code>LabelInc</code> and <code>LabelSet</code> to add labels to a sequence:</p><pre><code class="language-julia hljs"># Define a sequence
seq = Sequence()

# Create labels
lInc = LabelInc(1, &quot;LIN&quot;)
lSet = LabelSet(1, &quot;ECO&quot;)
trig = Trigger(0,1,100,500)

# Add labels to the sequence
seq.EXT = [[lInc,trig], [lSet]]

# Display the sequence
println(seq)</code></pre><p>In this example, <code>LabelInc(1, &quot;LIN&quot;)</code> increments the line number by 1, and <code>LabelSet(1, &quot;ECO&quot;)</code> sets the echo number to 1. These labels are added to the <code>EXTENSION</code> field of the sequence.</p><h3 id="Combining-Labels"><a class="docs-heading-anchor" href="#Combining-Labels">Combining Labels</a><a id="Combining-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Labels" title="Permalink"></a></h3><p>You can combine multiple labels for a single block by adding them to the <code>EXTENSION</code> field as a vector of labels. Here is an example:</p><pre><code class="language-julia hljs"># Define a sequence
seq = Sequence()

# Create labels
lInc = LabelInc(1, &quot;LIN&quot;)
lSet = LabelSet(1, &quot;ECO&quot;)

# Add combined labels to the sequence
seq.EXT = [[lInc, lSet]]

# Display the sequence
println(seq)</code></pre><p>In this example, both <code>LabelInc</code> and <code>LabelSet</code> are added to the <code>EXTENSION</code> field of the sequence, allowing for more complex metadata management.</p><p>By using <code>LabelInc</code> and <code>LabelSet</code>, you can effectively manage sequence metadata and ensure that your sequence is compatible with various reconstruction algorithms and formats.</p><div class="admonition is-warning" id="Warning-a58d3133d3cdc6a0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a58d3133d3cdc6a0" title="Permalink"></a></header><div class="admonition-body"><p>So far, <strong>KomaMRI</strong> EXTENSION only manage ADC labels and Triggers. In future version, other specific Pulseq extension will be added like <strong>Soft Delay</strong>, <strong>no rotation</strong> etc.</p></div></div><h2 id="Combination-of-Events"><a class="docs-heading-anchor" href="#Combination-of-Events">Combination of Events</a><a id="Combination-of-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Combination-of-Events" title="Permalink"></a></h2><p>We can include multiple events within a single block of a sequence. The example below demonstrates how to combine an <strong>RF</strong> struct, three <strong>Grad</strong> structs for the x-y-z components, and an <strong>ADC</strong> struct in a single block of a sequence:</p><pre><code class="language-julia hljs"># Define an RF struct
A, T =  1e-6*[0; -0.1; 0.2; -0.5; 1; -0.5; 0.2; -0.1; 0], 0.5e-3;
rf = RF(A, T)

# Define a Grad struct for Gx
A, T, rise =  50*10e-6, 5e-3, 1e-3
gx = Grad(A, T, rise)

# Define a Grad struct for Gy
A = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]
T, rise = 5e-3, 2e-3;
gy = Grad(A, T, rise)

# Define a Grad struct for Gz
A = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]
T = 5e-3*[0.0; 0.1; 0.3; 0.2; 0.1; 0.2; 0.3; 0.2; 0.1]
gz = Grad(A, T)

# Define an ADC struct
N, T, delay =  16, 5e-3, 1e-3
adc = ADC(N, T, delay)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; seq = Sequence([gx; gy; gz;;], [rf;;], [adc])
Sequence[ œÑ = 9.0 ms | blocks: 1 | ADC: 1 | GR: 3 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq; slider=false)</code></pre><object type="text/html" data="../../assets/event-combination.html" style="width:100%; height:420px;"></object><p>Once the struct events are defined, it&#39;s important to note that to create a single block sequence, you need to provide 2D matrices of <strong>Grad</strong> and <strong>RF</strong> structs, as well as a vector of <strong>ADC</strong> structs as arguments in the <a href="../../reference/2-koma-base/#KomaMRIBase.Sequence"><code>Sequence</code></a> constructor.</p><h2 id="Algebraic-manipulation"><a class="docs-heading-anchor" href="#Algebraic-manipulation">Algebraic manipulation</a><a id="Algebraic-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-manipulation" title="Permalink"></a></h2><p>Certain mathematical operations can be directly applied to events and sequence structs. This proves helpful when constructing sequences using reference structs and manipulating them algebraically to create new structs. Below, we provide a list of operations you can perform, along with examples where we check the equivalence of two different struct definitions:</p><ul><li>RF scaling</li></ul><pre><code class="language-julia hljs"># Define params
A, T = 10e-6, 0.5e-3    # Define base RF params  
Œ± = (1 + im*1)/sqrt(2)  # Define a complex scaling factor

# Create two equivalent RFs in different ways
ra = RF(Œ± * A, T)
rb = Œ± * RF(A, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ra ‚âà rb
true</code></pre><ul><li>Gradient scaling</li></ul><pre><code class="language-julia hljs"># Define params
A, T = 10e-3, 0.5e-3   # Define base gradient params  
Œ± = 2                  # Define a scaling factor

# Create two equivalent gradients in different ways
ga = Grad(Œ± * A, T)
gb = Œ± * Grad(A, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ga ‚âà gb
true</code></pre><ul><li>Gradient addition</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3      # Define common duration of the gradients
A1 = 5e-3       # Define base amplitude for gradient  
A2 = 10e-3      # Define another base amplitude for gradient  

# Create two equivalent gradients in different ways
ga = Grad(A1 + A2, T)
gb = Grad(A1, T) + Grad(A2, T)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ga ‚âà gb
true</code></pre><ul><li>Gradient array multiplication by a matrix</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3                          # Define common duration of the gradients
Ax, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  
gx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients
R = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)

# Create two equivalent gradient vectors in different ways
ga = [gy; gz; gx]
gb = R * [gx; gy; gz]

# Create two equivalent gradient matrices in different ways
gc = [gy 2*gy; gz 2*gz; gx 2*gx]
gd = R * [gx 2*gx; gy 2*gy; gz 2*gz]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; all(ga .‚âà gb)
true

julia&gt; all(gc .‚âà gd)
true</code></pre><ul><li>Sequence rotation</li></ul><pre><code class="language-julia hljs"># Define params
T = 0.5e-3                          # Define common duration of the gradients
Ax, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  
gx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients
R = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)

# Create two equivalent sequences in different ways
sa = Sequence(R * [gx; gy; gz;;])
sb = R * Sequence([gx; gy; gz;;])</code></pre><pre><code class="language-julia-repl hljs">julia&gt; all(sa.GR .‚âà sb.GR)
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../4-sequence/">¬´ Sequence</a><a class="docs-footer-nextpage" href="../6-simulation/">Simulation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 23:52">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
