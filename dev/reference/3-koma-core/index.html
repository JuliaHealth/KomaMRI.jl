<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>KomaMRICore ¬∑ KomaMRI.jl</title><meta name="title" content="KomaMRICore ¬∑ KomaMRI.jl"/><meta property="og:title" content="KomaMRICore ¬∑ KomaMRI.jl"/><meta property="twitter:title" content="KomaMRICore ¬∑ KomaMRI.jl"/><meta name="description" content="Documentation for KomaMRI.jl."/><meta property="og:description" content="Documentation for KomaMRI.jl."/><meta property="twitter:description" content="Documentation for KomaMRI.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/hide-documenter-example-output.css" rel="stylesheet" type="text/css"/><link href="../../assets/center-images.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="KomaMRI.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="KomaMRI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">üè† Home</a></li><li><a class="tocitem" href="../../how-to/1-getting-started/">üèÉ Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">üèãÔ∏è Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/01-FID/">Free Induction Decay</a></li><li><a class="tocitem" href="../../tutorial/02-SmallTipApproximation/">Small Tip Angle Approximation</a></li><li><a class="tocitem" href="../../tutorial/03-ChemicalShiftEPI/">Chemical Shift in an EPI sequence</a></li><li><a class="tocitem" href="../../tutorial/04-3DSliceSelective/">Slice-Selective Acquisition of 3D Phantom</a></li><li><a class="tocitem" href="../../tutorial/05-SimpleMotion/">Patient&#39;s Motion During Acquisition</a></li><li><a class="tocitem" href="../../tutorial/06-DiffusionMotion/">Diffusion-induced Signal Attenuation</a></li><li><a class="tocitem" href="../../tutorial/07-RRVariability/">Cardiac Cine MRI with Arrhythmias</a></li><li><a class="tocitem" href="../../tutorial/07-label/">Using Labels to reconstruct multi-slice / multi-contrast sequences</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">üßë‚Äçüî¨ Reproducible Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial-pluto/01-gradient-echo-spin-echo/">Understanding basic MRI sequences</a></li><li><a class="tocitem" href="../../tutorial-pluto/02-low-field-cmra-optimization/">Low-Field CMRA Optimization</a></li><li><a class="tocitem" href="../../tutorial-pluto/03-low-field-boost-optimization/">Low-Field BOOST Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">üë®‚Äçüç≥ How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how-to/2-1-use-koma-ui/">Use Koma&#39;s User Interface</a></li><li><a class="tocitem" href="../../how-to/2-2-use-koma-notebooks/">Use Koma in Notebooks</a></li><li><a class="tocitem" href="../../how-to/2-3-use-koma-scripts/">Use Koma in Julia Scripts</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-phantom/">Create Your Own Phantom</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-sequence/">Create Your Own Sequence</a></li><li><a class="tocitem" href="../../how-to/4-run-distributed-simulations/">Run Distributed Simulations</a></li><li><a class="tocitem" href="../../how-to/5-contribute-to-koma/">Contribute to Koma</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ü§î Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/1-phantom/">Phantom</a></li><li><a class="tocitem" href="../../explanation/2-motion/">Motion</a></li><li><a class="tocitem" href="../../explanation/3-phantom-format/">Phantom File Format</a></li><li><a class="tocitem" href="../../explanation/4-sequence/">Sequence</a></li><li><a class="tocitem" href="../../explanation/5-seq-events/">Sequence Events</a></li><li><a class="tocitem" href="../../explanation/6-simulation/">Simulation</a></li><li><a class="tocitem" href="../../explanation/7-gpu-explanation/">GPU Parallelization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">üë®‚Äçüíª Reference Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../1-api/">API Overview</a></li><li><a class="tocitem" href="../2-koma-base/">KomaMRIBase</a></li><li class="is-active"><a class="tocitem" href>KomaMRICore</a><ul class="internal"><li><a class="tocitem" href="#Simulation-functions"><span>Simulation functions</span></a></li><li><a class="tocitem" href="#GPU-helper-functions"><span>GPU helper functions</span></a></li><li><a class="tocitem" href="#Signal-to-RawAquisitionData-(MRD)"><span>Signal to <code>RawAquisitionData</code> (MRD)</span></a></li><li><a class="tocitem" href="#SpinRepresentationState&#39;s"><span><code>SpinRepresentationState</code>&#39;s</span></a></li><li><a class="tocitem" href="#Spinor-rotation-matrix-(RF-excitation)"><span><code>Spinor</code> rotation matrix (RF excitation)</span></a></li></ul></li><li><a class="tocitem" href="../4-koma-files/">KomaMRIFiles</a></li><li><a class="tocitem" href="../5-koma-plots/">KomaMRIPlots</a></li><li><a class="tocitem" href="../6-koma-mri/">KomaMRI</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">üë®‚Äçüíª Reference Guides</a></li><li class="is-active"><a href>KomaMRICore</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>KomaMRICore</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/master/docs/src/reference/3-koma-core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KomaMRICore"><a class="docs-heading-anchor" href="#KomaMRICore">KomaMRICore</a><a id="KomaMRICore-1"></a><a class="docs-heading-anchor-permalink" href="#KomaMRICore" title="Permalink"></a></h1><h2 id="Simulation-functions"><a class="docs-heading-anchor" href="#Simulation-functions">Simulation functions</a><a id="Simulation-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRICore.simulate"><a class="docstring-binding" href="#KomaMRICore.simulate"><code>KomaMRICore.simulate</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; sim_params, w)</code></pre><p>Returns the raw signal or the last state of the magnetization according to the value of the <code>&quot;return_type&quot;</code> key of the <code>sim_params</code> dictionary. </p><p>This is a wrapper function to <code>run_sim_time_iter</code>, which converts the inputs to the appropriate types and discretizes the sequence before simulation. The reported simulation time only considers <code>run_sim_time_iter</code>, as the preprocessing duration should be negligible compared to the simulation time (if this is not the case, please file a bug report). </p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) Phantom struct</li><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>sim_params</code>: (<code>::Dict{String,Any}</code>, <code>=Dict{String,Any}()</code>) simulation parameter dictionary</li><li><code>w</code>: (<code>::Blink.AtomShell.Window</code>, <code>=nothing</code>) the window within which to display a   progress bar in the Blink Window UI. If this variable is anything other than &#39;nothing&#39;,   the progress bar will be considered</li></ul><p><strong>Returns</strong></p><ul><li><code>out</code>: (<code>::Vector{Complex}</code> or <code>::SpinStateRepresentation</code> or <code>::RawAcquisitionData</code>) depending   on whether &quot;return_type&quot; is &quot;mat&quot;, &quot;state&quot; or &quot;raw&quot; (default), respectively</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq_file = joinpath(dirname(pathof(KomaMRI)), &quot;../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq&quot;);

julia&gt; sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)

julia&gt; raw = simulate(obj, seq, sys)

julia&gt; plot_signal(raw)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/SimulatorCore.jl#L304-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.simulate_slice_profile"><a class="docstring-binding" href="#KomaMRICore.simulate_slice_profile"><code>KomaMRICore.simulate_slice_profile</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mag = simulate_slice_profile(seq; z, sim_params)</code></pre><p>Returns magnetization of spins distributed along <code>z</code> after running the Sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>z</code>: (<code>=range(-2e-2,2e-2,200)</code>) range for the z axis</li><li><code>sim_params</code>: (<code>::Dict{String, Any}</code>, <code>=Dict{String,Any}(&quot;Œît_rf&quot;=&gt;1e-6)</code>) dictionary with   simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>mag</code>: (<code>::SpinStateRepresentation</code>) final state of the magnetization vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/SimulatorCore.jl#L442-L457">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.default_sim_params"><a class="docstring-binding" href="#KomaMRICore.default_sim_params"><code>KomaMRICore.default_sim_params</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sim_params = default_sim_params(sim_params=Dict{String,Any}())</code></pre><p>This function returns a dictionary containing default simulation parameters while also allowing the user to define some of them.</p><p><strong>Arguments</strong></p><ul><li><code>sim_params</code>: (<code>::Dict{String,Any}</code>, <code>=Dict{String,Any}()</code>) user-defined dictionary with   simulation parameters. The following lists its keys along with their possible values:<ul><li>&quot;return_type&quot;: defines the output of the <a href="#KomaMRICore.simulate"><code>simulate</code></a> function. Possible values   are <code>&quot;raw&quot;</code>, <code>&quot;mat&quot;</code>, and <code>&quot;state&quot;</code>, corresponding to outputting a MRIReco   <code>RawAcquisitionData</code>, the signal values, and the last magnetization state of the   simulation, respectively</li><li>&quot;sim_method&quot;: defines the type of simulation. The default value is <code>Bloch()</code>, but you   can alternatively use the <code>BlochDict()</code> simulation method. Moreover, you have the   flexibility to create your own methods without altering the KomaMRI source code</li><li>&quot;Œît&quot;: raster time for gradients</li><li>&quot;Œît_rf&quot;: raster time for RFs</li><li>&quot;precision&quot;: defines the floating-point simulation precision. You can choose between   <code>&quot;f32&quot;</code> and <code>&quot;f64&quot;</code> to use <code>Float32</code> and <code>Float64</code> primitive types, respectively.   It&#39;s important to note that, especially for GPU operations, using <code>&quot;f32&quot;</code> is   generally much faster</li><li>&quot;Nblocks&quot;: divides the simulation into a specified number of time blocks. This parameter   is designed to conserve RAM resources, as <strong>KomaMRI</strong> computes a series of   simulations consecutively, each with the specified number of blocks determined by   the value of <code>&quot;Nblocks&quot;</code></li><li>&quot;Nthreads&quot;: divides the <strong>Phantom</strong> into a specified number of threads. Because spins   are modeled independently of each other, <strong>KomaMRI</strong> can solve simulations in   parallel threads, speeding up the execution time</li><li>&quot;gpu&quot;: is a boolean that determines whether to use GPU or CPU hardware resources, as   long as they are available on the host computer</li><li>&quot;gpu_device&quot;: default value is &#39;nothing&#39;. If set to integer or device instance, calls the   corresponding function to set the device of the available GPU in the host computer    (e.g. CUDA.device!)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>sim_params</code>: (<code>::Dict{String,Any}</code>) dictionary with simulation parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/SimulatorCore.jl#L7-L44">source</a></section></details></article><h2 id="GPU-helper-functions"><a class="docs-heading-anchor" href="#GPU-helper-functions">GPU helper functions</a><a id="GPU-helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-helper-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRICore.get_backend"><a class="docstring-binding" href="#KomaMRICore.get_backend"><code>KomaMRICore.get_backend</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_backend(use_gpu)</code></pre><p>Gets the simulation backend to use. If use_gpu=false or there are no available GPU backends,  returns CPU(), else, returns the GPU backend (currently either CUDABackend(), MetalBackend(),  ROCBackend(), or oneAPIBackend()).</p><p>The GPU package for the corresponding backend (CUDA.jl, Metal.jl, AMDGPU.jl, or oneAPI.jl) must be loaded and functional, otherwise KomaMRI will default to using the CPU.</p><p><strong>Arguments</strong></p><ul><li>&#39;use_gpu&#39;: (&#39;::Bool&#39;) If true, attempt to use GPU and check for available backends</li></ul><p><strong>Returns</strong></p><ul><li>&#39;backend&#39;: (::KernelAbstractions.backend) The backend to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/GPUFunctions.jl#L23-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.print_devices"><a class="docstring-binding" href="#KomaMRICore.print_devices"><code>KomaMRICore.print_devices</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">print_devices()</code></pre><p>Simple function to print available devices. Calls internal get_backend() function to get the appropriate GPU / CPU backend and prints device information.</p><p><strong>Arguments</strong></p><ul><li>&#39;use_gpu&#39;:  (&#39;::Bool&#39;) If true, check for loaded / functional GPU backends and print appropriate warnings if no GPU backends have been loaded</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/GPUFunctions.jl#L92-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.gpu"><a class="docstring-binding" href="#KomaMRICore.gpu"><code>KomaMRICore.gpu</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gpu(x)</code></pre><p>Moves &#39;x&#39; to the GPU. For this function to work, a GPU backend will need to be loaded with &#39;using AMDGPU / CUDA / Metal / oneAPI.</p><p>This works for functions, and any struct marked with <code>@functor</code>.</p><p>Use <a href="#KomaMRICore.cpu"><code>cpu</code></a> to copy back to ordinary <code>Array</code>s.</p><p>See also <a href="#KomaMRICore.f32"><code>f32</code></a> and <a href="#KomaMRICore.f64"><code>f64</code></a> to change element type only.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using CUDA
x = x |&gt; gpu</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/Functors.jl#L9-L26">source</a></section><section><div><pre><code class="language-julia hljs">gpu(x, backend)</code></pre><p>Tries to move <code>x</code> to the GPU backend specified in the &#39;backend&#39; parameter. </p><p>This works for functions, and any struct marked with <code>@functor</code>.</p><p>Use <a href="#KomaMRICore.cpu"><code>cpu</code></a> to copy back to ordinary <code>Array</code>s.</p><p>See also <a href="#KomaMRICore.f32"><code>f32</code></a> and <a href="#KomaMRICore.f64"><code>f64</code></a> to change element type only.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = gpu(x, CUDABackend())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/Functors.jl#L38-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.cpu"><a class="docstring-binding" href="#KomaMRICore.cpu"><code>KomaMRICore.cpu</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cpu(x)</code></pre><p>Tries to move object to CPU. This works for functions, and any struct marked with <code>@functor</code>.</p><p>See also <a href="#KomaMRICore.gpu"><code>gpu</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x = x |&gt; cpu</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/Functors.jl#L59-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.f32"><a class="docstring-binding" href="#KomaMRICore.f32"><code>KomaMRICore.f32</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">f32(m)</code></pre><p>Converts the <code>eltype</code> of model&#39;s parameters to <code>Float32</code> Recurses into structs marked with <code>@functor</code>.</p><p>See also <a href="#KomaMRICore.f64"><code>f64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/Functors.jl#L80-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.f64"><a class="docstring-binding" href="#KomaMRICore.f64"><code>KomaMRICore.f64</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">f64(m)</code></pre><p>Converts the <code>eltype</code> of model&#39;s parameters to <code>Float64</code> (which is Koma&#39;s default).. Recurses into structs marked with <code>@functor</code>.</p><p>See also <a href="#KomaMRICore.f32"><code>f32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/Functors.jl#L90-L97">source</a></section></details></article><h2 id="Signal-to-RawAquisitionData-(MRD)"><a class="docs-heading-anchor" href="#Signal-to-RawAquisitionData-(MRD)">Signal to <code>RawAquisitionData</code> (MRD)</a><a id="Signal-to-RawAquisitionData-(MRD)-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-to-RawAquisitionData-(MRD)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRICore.signal_to_raw_data"><a class="docstring-binding" href="#KomaMRICore.signal_to_raw_data"><code>KomaMRICore.signal_to_raw_data</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">raw = signal_to_raw_data(signal, seq; phantom_name, sys, sim_params)</code></pre><p>Transforms the raw signal into a RawAcquisitionData struct (nearly equivalent to the ISMRMRD format) used for reconstruction with MRIReco.</p><p><strong>Arguments</strong></p><ul><li><code>signal</code>: (<code>::Matrix{Complex}</code>) raw signal matrix</li><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>phantom_name</code>: (<code>::String</code>, <code>=&quot;Phantom&quot;</code>) phantom name</li><li><code>sys</code>: (<code>::Scanner</code>, <code>=Scanner()</code>) Scanner struct</li><li><code>sim_params</code>: (<code>::Dict{String, Any}</code>, <code>=Dict{String,Any}()</code>) simulation parameter dictionary</li></ul><p><strong>Returns</strong></p><ul><li><code>raw</code>: (<code>::RawAcquisitionData</code>) RawAcquisitionData struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq_file = joinpath(dirname(pathof(KomaMRI)), &quot;../examples/1.sequences/epi_se.seq&quot;)

julia&gt; sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)

julia&gt; sim_params = KomaMRICore.default_sim_params(); sim_params[&quot;return_type&quot;] = &quot;mat&quot;

julia&gt; signal = simulate(obj, seq, sys; sim_params)

julia&gt; raw = signal_to_raw_data(signal, seq)

julia&gt; plot_signal(raw)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/rawdata/ISMRMRD.jl#L45-L77">source</a></section></details></article><h2 id="SpinRepresentationState&#39;s"><a class="docs-heading-anchor" href="#SpinRepresentationState&#39;s"><code>SpinRepresentationState</code>&#39;s</a><a id="SpinRepresentationState&#39;s-1"></a><a class="docs-heading-anchor-permalink" href="#SpinRepresentationState&#39;s" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRICore.Mag"><a class="docstring-binding" href="#KomaMRICore.Mag"><code>KomaMRICore.Mag</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mag = Mag(xy::Complex, z::Real)</code></pre><p>The Magnetization struct.</p><p><strong>Arguments</strong></p><ul><li><code>xy</code>: (<code>::Complex{Float64}</code>) magnetization of a spin in the xy plane</li><li><code>z</code>: (<code>::Real</code>) magnetization of a spin in the z plane</li></ul><p><strong>Returns</strong></p><ul><li><code>mag</code>: (<code>::Mag</code>) Magnetization struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/simulation/SimMethods/Magnetization.jl#L1-L12">source</a></section></details></article><h2 id="Spinor-rotation-matrix-(RF-excitation)"><a class="docs-heading-anchor" href="#Spinor-rotation-matrix-(RF-excitation)"><code>Spinor</code> rotation matrix (RF excitation)</a><a id="Spinor-rotation-matrix-(RF-excitation)-1"></a><a class="docs-heading-anchor-permalink" href="#Spinor-rotation-matrix-(RF-excitation)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRICore.Spinor"><a class="docstring-binding" href="#KomaMRICore.Spinor"><code>KomaMRICore.Spinor</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">spinor = Spinor(Œ±, Œ≤)</code></pre><p>Spinor(Œ±, Œ≤) with Cayley-Klein parameters Œ± and Œ≤. Based on &quot;Introduction to the Shinnar-Le Roux algorithm&quot;, Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (<span>$\alpha,\beta\in\mathbb{C}$</span>):</p><p class="math-container">\[R=\left[\begin{array}{cc}
\alpha &amp; -\beta^{*}\\
\beta &amp; \alpha^{*}
\end{array}\right],\]</p><p>with <span>$|\alpha|^2+|\beta|^2 = 1$</span>.</p><p>This later operates on the <span>$2\times2$</span> representation of <span>$(x,y,z)$</span> as follows <span>$V^{+} = R V R^{*}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>Œ±</code>: (<code>::Complex{Float64}</code>) Cayley-Klein parameter Œ±</li><li><code>Œ≤</code>: (<code>::Complex{Float64}</code>) Cayley-Klein parameter Œ≤</li></ul><p><strong>Returns</strong></p><ul><li><code>spinor</code>: (<code>::Spinor</code>) Spinor struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/datatypes/Spinor.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.Q"><a class="docstring-binding" href="#KomaMRICore.Q"><code>KomaMRICore.Q</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s = Q(œÜ, nxy, nz)</code></pre><p>Spinor rotation matrix. Counter-clockwise rotation of <code>œÜ</code> with respect to the axis of rotation n=(nx, ny, nz).</p><p>Pauly, J., Le Roux, P., Nishimura, D., &amp; Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611</p><p class="math-container">\[\varphi=-\gamma\Delta t\sqrt{\left|B_{1}\right|^{2}+\left(\boldsymbol{G}\cdot\boldsymbol{x}
\right)^{2}}=-\gamma\Delta t\left\Vert \boldsymbol{B}\right\Vert\]</p><p class="math-container">\[\boldsymbol{n}=\boldsymbol{B}/\left\Vert \boldsymbol{B}\right\Vert\]</p><p><strong>Arguments</strong></p><ul><li><code>œÜ</code>: (<code>::Real</code>, <code>[rad]</code>) œÜ angle</li><li><code>nxy</code>: (<code>::Real</code>) nxy factor</li><li><code>nz</code>: (<code>::Real</code>) nz factor</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) spinnor struct that represents the <code>Q</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/datatypes/Spinor.jl#L132-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.Un"><a class="docstring-binding" href="#KomaMRICore.Un"><code>KomaMRICore.Un</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Rodrigues&#39; formula: Rotation matrix that when applied rotates with respect to &quot;n&quot; in an angle Œ∏ anti clock-wise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/other/DiffusionModel.jl#L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.Rx"><a class="docstring-binding" href="#KomaMRICore.Rx"><code>KomaMRICore.Rx</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s = Rx(Œ∏)</code></pre><p>Spinor counter-clockwise rotation matrix with angle <code>Œ∏</code> with respect to x-axis.</p><p><strong>Arguments</strong></p><ul><li><code>Œ∏</code>: (<code>::Real</code>, <code>[rad]</code>) angle with respect to x-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) spinor struct that represents the <code>Rx</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/datatypes/Spinor.jl#L86-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.Ry"><a class="docstring-binding" href="#KomaMRICore.Ry"><code>KomaMRICore.Ry</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s = Ry(Œ∏)</code></pre><p>Spinor counter-clockwise rotation matrix with angle <code>Œ∏</code> with respect to y-axis.</p><p><strong>Arguments</strong></p><ul><li><code>Œ∏</code>: (<code>::Real</code>, <code>[rad]</code>) angle with respect to y-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) spinor struct that represents the <code>Ry</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/datatypes/Spinor.jl#L73-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRICore.Rz"><a class="docstring-binding" href="#KomaMRICore.Rz"><code>KomaMRICore.Rz</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s = Rz(œÜ)</code></pre><p>Spinor counter-clockwise rotation matrix with angle <code>œÜ</code> with respect to z-axis.</p><p><strong>Arguments</strong></p><ul><li><code>œÜ</code>: (<code>::Real</code>, <code>[rad]</code>) angle with respect to z-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) spinnor struct that represents the <code>Rz</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRICore/src/datatypes/Spinor.jl#L60-L70">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2-koma-base/">¬´ KomaMRIBase</a><a class="docs-footer-nextpage" href="../4-koma-files/">KomaMRIFiles ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 23:52">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
