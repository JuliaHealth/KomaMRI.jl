<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>KomaMRIBase ¬∑ KomaMRI.jl</title><meta name="title" content="KomaMRIBase ¬∑ KomaMRI.jl"/><meta property="og:title" content="KomaMRIBase ¬∑ KomaMRI.jl"/><meta property="twitter:title" content="KomaMRIBase ¬∑ KomaMRI.jl"/><meta name="description" content="Documentation for KomaMRI.jl."/><meta property="og:description" content="Documentation for KomaMRI.jl."/><meta property="twitter:description" content="Documentation for KomaMRI.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/hide-documenter-example-output.css" rel="stylesheet" type="text/css"/><link href="../../assets/center-images.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="KomaMRI.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="KomaMRI.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">üè† Home</a></li><li><a class="tocitem" href="../../how-to/1-getting-started/">üèÉ Getting Started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">üèãÔ∏è Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/01-FID/">Free Induction Decay</a></li><li><a class="tocitem" href="../../tutorial/02-SmallTipApproximation/">Small Tip Angle Approximation</a></li><li><a class="tocitem" href="../../tutorial/03-ChemicalShiftEPI/">Chemical Shift in an EPI sequence</a></li><li><a class="tocitem" href="../../tutorial/04-3DSliceSelective/">Slice-Selective Acquisition of 3D Phantom</a></li><li><a class="tocitem" href="../../tutorial/05-SimpleMotion/">Patient&#39;s Motion During Acquisition</a></li><li><a class="tocitem" href="../../tutorial/06-DiffusionMotion/">Diffusion-induced Signal Attenuation</a></li><li><a class="tocitem" href="../../tutorial/07-RRVariability/">Cardiac Cine MRI with Arrhythmias</a></li><li><a class="tocitem" href="../../tutorial/07-label/">Using Labels to reconstruct multi-slice / multi-contrast sequences</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">üßë‚Äçüî¨ Reproducible Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial-pluto/01-gradient-echo-spin-echo/">Understanding basic MRI sequences</a></li><li><a class="tocitem" href="../../tutorial-pluto/02-low-field-cmra-optimization/">Low-Field CMRA Optimization</a></li><li><a class="tocitem" href="../../tutorial-pluto/03-low-field-boost-optimization/">Low-Field BOOST Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">üë®‚Äçüç≥ How to</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how-to/2-1-use-koma-ui/">Use Koma&#39;s User Interface</a></li><li><a class="tocitem" href="../../how-to/2-2-use-koma-notebooks/">Use Koma in Notebooks</a></li><li><a class="tocitem" href="../../how-to/2-3-use-koma-scripts/">Use Koma in Julia Scripts</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-phantom/">Create Your Own Phantom</a></li><li><a class="tocitem" href="../../how-to/3-create-your-own-sequence/">Create Your Own Sequence</a></li><li><a class="tocitem" href="../../how-to/4-run-distributed-simulations/">Run Distributed Simulations</a></li><li><a class="tocitem" href="../../how-to/5-contribute-to-koma/">Contribute to Koma</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ü§î Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/1-phantom/">Phantom</a></li><li><a class="tocitem" href="../../explanation/2-motion/">Motion</a></li><li><a class="tocitem" href="../../explanation/3-phantom-format/">Phantom File Format</a></li><li><a class="tocitem" href="../../explanation/4-sequence/">Sequence</a></li><li><a class="tocitem" href="../../explanation/5-seq-events/">Sequence Events</a></li><li><a class="tocitem" href="../../explanation/6-simulation/">Simulation</a></li><li><a class="tocitem" href="../../explanation/7-gpu-explanation/">GPU Parallelization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">üë®‚Äçüíª Reference Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../1-api/">API Overview</a></li><li class="is-active"><a class="tocitem" href>KomaMRIBase</a><ul class="internal"><li><a class="tocitem" href="#Scanner-related-functions"><span><code>Scanner</code>-related functions</span></a></li><li><a class="tocitem" href="#Phantom-related-functions"><span><code>Phantom</code>-related functions</span></a></li><li><a class="tocitem" href="#Motion-related-functions"><span><code>Motion</code>-related functions</span></a></li><li><a class="tocitem" href="#Motionconstructors"><span><code>Motion</code>constructors</span></a></li><li><a class="tocitem" href="#Sequence-related-functions"><span><code>Sequence</code>-related functions</span></a></li><li><a class="tocitem" href="#Sequence-Building-Blocks-(SBB)"><span>Sequence Building Blocks (SBB)</span></a></li></ul></li><li><a class="tocitem" href="../3-koma-core/">KomaMRICore</a></li><li><a class="tocitem" href="../4-koma-files/">KomaMRIFiles</a></li><li><a class="tocitem" href="../5-koma-plots/">KomaMRIPlots</a></li><li><a class="tocitem" href="../6-koma-mri/">KomaMRI</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">üë®‚Äçüíª Reference Guides</a></li><li class="is-active"><a href>KomaMRIBase</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>KomaMRIBase</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/master/docs/src/reference/2-koma-base.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KomaMRIBase"><a class="docs-heading-anchor" href="#KomaMRIBase">KomaMRIBase</a><a id="KomaMRIBase-1"></a><a class="docs-heading-anchor-permalink" href="#KomaMRIBase" title="Permalink"></a></h1><h2 id="Scanner-related-functions"><a class="docs-heading-anchor" href="#Scanner-related-functions"><code>Scanner</code>-related functions</a><a id="Scanner-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Scanner-related-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.Scanner"><a class="docstring-binding" href="#KomaMRIBase.Scanner"><code>KomaMRIBase.Scanner</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">sys = Scanner(B0, B1, Gmax, Smax, ADC_Œît, seq_Œît, GR_Œît, RF_Œît,
    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)</code></pre><p>The Scanner struct. It contains hardware limitations of the MRI resonator. It is an input for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>B0</code>: (<code>::Real</code>, <code>=1.5</code>, <code>[T]</code>) main magnetic field strength</li><li><code>B1</code>: (<code>::Real</code>, <code>=10e-6</code>, <code>[T]</code>) maximum RF amplitude</li><li><code>Gmax</code>: (<code>::Real</code>, <code>=60e-3</code>, <code>[T/m]</code>) maximum gradient amplitude</li><li><code>Smax</code>: (<code>::Real</code>, <code>=500</code>, <code>[mT/m/ms]</code>) gradient&#39;s maximum slew-rate</li><li><code>ADC_Œît</code>: (<code>::Real</code>, <code>=2e-6</code>, <code>[s]</code>) ADC raster time</li><li><code>seq_Œît</code>: (<code>::Real</code>, <code>=1e-5</code>, <code>[s]</code>) sequence-block raster time</li><li><code>GR_Œît</code>: (<code>::Real</code>, <code>=1e-5</code>, <code>[s]</code>) gradient raster time</li><li><code>RF_Œît</code>: (<code>::Real</code>, <code>=1e-6</code>, <code>[s]</code>) RF raster time</li><li><code>RF_ring_down_T</code>: (<code>::Real</code>, <code>=20e-6</code>, <code>[s]</code>) RF ring down time</li><li><code>RF_dead_time_T</code>: (<code>::Real</code>, <code>=100e-6</code>, <code>[s]</code>) RF dead time</li><li><code>ADC_dead_time_T</code>: (<code>::Real</code>, <code>=10e-6</code>, <code>[s]</code>) ADC dead time</li></ul><p><strong>Returns</strong></p><ul><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner()

julia&gt; sys.B0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Scanner.jl#L1-L30">source</a></section></details></article><h2 id="Phantom-related-functions"><a class="docs-heading-anchor" href="#Phantom-related-functions"><code>Phantom</code>-related functions</a><a id="Phantom-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Phantom-related-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.Phantom"><a class="docstring-binding" href="#KomaMRIBase.Phantom"><code>KomaMRIBase.Phantom</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">obj = Phantom(name, x, y, z, œÅ, T1, T2, T2s, Œîw, DŒª1, DŒª2, DŒ∏, motion)</code></pre><p>The Phantom struct. Most of its field names are vectors, with each element associated with a property value representing a spin. This struct serves as an input for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>name</code>: (<code>::String</code>) phantom name</li><li><code>x</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin x-position vector</li><li><code>y</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin y-position vector</li><li><code>z</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin z-position vector</li><li><code>œÅ</code>: (<code>::AbstractVector{T&lt;:Real}</code>) spin proton density vector</li><li><code>T1</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[s]</code>) spin T1 parameter vector</li><li><code>T2</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[s]</code>) spin T2 parameter vector</li><li><code>T2s</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[s]</code>) spin T2s parameter vector</li><li><code>Œîw</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[rad/s]</code>) spin off-resonance parameter vector</li><li><code>DŒª1</code>: (<code>::AbstractVector{T&lt;:Real}</code>) spin DŒª1 (diffusion) parameter vector</li><li><code>DŒª2</code>: (<code>::AbstractVector{T&lt;:Real}</code>) spin DŒª2 (diffusion) parameter vector</li><li><code>DŒ∏</code>: (<code>::AbstractVector{T&lt;:Real}</code>) spin DŒ∏ (diffusion) parameter vector</li><li><code>motion</code>: (<code>::Union{NoMotion, Motion{T&lt;:Real} MotionList{T&lt;:Real}}</code>) motion</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) Phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = Phantom(x=[0.0])

julia&gt; obj.œÅ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Phantom.jl#L1-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.brain_phantom2D"><a class="docstring-binding" href="#KomaMRIBase.brain_phantom2D"><code>KomaMRIBase.brain_phantom2D</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">phantom = brain_phantom2D(;axis=&quot;axial&quot;, ss=4)</code></pre><p>Creates a two-dimensional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.</p><p><strong>References</strong></p><ul><li>B. Aubert-Broche, D.L. Collins, A.C. Evans: &quot;A new improved version of the realistic   digital brain phantom&quot; NeuroImage, in review - 2006</li><li>B. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: &quot;20 new digital   brain phantoms for creation of validation image data bases&quot; IEEE TMI, in review - 2006</li><li>https://brainweb.bic.mni.mcgill.ca/brainweb/tissue<em>mr</em>parameters.txt</li></ul><p><strong>Keywords</strong></p><ul><li><code>axis</code>: (<code>::String</code>, <code>=&quot;axial&quot;</code>, opts=[<code>&quot;axial&quot;</code>, <code>&quot;coronal&quot;</code>, <code>&quot;sagittal&quot;</code>]) orientation of the phantom</li><li><code>ss</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=4</code>) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]</li><li><code>us</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=1</code>)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy], if used ss is set to ss=1</li><li><code>tissue_properties</code>: (<code>::Dict</code>, <code>=Dict()</code>) phantom tissue properties in SI units considering the available tissues</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) Phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom2D(; axis=&quot;sagittal&quot;, ss=1)

julia&gt; obj = brain_phantom2D(; axis=&quot;axial&quot;, us=[1, 2])

julia&gt; phantom_values = 
    Dict(
        # œÅ, T1, T2, T2*, Œîw
        &quot;CSF&quot;           =&gt; [1,      2.569,  0.329,  0.058,  0],
        &quot;GM&quot;            =&gt; [0.86,   0.833,  0.083,  0.069,  0],
        &quot;WM&quot;            =&gt; [0.77,   0.500,  0.070,  0.061,  0],
        &quot;FAT1&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;MUSCLE&quot;        =&gt; [0,      0,      0,      0,      0],
        &quot;SKIN/MUSCLE&quot;   =&gt; [0,      0,      0,      0,      0],
        &quot;SKULL&quot;         =&gt; [0,      0,      0,      0,      0],
        &quot;VESSELS&quot;       =&gt; [0,      0,      0,      0,      0],
        &quot;FAT2&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;DURA&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;MARROW&quot;        =&gt; [0,      0,      0,      0,      0])
julia&gt; obj = brain_phantom2D(; tissue_properties=phantom_values)

julia&gt; plot_phantom_map(obj, :œÅ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Phantom.jl#L201-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.brain_phantom3D"><a class="docstring-binding" href="#KomaMRIBase.brain_phantom3D"><code>KomaMRIBase.brain_phantom3D</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obj = brain_phantom3D(; ss=4, us=1, start_end=[160,200])</code></pre><p>Creates a three-dimentional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm. </p><p><strong>References</strong></p><ul><li>B. Aubert-Broche, D.L. Collins, A.C. Evans: &quot;A new improved version of the realistic   digital brain phantom&quot; NeuroImage, in review - 2006</li><li>B. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: &quot;20 new digital   brain phantoms for creation of validation image data bases&quot; IEEE TMI, in review - 2006</li><li>https://brainweb.bic.mni.mcgill.ca/brainweb/tissue<em>mr</em>parameters.txt</li></ul><p><strong>Keywords</strong></p><ul><li><code>ss</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=4</code>) subsampling parameter for all axes if scaler, per axis if 3 element vector [ssx, ssy, ssz]</li><li><code>us</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=1</code>)  upsampling parameter for all axes if scaler, per axis if 3 element vector [usx, usy, usz]</li><li><code>start_end</code>: (<code>::Vector{Integer}</code>, <code>=[160,200]</code>) z index range of presampled phantom, 180 is center</li><li><code>tissue_properties</code>: (<code>::Dict</code>, <code>=Dict()</code>) phantom tissue properties in SI units considering the available tissues</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) 3D Phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom3D(; ss=5)

julia&gt; obj = brain_phantom3D(; us=[2, 2, 1])

julia&gt; phantom_values = 
    Dict(
        # œÅ, T1, T2, T2*, Œîw
        &quot;CSF&quot;           =&gt; [1,      2.569,  0.329,  0.058,  0],
        &quot;GM&quot;            =&gt; [0.86,   0.833,  0.083,  0.069,  0],
        &quot;WM&quot;            =&gt; [0.77,   0.500,  0.070,  0.061,  0],
        &quot;FAT1&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;MUSCLE&quot;        =&gt; [0,      0,      0,      0,      0],
        &quot;SKIN/MUSCLE&quot;   =&gt; [0,      0,      0,      0,      0],
        &quot;SKULL&quot;         =&gt; [0,      0,      0,      0,      0],
        &quot;VESSELS&quot;       =&gt; [0,      0,      0,      0,      0],
        &quot;FAT2&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;DURA&quot;          =&gt; [0,      0,      0,      0,      0],
        &quot;MARROW&quot;        =&gt; [0,      0,      0,      0,      0])
julia&gt; obj = brain_phantom3D(; tissue_properties=phantom_values)

julia&gt; plot_phantom_map(obj, :œÅ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Phantom.jl#L291-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.pelvis_phantom2D"><a class="docstring-binding" href="#KomaMRIBase.pelvis_phantom2D"><code>KomaMRIBase.pelvis_phantom2D</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obj = pelvis_phantom2D(; ss=4, us=1)</code></pre><p>Creates a two-dimensional pelvis Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.</p><p><strong>Keywords</strong></p><ul><li><code>ss</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=4</code>) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]</li><li><code>us</code>: (<code>::Integer or ::Vector{Integer}</code>, <code>=1</code>)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy]</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) Phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = pelvis_phantom2D(; ss=2])

julia&gt; obj = pelvis_phantom2D(; us=[1, 2])

julia&gt; pelvis_phantom2D(obj, :œÅ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Phantom.jl#L384-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.heart_phantom"><a class="docstring-binding" href="#KomaMRIBase.heart_phantom"><code>KomaMRIBase.heart_phantom</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obj = heart_phantom(
    circumferential_strain, radial_strain, rotation_angle; 
    heart_rate, asymmetry
)</code></pre><p>Heart-like LV 2D phantom. The variable <code>circumferential_strain</code> and <code>radial_strain</code> are for streching (if positive)  or contraction (if negative). <code>rotation_angle</code> is for rotation.</p><p><strong>Keywords</strong></p><ul><li><code>circumferential_strain</code>: (<code>::Real</code>, <code>=-0.3</code>) contraction parameter. Between -1 and 1</li><li><code>radial_strain</code>: (<code>::Real</code>, <code>=-0.3</code>) contraction parameter. Between -1 and 1</li><li><code>rotation_angle</code>: (<code>::Real</code>, <code>=15.0</code>, <code>[¬∫]</code>) maximum rotation angle</li><li><code>heart_rate</code>: (<code>::Real</code>, <code>=60</code>, <code>[bpm]</code>) heartbeat frequency</li><li><code>temporal_asymmetry</code>: (<code>::Real</code>, <code>=0.2</code>) time fraction of the period in which the systole occurs. Therefore, diastole lasts for <code>period * (1 - temporal_asymmetry)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) Heart-like LV phantom struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Phantom.jl#L124-L142">source</a></section></details></article><h2 id="Motion-related-functions"><a class="docs-heading-anchor" href="#Motion-related-functions"><code>Motion</code>-related functions</a><a id="Motion-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Motion-related-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.NoMotion"><a class="docstring-binding" href="#KomaMRIBase.NoMotion"><code>KomaMRIBase.NoMotion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">nomotion = NoMotion()</code></pre><p>NoMotion struct. It is used to create static phantoms.</p><p><strong>Returns</strong></p><ul><li><code>nomotion</code>: (<code>::NoMotion</code>) NoMotion struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nomotion = NoMotion()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/NoMotion.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.Motion"><a class="docstring-binding" href="#KomaMRIBase.Motion"><code>KomaMRIBase.Motion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">motion = Motion(action)
motion = Motion(action, time)
motion = Motion(action, time, spins)</code></pre><p>Motion struct. It defines the motion, during a certain time interval, of a given group of spins. It is composed by three fields: <code>action</code>, which  defines the motion itself, <code>time</code>, which accounts for the time during which the motion takes place, and <code>spins</code>, which indicates the spins  that are affected by that motion.</p><p><strong>Arguments</strong></p><ul><li><code>action</code>: (<code>::AbstractAction{T&lt;:Real}</code>) action, such as <a href="#KomaMRIBase.Translate"><code>Translate</code></a> or <a href="#KomaMRIBase.Rotate"><code>Rotate</code></a></li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>, <code>=TimeRange(0.0)</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>, <code>=AllSpins()</code>) spin indexes affected by the motion</li></ul><p><strong>Returns</strong></p><ul><li><code>motion</code>: (<code>::Motion</code>) Motion struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; motion =  Motion(
            action = Translate(0.01, 0.0, 0.02),
            time = TimeRange(0.0, 1.0),
            spins = SpinRange(1:10)
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.MotionList"><a class="docstring-binding" href="#KomaMRIBase.MotionList"><code>KomaMRIBase.MotionList</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">motionlist = MotionList(motions...)</code></pre><p>MotionList struct. The other option, instead of <code>NoMotion</code>,  is to define a dynamic phantom by means of the <code>MotionList</code> struct. It is composed by one or more <a href="../../explanation/2-motion/#Motion"><code>Motion</code></a> instances. </p><p><strong>Arguments</strong></p><ul><li><code>motions</code>: (<code>::Vector{Motion{T&lt;:Real}}</code>) vector of <code>Motion</code> instances</li></ul><p><strong>Returns</strong></p><ul><li><code>motionlist</code>: (<code>::MotionList</code>) MotionList struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  motionlist = MotionList(
            Motion(
                action = Translate(0.01, 0.0, 0.02),
                time = TimeRange(0.0, 1.0),
                spins = AllSpins()
            ),
            Motion(
                action = Rotate(0.0, 0.0, 45.0),
                time = Periodic(1.0),
                spins = SpinRange(1:10)
            )
        )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/MotionList.jl#L7-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_spin_coords"><a class="docstring-binding" href="#KomaMRIBase.get_spin_coords"><code>KomaMRIBase.get_spin_coords</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x, y, z = get_spin_coords(motion, x, y, z, t)</code></pre><p>Calculates the position of each spin at a set of arbitrary time instants, i.e. the time steps of the simulation.  For each dimension (x, y, z), the output matrix has <span>$N_{	{spins}}$</span> rows and <code>length(t)</code> columns.</p><p><strong>Arguments</strong></p><ul><li><code>motion</code>: (<code>::Union{NoMotion, Motion{T&lt;:Real} MotionList{T&lt;:Real}}</code>) phantom motion</li><li><code>x</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin x-position vector</li><li><code>y</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin y-position vector</li><li><code>z</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[m]</code>) spin z-position vector</li><li><code>t</code>: horizontal array of time instants</li></ul><p><strong>Returns</strong></p><ul><li><code>x, y, z</code>: (<code>::Tuple{AbstractArray, AbstractArray, AbstractArray}</code>) spin positions over time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L191-L206">source</a></section></details></article><h2 id="Motionconstructors"><a class="docs-heading-anchor" href="#Motionconstructors"><code>Motion</code>constructors</a><a id="Motionconstructors-1"></a><a class="docs-heading-anchor-permalink" href="#Motionconstructors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.translate"><a class="docstring-binding" href="#KomaMRIBase.translate"><code>KomaMRIBase.translate</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tr = translate(dx, dy, dz, time, spins)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::Real</code>, <code>[m]</code>) translation in x</li><li><code>dy</code>: (<code>::Real</code>, <code>[m]</code>) translation in y </li><li><code>dz</code>: (<code>::Real</code>, <code>[m]</code>) translation in z</li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>) spin indexes affected by the motion</li></ul><p><strong>Returns</strong></p><ul><li><code>tr</code>: (<code>::Motion</code>) Motion struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tr = translate(0.01, 0.02, 0.03, TimeRange(0.0, 1.0), SpinRange(1:10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L50-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.rotate"><a class="docstring-binding" href="#KomaMRIBase.rotate"><code>KomaMRIBase.rotate</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rt = rotate(pitch, roll, yaw, spins)</code></pre><p><strong>Arguments</strong></p><ul><li><code>pitch</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in x</li><li><code>roll</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in y </li><li><code>yaw</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in z</li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>) spin indexes affected by the motion</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: (<code>::NTuple{3,Real}</code> or <code>::CenterOfMass</code>) center of rotation, given in global coordinates. Default is center of mass.</li></ul><p><strong>Returns</strong></p><ul><li><code>rt</code>: (<code>::Motion</code>) Motion struct with <a href="#KomaMRIBase.Rotate"><code>Rotate</code></a> action</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rt = rotate(15.0, 0.0, 20.0, TimeRange(0.0, 1.0), SpinRange(1:10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L72-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.heartbeat"><a class="docstring-binding" href="#KomaMRIBase.heartbeat"><code>KomaMRIBase.heartbeat</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hb = heartbeat(circumferential_strain, radial_strain, longitudinal_strainl, time, spins)</code></pre><p><strong>Arguments</strong></p><ul><li><code>circumferential_strain</code>: (<code>::Real</code>) contraction parameter</li><li><code>radial_strain</code>: (<code>::Real</code>) contraction parameter</li><li><code>longitudinal_strain</code>: (<code>::Real</code>) contraction parameter</li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>) spin indexes affected by the motion</li></ul><p><strong>Returns</strong></p><ul><li><code>hb</code>: (<code>::Motion</code>) Motion struct with <a href="#KomaMRIBase.HeartBeat"><code>HeartBeat</code></a> action</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hb = heartbeat(-0.3, -0.2, 0.0, TimeRange(0.0, 1.0), SpinRange(1:10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L97-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.path"><a class="docstring-binding" href="#KomaMRIBase.path"><code>KomaMRIBase.path</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pt = path(dx, dy, dz, time, spins)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in x</li><li><code>dy</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in y </li><li><code>dz</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in z</li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>) spin indexes affected by the motion</li></ul><p><strong>Returns</strong></p><ul><li><code>pt</code>: (<code>::Motion</code>) Motion struct with <a href="#KomaMRIBase.Path"><code>Path</code></a> action</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pt = path(
          [0.01 0.02; 0.02 0.03], 
          [0.02 0.03; 0.03 0.04], 
          [0.03 0.04; 0.04 0.05], 
          TimeRange(0.0, 1.0), 
          SpinRange(1:10)
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L119-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.flowpath"><a class="docstring-binding" href="#KomaMRIBase.flowpath"><code>KomaMRIBase.flowpath</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fp = flowpath(dx, dy, dz, spin_reset, time, spins)</code></pre><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in x</li><li><code>dy</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in y </li><li><code>dz</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in z</li><li><code>spin_reset</code>: (<code>::AbstractArray{Bool}</code>) reset spin state flags</li><li><code>time</code>: (<code>::TimeCurve{T&lt;:Real}</code>) time information about the motion</li><li><code>spins</code>: (<code>::AbstractSpinSpan</code>) spin indexes affected by the motion</li></ul><p><strong>Returns</strong></p><ul><li><code>fp</code>: (<code>::Motion</code>) Motion struct with <a href="#KomaMRIBase.FlowPath"><code>FlowPath</code></a> action</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fp = flowpath(
          [0.01 0.02; 0.02 0.03], 
          [0.02 0.03; 0.03 0.04], 
          [0.03 0.04; 0.04 0.05], 
          [false false; false true],
          TimeRange(0.0, 1.0), 
          SpinRange(1:10)
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/Motion.jl#L147-L172">source</a></section></details></article><h3 id="AbstractAction-types"><a class="docs-heading-anchor" href="#AbstractAction-types"><code>AbstractAction</code> types</a><a id="AbstractAction-types-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractAction-types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.Translate"><a class="docstring-binding" href="#KomaMRIBase.Translate"><code>KomaMRIBase.Translate</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">t = Translate(dx, dy, dz)</code></pre><p>Translate struct. It produces a linear translation. Its fields are the final displacements in the three axes (dx, dy, dz).</p><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::Real</code>, <code>[m]</code>) translation in x</li><li><code>dy</code>: (<code>::Real</code>, <code>[m]</code>) translation in y </li><li><code>dz</code>: (<code>::Real</code>, <code>[m]</code>) translation in z</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Translate</code>) Translate struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = Translate(dx=0.01, dy=0.02, dz=0.03)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/actions/simpleactions/Translate.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.Rotate"><a class="docstring-binding" href="#KomaMRIBase.Rotate"><code>KomaMRIBase.Rotate</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">r = Rotate(pitch, roll, yaw, center=CenterOfMass())</code></pre><p>Rotate struct. It produces a rotation in the three axes:  x (pitch), y (roll), and z (yaw). We follow the RAS (Right-Anterior-Superior) orientation,  and the rotations are applied following the right-hand rule (counter-clockwise):</p><p><img src="../../assets/head-rotation-axis.svg" alt="Head Rotation Axis"/></p><p>The applied rotation matrix is obtained as follows: </p><p class="math-container">\[\begin{equation}
\begin{aligned}
R &amp;= R_z(\alpha) R_y(\beta) R_x(\gamma) \\
  &amp;= \begin{bmatrix}
\cos \alpha &amp; -\sin \alpha &amp; 0 \\
\sin \alpha &amp; \cos \alpha &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
\cos \beta &amp; 0 &amp; \sin \beta \\
0 &amp; 1 &amp; 0 \\
-\sin \beta &amp; 0 &amp; \cos \beta
\end{bmatrix}
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos \gamma &amp; -\sin \gamma \\
0 &amp; \sin \gamma &amp; \cos \gamma
\end{bmatrix} \\
  &amp;= \begin{bmatrix}
\cos \alpha \cos \beta &amp; \cos \alpha \sin \beta \sin \gamma - \sin \alpha \cos \gamma &amp; \cos \alpha \sin \beta \cos \gamma + \sin \alpha \sin \gamma \\
\sin \alpha \cos \beta &amp; \sin \alpha \sin \beta \sin \gamma + \cos \alpha \cos \gamma &amp; \sin \alpha \sin \beta \cos \gamma - \cos \alpha \sin \gamma \\
-\sin \beta &amp; \cos \beta \sin \gamma &amp; \cos \beta \cos \gamma
\end{bmatrix}
\end{aligned}
\end{equation}\]</p><p><strong>Arguments</strong></p><ul><li><code>pitch</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in x</li><li><code>roll</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in y </li><li><code>yaw</code>: (<code>::Real</code>, <code>[¬∫]</code>) rotation in z</li><li><code>center</code>: (<code>::NTuple{3,Real}</code> or <code>::CenterOfMass</code>) optional center of rotation, given in global coordinates. Default is center of mass.</li></ul><p><strong>Notes</strong></p><ul><li>Rotations are applied around the point specified in <code>center</code>. If omitted, the rotation is centered at the phantom‚Äôs center of mass.</li><li>If <code>center</code> is not <code>::CenterOfMass</code>, the rotation center is interpreted as a fixed point in space (absolute/global coordinates).</li><li>This design ensures that consecutive or inverse rotations behave consistently and predictably, since the rotation center does not change with object transformations.</li></ul><p><strong>Returns</strong></p><ul><li><code>r</code>: (<code>::Rotate</code>) Rotate struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = Rotate(pitch=15.0, roll=0.0, yaw=20.0)

julia&gt; r = Rotate(pitch=0.0, roll=45.0, yaw=0.0, center=(5e-3,0.0,0.0))
# Rotates around a point 5 mm to the right of the center of mass</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/actions/simpleactions/Rotate.jl#L6-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.HeartBeat"><a class="docstring-binding" href="#KomaMRIBase.HeartBeat"><code>KomaMRIBase.HeartBeat</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">h = HeartBeat(circumferential_strain, radial_strain, longitudinal_strain)</code></pre><p>HeartBeat struct. It produces a heartbeat-like motion, characterised by three types of strain: circumferential, radial and longitudinal</p><p><strong>Arguments</strong></p><ul><li><code>circumferential_strain</code>: (<code>::Real</code>) contraction parameter</li><li><code>radial_strain</code>: (<code>::Real</code>) contraction parameter</li><li><code>longitudinal_strain</code>: (<code>::Real</code>) contraction parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>h</code>: (<code>::HeartBeat</code>) HeartBeat struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = HeartBeat(circumferential_strain=-0.3, radial_strain=-0.2, longitudinal_strain=0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/actions/simpleactions/HeartBeat.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.Path"><a class="docstring-binding" href="#KomaMRIBase.Path"><code>KomaMRIBase.Path</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">p = Path(dx, dy, dz)</code></pre><p>Path struct. For this action (and for <code>FlowPath</code>), motion is not defined solely on the basis of  three numerical parameters, one for each spatial direction, as occurs for the <code>Translate</code>, <code>Rotate</code> and <code>HeartBeat</code> actions.</p><p>For this action, it is necessary to define  motion for each spin independently, in x (<code>dx</code>), y (<code>dy</code>) and z (<code>dz</code>). <code>dx</code>, <code>dy</code> and <code>dz</code> are now three matrixes, of (<span>$N_{spins}* \times \; N_{discrete\,times}$</span>) each. This means that each row corresponds to a spin trajectory over a set of discrete time instants.</p><div class="admonition is-info" id="Note-5f19a41067c1cb82"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5f19a41067c1cb82" title="Permalink"></a></header><div class="admonition-body"><p>*When creating a motion with <code>Flow</code> or <code>FlowPath</code>, you must make sure that  the number of rows of the matrices <code>dx</code>, <code>dy</code> and <code>dz</code> matches the number  of spins that are affected by the motion. </p><p>Remember that the range of spins affected by a motion  is defined by the <code>spins</code> field of the <code>Motion</code> struct</p><p>example:</p><pre><code class="language-julia-repl hljs">julia&gt; motion = Motion(
    action = Path(
        dx=[0.01 0.02; 0.02 0.03],  # 2 rows
        dy=[0.02 0.03; 0.03 0.04], 
        dz=[0.03 0.04; 0.04 0.05]),
    time = TimeRange(0.0, 1.0),
    spins = SpinRange(1:2)          # 2 spins
)</code></pre></div></div><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in x</li><li><code>dy</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in y </li><li><code>dz</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in z</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::Path</code>) Path struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = Path(
           dx=[0.01 0.02; 0.02 0.03], 
           dy=[0.02 0.03; 0.03 0.04], 
           dz=[0.03 0.04; 0.04 0.05]
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/actions/arbitraryactions/Path.jl#L1-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.FlowPath"><a class="docstring-binding" href="#KomaMRIBase.FlowPath"><code>KomaMRIBase.FlowPath</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">f = FlowPath(dx, dy, dz, spin_reset)</code></pre><p>FlowPath struct. This action is the same as <code>Path</code>,  except that it includes an additional field, called <code>spin_reset</code>,  which accounts for spins leaving the volume and being remapped  to another input position. When this happens, the magnetization  state of these spins must be reset during the simulation. </p><p>As with the <code>dx</code>, <code>dy</code> and <code>dz</code> matrices, <code>spin_reset</code> has a size of (<span>$N_{spins} \times \; N_{discrete\,times}$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>dx</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in x</li><li><code>dy</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in y </li><li><code>dz</code>: (<code>::AbstractArray{T&lt;:Real}</code>, <code>[m]</code>) displacements in z</li><li><code>spin_reset</code>: (<code>::AbstractArray{Bool}</code>) reset spin state flags</li></ul><p><strong>Returns</strong></p><ul><li><code>f</code>: (<code>::FlowPath</code>) FlowPath struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = FlowPath(
           dx=[0.01 0.02; 0.02 0.03], 
           dy=[0.02 0.03; 0.03 0.04], 
           dz=[0.03 0.04; 0.04 -0.04],
           spin_reset=[false false; false true]
       )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/actions/arbitraryactions/FlowPath.jl#L1-L31">source</a></section></details></article><h3 id="TimeCurve-types-and-related-functions"><a class="docs-heading-anchor" href="#TimeCurve-types-and-related-functions"><code>TimeCurve</code> types and related functions</a><a id="TimeCurve-types-and-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#TimeCurve-types-and-related-functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.TimeCurve"><a class="docstring-binding" href="#KomaMRIBase.TimeCurve"><code>KomaMRIBase.TimeCurve</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">timecurve = TimeCurve(t, t_unit, periodic, periods)</code></pre><p>TimeCurve struct. It is a specialized type that defines a time curve, which represents  the temporal behavior of motion. This curve is defined by two vectors:  <code>t</code> and <code>t_unit</code>, which represent the horizontal (x-axis) and vertical (y-axis) axes  of the curve, respectively. To some extent, this curve can be associated with animation curves, commonly found in software for video editing, 3D scene creation, or video game development.</p><p>Additionally, the TimeCurve struct contains two more fields, independent of each other: <code>periodic</code> is a Boolean that indicates whether the time curve should be repeated periodically. <code>periods</code> contains as many elements as repetitions are desired in the time curve.  Each element specifies the scaling factor for that repetition.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: (<code>::AbstractVector{&lt;:Real}</code>, <code>[s]</code>) time vector</li><li><code>t_unit</code>: (<code>::AbstractVector{&lt;:Real}</code>) y vector, it needs to be scaled between 0 and 1. 0    represents the start of the motion, while 1 represents the end.    The values in between represent the intermediate states of the motion.</li><li><code>periodic</code>: (<code>::Bool</code>, <code>=false</code>) indicates whether the time curve should be periodically repeated</li><li><code>periods</code>: (<code>::Union{&lt;:Real,AbstractVector{&lt;:Real}}</code>, <code>=1.0</code>): represents the relative duration    of each period with respect to the baseline duration defined by <code>t[end] - t[1]</code>.    In other words, it acts as a scaling factor to lengthen or shorten specific periods.    This allows for the creation of patterns such as arrhythmias or other variations in periodicity.</li></ul><p><strong>Returns</strong></p><ul><li><code>timecurve</code>: (<code>::TimeCurve</code>) TimeCurve struct</li></ul><p><strong>Examples</strong></p><p>1. Non-periodic motion with a single repetition: </p><pre><code class="language-julia-repl hljs">julia&gt; timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 0.2, 0.5, 1.0])</code></pre><p><img src="../../assets/time-curve-1.svg" alt="Time Curve 1"/></p><p>2. Periodic motion with a single repetition:</p><pre><code class="language-julia-repl hljs">julia&gt; timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periodic=true)</code></pre><p><img src="../../assets/time-curve-2.svg" alt="Time Curve 2"/></p><p>3. Non-periodic motion with multiple repetitions:</p><pre><code class="language-julia-repl hljs">julia&gt; timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5])</code></pre><p><img src="../../assets/time-curve-3.svg" alt="Time Curve 3"/></p><p>4. Periodic motion with multiple repetitions:</p><pre><code class="language-julia-repl hljs">julia&gt; timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5], periodic=true)</code></pre><p><img src="../../assets/time-curve-4.svg" alt="Time Curve 4"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/TimeCurve.jl#L1-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.TimeRange"><a class="docstring-binding" href="#KomaMRIBase.TimeRange"><code>KomaMRIBase.TimeRange</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timerange = TimeRange(t_start, t_end)</code></pre><p>The <code>TimeRange</code> function is a custom constructor for the <code>TimeCurve</code> struct.  It allows defining a simple time interval, with start and end times.</p><p><strong>Arguments</strong></p><ul><li><code>t_start</code>: (<code>::Real</code>, <code>[s]</code>, <code>=0.0</code>) start time</li><li><code>t_end</code>: (<code>::Real</code>, <code>[s]</code>, <code>=1.0</code>) end time</li></ul><p><strong>Returns</strong></p><ul><li><code>timerange</code>: (<code>::TimeCurve</code>) TimeCurve struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; timerange = TimeRange(t_start=0.6, t_end=1.4)</code></pre><p><img src="../../assets/time-range.svg" alt="Time Range"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/TimeCurve.jl#L72-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.Periodic"><a class="docstring-binding" href="#KomaMRIBase.Periodic"><code>KomaMRIBase.Periodic</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">periodic = Periodic(period, asymmetry)</code></pre><p>The <code>Periodic</code> function is a custom constructor for the <code>TimeCurve</code> struct. It allows defining time intervals that repeat periodically with a triangular period.  It includes a measure of asymmetry in order to recreate a asymmetric period.</p><p><strong>Arguments</strong></p><ul><li><code>period</code>: (<code>::Real</code>, <code>[s]</code>, <code>=1.0</code>) period duration</li><li><code>asymmetry</code>: (<code>::Real</code>, <code>=0.5</code>) temporal asymmetry factor. Between 0 and 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>periodic</code>: (<code>::TimeCurve</code>) TimeCurve struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; periodic = Periodic(period=1.0, asymmetry=0.2)</code></pre><p><img src="../../assets/periodic.svg" alt="Periodic"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/TimeCurve.jl#L96-L115">source</a></section></details></article><h3 id="AbstractSpinSpan-types"><a class="docs-heading-anchor" href="#AbstractSpinSpan-types"><code>AbstractSpinSpan</code> types</a><a id="AbstractSpinSpan-types-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractSpinSpan-types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.AllSpins"><a class="docstring-binding" href="#KomaMRIBase.AllSpins"><code>KomaMRIBase.AllSpins</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">allspins = AllSpins()</code></pre><p>AllSpins struct. It is a specialized type that inherits from AbstractSpinSpan and is used to cover all the spins of a phantom.</p><p><strong>Returns</strong></p><ul><li><code>allspins</code>: (<code>::AllSpins</code>) AllSpins struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; allspins = AllSpins()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/SpinSpan.jl#L5-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.SpinRange"><a class="docstring-binding" href="#KomaMRIBase.SpinRange"><code>KomaMRIBase.SpinRange</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">spinrange = SpinRange(range)</code></pre><p>SpinRange struct. It is a specialized type that inherits from AbstractSpinSpan and is used to select a certain range and number of spins.</p><p><strong>Arguments</strong></p><ul><li><code>range</code>: (<code>::AbstractVector</code>) spin id&#39;s. This argument can be a Range, a Vector or a BitVector</li></ul><p><strong>Returns</strong></p><ul><li><code>spinrange</code>: (<code>::SpinRange</code>) SpinRange struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spinrange = SpinRange(1:10)
julia&gt; spinrange = SpinRange([1, 3, 5, 7])
julia&gt; spinrange = SpinRange(obj.x .&gt; 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/SpinSpan.jl#L27-L45">source</a></section></details></article><h2 id="Sequence-related-functions"><a class="docs-heading-anchor" href="#Sequence-related-functions"><code>Sequence</code>-related functions</a><a id="Sequence-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence-related-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.Sequence"><a class="docstring-binding" href="#KomaMRIBase.Sequence"><code>KomaMRIBase.Sequence</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">seq = Sequence()
seq = Sequence(GR)
seq = Sequence(GR, RF)
seq = Sequence(GR, RF, ADC)
seq = Sequence(GR, RF, ADC, DUR)
seq = Sequence(GR::Array{Grad,1})
seq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})
seq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)</code></pre><p>The Sequence struct. It contains events of an MRI sequence. Most field names (except for the DEF field) consist of matrices or vectors, where each column index represents a sequence block. This struct serves as an input for the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>GR</code>: (<code>::Matrix{Grad}</code>) gradient matrix. Rows for x-y-z amplitudes and columns are for blocks</li><li><code>RF</code>: (<code>::Matrix{RF}</code>) RF matrix. The 1 row is for the coil and columns are for blocks</li><li><code>ADC</code>: (<code>::Array{ADC,1}</code>) ADC block vector</li><li><code>DUR</code>: (<code>::Vector</code>, <code>[s]</code>) duration block vector</li><li><code>DEF</code>: (<code>::Dict{String, Any}</code>) dictionary with relevant information of the sequence.   Possible keys could be [<code>&quot;AdcRasterTime&quot;</code>, <code>&quot;GradientRasterTime&quot;</code>, <code>&quot;Name&quot;</code>, <code>&quot;Nz&quot;</code>,   <code>&quot;Num_Blocks&quot;</code>, <code>&quot;Nx&quot;</code>, <code>&quot;Ny&quot;</code>, <code>&quot;PulseqVersion&quot;</code>, <code>&quot;BlockDurationRaster&quot;</code>,   <code>&quot;FileName&quot;</code>, <code>&quot;RadiofrequencyRasterTime&quot;</code>]</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.dur"><a class="docstring-binding" href="#KomaMRIBase.dur"><code>KomaMRIBase.dur</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = dur(x::Grad)
y = dur(x::Vector{Grad})
y = dur(x::Matrix{Grad})</code></pre><p>Duration time in [s] of Grad struct or Grad Array.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Grad</code> or <code>::Vector{Grad}</code> or <code>::Matrix{Grad}</code>) Grad struct or Grad Array</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Float64</code>, <code>[s]</code>) duration of the Grad struct or Grad Array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L229-L241">source</a></section><section><div><pre><code class="language-julia hljs">y = dur(x::RF)
y = dur(x::Vector{RF})
y = dur(x::Matrix{RF})</code></pre><p>Duration time in [s] of RF struct or RF Array.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code> or <code>::Vector{RF}</code> or <code>::Matrix{RF}</code>) RF struct or RF array</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Float64</code>, [<code>s</code>]) duration of the RF struct or RF array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/RF.jl#L131-L143">source</a></section><section><div><pre><code class="language-julia hljs">T = dur(x::Sequence)</code></pre><p>The total duration of the sequence in [s].</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) total duration of the sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L270-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_block_start_times"><a class="docstring-binding" href="#KomaMRIBase.get_block_start_times"><code>KomaMRIBase.get_block_start_times</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">T0 = get_block_start_times(seq::Sequence)</code></pre><p>Returns a vector containing the start times of blocks in a sequence. The initial time is always zero, and the final time corresponds to the duration of the sequence.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>T0</code>: (<code>::Vector</code>, <code>[s]</code>) start times of the blocks in a sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L283-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_flip_angles"><a class="docstring-binding" href="#KomaMRIBase.get_flip_angles"><code>KomaMRIBase.get_flip_angles</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = get_flip_angles(x::Sequence)</code></pre><p>Returns all the flip angles of the RF pulses in the sequence <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Float64}</code>, <code>[deg]</code>) flip angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L407-L417">source</a></section></details></article><h3 id="Grad"><a class="docs-heading-anchor" href="#Grad"><code>Grad</code></a><a id="Grad-1"></a><a class="docs-heading-anchor-permalink" href="#Grad" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.Grad"><a class="docstring-binding" href="#KomaMRIBase.Grad"><code>KomaMRIBase.Grad</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">gr = Grad(A, T)
gr = Grad(A, T, rise)
gr = Grad(A, T, rise, delay)
gr = Grad(A, T, rise, fall, delay)
gr = Grad(A, T, rise, fall, delay, first, last)</code></pre><p>The Grad struct represents a gradient of a sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: (<code>::Real</code> or <code>::Vector</code>, <code>[T/m]</code>) amplitude of the gradient</li><li><code>T</code>: (<code>::Real</code> or <code>::Vector</code>, <code>[s]</code>) duration of the flat-top</li><li><code>rise</code>: (<code>::Real</code>, <code>[s]</code>) duration of the rise</li><li><code>fall</code>: (<code>::Real</code>, <code>[s]</code>) duration of the fall</li><li><code>delay</code>: (<code>::Real</code>, <code>[s]</code>) duration of the delay</li></ul><p><strong>Returns</strong></p><ul><li><code>gr</code>: (<code>::Grad</code>) gradient struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gr = Grad(1, 1, 0.1, 0.1, 0.2)

julia&gt; seq = Sequence([gr]); plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L52-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.Grad-Tuple{Function, Real, Int64}"><a class="docstring-binding" href="#KomaMRIBase.Grad-Tuple{Function, Real, Int64}"><code>KomaMRIBase.Grad</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gr = Grad(f::Function, T::Real, N::Integer; delay::Real)</code></pre><p>Generates an arbitrary gradient waveform defined by the function <code>f</code> in the interval t ‚àà [0,<code>T</code>]. The time separation between two consecutive samples is given by T/(N-1).</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: (<code>::Function</code>) function that describes the gradient waveform</li><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) duration of the gradient waveform</li><li><code>N</code>: (<code>::Integer</code>, <code>=300</code>) number of samples of the gradient waveform</li></ul><p><strong>Keywords</strong></p><ul><li><code>delay</code>: (<code>::Real</code>, <code>=0</code>, <code>[s]</code>) delay time of the waveform</li></ul><p><strong>Returns</strong></p><ul><li><code>gr</code>: (<code>::Grad</code>) gradient struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gx = Grad(t -&gt; sin(œÄ*t / 0.8), 0.8)

julia&gt; seq = Sequence([gx]); plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L93-L116">source</a></section></details></article><h3 id="RF"><a class="docs-heading-anchor" href="#RF"><code>RF</code></a><a id="RF-1"></a><a class="docs-heading-anchor-permalink" href="#RF" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.RF"><a class="docstring-binding" href="#KomaMRIBase.RF"><code>KomaMRIBase.RF</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">rf = RF(A, T)
rf = RF(A, T, Œîf)
rf = RF(A, T, Œîf, delay)</code></pre><p>The RF struct represents a Radio Frequency excitation of a sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: (<code>::Complex</code>, <code>[T]</code>) RF complex amplitud modulation (AM), <span>$B_1(t) = |B_1(t)|   e^{i\phi(t)} = B_{1}(t) + iB_{1,y}(t)$</span></li><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) RF duration</li><li><code>Œîf</code>: (<code>::Real</code> or <code>::Vector</code>, <code>[Hz]</code>) RF frequency difference with respect to the Larmor frequency.   This can be a number but also a vector to represent frequency modulated signals (FM).</li><li><code>delay</code>: (<code>::Real</code>, <code>[s]</code>) RF delay time</li><li><code>center</code>: (<code>::Real</code>, <code>[s]</code>) RF center time</li><li><code>use</code>: (<code>::RFUse</code>) RF use type</li></ul><p><strong>Returns</strong></p><ul><li><code>rf</code>: (<code>::RF</code>) the RF struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rf = RF(1, 1, 0, 0.2)

julia&gt; seq = Sequence(); seq += rf; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/RF.jl#L18-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.RF-Tuple{Function, Real, Int64}"><a class="docstring-binding" href="#KomaMRIBase.RF-Tuple{Function, Real, Int64}"><code>KomaMRIBase.RF</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rf = RF_fun(f::Function, T::Real, N::Int64)</code></pre><p>Generate an RF sequence with amplitudes sampled from a function waveform.</p><div class="admonition is-info" id="Note-de33b933ca2948f8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-de33b933ca2948f8" title="Permalink"></a></header><div class="admonition-body"><p>This function is not being used in this KomaMRI version.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>f</code>: (<code>::Function</code>, [<code>T</code>]) function for the RF amplitud waveform</li><li><code>T</code>: (<code>::Real</code>, [<code>s</code>]) duration of the RF pulse</li><li><code>N</code>: (<code>::Int64</code>) number of samples of the RF pulse</li></ul><p><strong>Returns</strong></p><ul><li><code>rf</code>:(<code>::RF</code>) RF struct with amplitud defined by the function <code>f</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/RF.jl#L148-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_flip_angle"><a class="docstring-binding" href="#KomaMRIBase.get_flip_angle"><code>KomaMRIBase.get_flip_angle</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Œ± = get_flip_angle(x::RF)</code></pre><p>Calculates the flip angle Œ± [deg] of an RF struct. Œ± = Œ≥ ‚à´ B1(œÑ) dœÑ</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code>) RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>Œ±</code>: (<code>::Int64</code>, <code>[deg]</code>) flip angle RF struct <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/RF.jl#L170-L180">source</a></section></details></article><h3 id="ADC"><a class="docs-heading-anchor" href="#ADC"><code>ADC</code></a><a id="ADC-1"></a><a class="docs-heading-anchor-permalink" href="#ADC" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.ADC"><a class="docstring-binding" href="#KomaMRIBase.ADC"><code>KomaMRIBase.ADC</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">adc = ADC(N, T)
adc = ADC(N, T, delay)
adc = ADC(N, T, delay, Œîf, œï)</code></pre><p>The ADC struct represents the Analog to Digital Converter (ADC) of a sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: (<code>::Int64</code>) number of acquired samples</li><li><code>T</code>: (<code>::Float64</code>, [<code>s</code>]) duration to acquire the samples</li><li><code>delay</code>: (<code>::Float64</code>, [<code>s</code>]) delay time to start the acquisition</li><li><code>Œîf</code>: (<code>::Float64</code>, [<code>Hz</code>]) delta frequency. It is meant to compensate RF pulse phases</li><li><code>œï</code>: (<code>::Float64</code>, <code>[rad]</code>) phase. It is meant to compensate RF pulse phases</li></ul><p><strong>Returns</strong></p><ul><li><code>adc</code>: (<code>::ADC</code>) ADC struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; adc = ADC(16, 1, 0.1)

julia&gt; seq = Sequence(); seq += adc; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/ADC.jl#L1-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_adc_sampling_times"><a class="docstring-binding" href="#KomaMRIBase.get_adc_sampling_times"><code>KomaMRIBase.get_adc_sampling_times</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">times = get_adc_sampling_times(seq)</code></pre><p>Returns an array of times when the samples of the sequence <code>seq</code> are acquired.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>times</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) time array when samples are acquired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/ADC.jl#L73-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_adc_phase_compensation"><a class="docstring-binding" href="#KomaMRIBase.get_adc_phase_compensation"><code>KomaMRIBase.get_adc_phase_compensation</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">comp = get_adc_phase_compensation(seq)</code></pre><p>Returns an array of phase compensation factors, <span>$\exp(-\mathrm{i}\varphi)$</span>, which are used to compensate the acquired signal <span>$S$</span> by applying the operation <span>$S_{\mathrm{comp}} = S \exp(-\mathrm{i}\varphi)$</span> after the simulation. This compensation is necessary because the signal typically exhibits a phase offset of <span>$\varphi$</span> following RF excitation with a phase of <span>$\varphi$</span>. Such pulses are commonly employed in sequences involving RF spoiling.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>comp</code>: (<code>::Vector{Complex}</code>, <code>[rad]</code>) array of phase compensations for every acquired sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/ADC.jl#L98-L113">source</a></section></details></article><h3 id="Delay"><a class="docs-heading-anchor" href="#Delay"><code>Delay</code></a><a id="Delay-1"></a><a class="docs-heading-anchor-permalink" href="#Delay" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.Delay"><a class="docstring-binding" href="#KomaMRIBase.Delay"><code>KomaMRIBase.Delay</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">delay = Delay(T)</code></pre><p>The Delay struct is meant to add a delay to a sequence by using a sum operator.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) time delay value</li></ul><p><strong>Returns</strong></p><ul><li><code>delay</code>: (<code>::Delay</code>) delay struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; delay = Delay(0.5)

julia&gt; s = Sequence([Grad(1, 1, 0.1)])

julia&gt; seq = delay + s; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Delay.jl#L1-L20">source</a></section></details></article><h3 id="Rotation-matrices"><a class="docs-heading-anchor" href="#Rotation-matrices">Rotation matrices</a><a id="Rotation-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-matrices" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.rotx"><a class="docstring-binding" href="#KomaMRIBase.rotx"><code>KomaMRIBase.rotx</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Rx = rotx(Œ∏::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the x-axis.</p><p><strong>Arguments</strong></p><ul><li><code>Œ∏</code>: (<code>::Real</code>, <code>[rad]</code>) rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Rx</code>: (<code>::Matrix{Int64}</code>) rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.roty"><a class="docstring-binding" href="#KomaMRIBase.roty"><code>KomaMRIBase.roty</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Ry = roty(Œ∏::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the y-axis.</p><p><strong>Arguments</strong></p><ul><li><code>Œ∏</code>: (<code>::Real</code>, <code>[rad]</code>) rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Ry</code>: (<code>::Matrix{Int64}</code>) rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L18-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.rotz"><a class="docstring-binding" href="#KomaMRIBase.rotz"><code>KomaMRIBase.rotz</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Rz = rotz(Œ∏::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the z-axis.</p><p><strong>Arguments</strong></p><ul><li><code>Œ∏</code>: (<code>::Real</code>, <code>[rad]</code>) rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Rz</code>: (<code>::Matrix{Int64}</code>) rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/sequence/Grad.jl#L35-L45">source</a></section></details></article><h3 id="Moments"><a class="docs-heading-anchor" href="#Moments">Moments</a><a id="Moments-1"></a><a class="docs-heading-anchor-permalink" href="#Moments" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_Mk"><a class="docstring-binding" href="#KomaMRIBase.get_Mk"><code>KomaMRIBase.get_Mk</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Mk, Mk_adc = get_Mk(seq::Sequence, k; Œît=1)</code></pre><p>Computes the <span>$k$</span>th-order moment of the Sequence <code>seq</code> given by the formula <span>$\int_0^T t^k G(t) dt$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li><li><code>k</code>: (<code>::Integer</code>) order of the moment to be computed</li><li><code>Œît</code>: (<code>::Real</code>, <code>=1</code>, <code>[s]</code>) nominal delta time separation between two time samples   for ADC acquisition and Gradients</li></ul><p><strong>Returns</strong></p><ul><li><code>Mk</code>: (<code>3-column ::Matrix{Real}</code>) <span>$k$</span>th-order moment</li><li><code>Mk_adc</code>: (<code>3-column ::Matrix{Real}</code>) <span>$k$</span>th-order moment sampled at ADC times</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L448-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_kspace"><a class="docstring-binding" href="#KomaMRIBase.get_kspace"><code>KomaMRIBase.get_kspace</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Computes the k-space trajectory of the Sequence <code>seq</code>. Refer to <a href="#KomaMRIBase.get_Mk"><code>get_Mk</code></a> and <a href="#KomaMRIBase.get_M0"><code>get_M0</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L500-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_M0"><a class="docstring-binding" href="#KomaMRIBase.get_M0"><code>KomaMRIBase.get_M0</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Computes the zero-order moment of the Sequence <code>seq</code>. Refer to <a href="#KomaMRIBase.get_Mk"><code>get_Mk</code></a> and <a href="#KomaMRIBase.get_kspace"><code>get_kspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L506-L509">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_M1"><a class="docstring-binding" href="#KomaMRIBase.get_M1"><code>KomaMRIBase.get_M1</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Computes the 1st-order moment of the Sequence <code>seq</code>. Refer to <a href="#KomaMRIBase.get_Mk"><code>get_Mk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L512-L515">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_M2"><a class="docstring-binding" href="#KomaMRIBase.get_M2"><code>KomaMRIBase.get_M2</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p>Computes the 2nd-order moment of the Sequence <code>seq</code>. Refer to <a href="#KomaMRIBase.get_Mk"><code>get_Mk</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L518-L521">source</a></section></details></article><h3 id="Event-checks"><a class="docs-heading-anchor" href="#Event-checks">Event checks</a><a id="Event-checks-1"></a><a class="docs-heading-anchor-permalink" href="#Event-checks" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_RF_on"><a class="docstring-binding" href="#KomaMRIBase.is_RF_on"><code>KomaMRIBase.is_RF_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_RF_on(x::Sequence)
y = is_RF_on(x::Sequence, t::Vector{Float64})</code></pre><p>Tells if the sequence <code>seq</code> has elements with RF active, or active during time <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) time to check</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the RF in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L176-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_GR_on"><a class="docstring-binding" href="#KomaMRIBase.is_GR_on"><code>KomaMRIBase.is_GR_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_GR_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the GR in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L205-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_Gx_on"><a class="docstring-binding" href="#KomaMRIBase.is_Gx_on"><code>KomaMRIBase.is_Gx_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_Gx_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in x direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the GRx in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L218-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_Gy_on"><a class="docstring-binding" href="#KomaMRIBase.is_Gy_on"><code>KomaMRIBase.is_Gy_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_Gy_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in y direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the GRy in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L231-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_Gz_on"><a class="docstring-binding" href="#KomaMRIBase.is_Gz_on"><code>KomaMRIBase.is_Gz_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_Gz_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in z direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the GRz in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L244-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.is_ADC_on"><a class="docstring-binding" href="#KomaMRIBase.is_ADC_on"><code>KomaMRIBase.is_ADC_on</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = is_ADC_on(x::Sequence)
y = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})</code></pre><p>Tells if the sequence <code>seq</code> has elements with ADC active, or active during time <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) sequence struct</li><li><code>t</code>: (<code>::Union{Array{Float64,1}, Array{Float64,2}}</code>, <code>[s]</code>) time to check</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) boolean that tells whether or not the ADC in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L147-L159">source</a></section></details></article><h3 id="DiscreteSequence"><a class="docs-heading-anchor" href="#DiscreteSequence"><code>DiscreteSequence</code></a><a id="DiscreteSequence-1"></a><a class="docs-heading-anchor-permalink" href="#DiscreteSequence" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.DiscreteSequence"><a class="docstring-binding" href="#KomaMRIBase.DiscreteSequence"><code>KomaMRIBase.DiscreteSequence</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">seqd = DiscreteSequence(Gx, Gy, Gz, B1, Œîf, ADC, t, Œît)</code></pre><p>A sampled version of a Sequence struct, containing vectors for event amplitudes at specified times. DiscreteSequence is the struct used for simulation.</p><p><strong>Arguments</strong></p><ul><li><code>Gx</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[T/m]</code>) x-gradient vector</li><li><code>Gy</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[T/m]</code>) y-gradient vector</li><li><code>Gz</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[T/m]</code>) z-gradient vector</li><li><code>B1</code>: (<code>::AbstractVector{Complex{T&lt;:Real}}</code>, <code>[T]</code>) RF amplitude vector</li><li><code>Œîf</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[Hz]</code>) RF carrier frequency displacement vector</li><li><code>ADC</code>: (<code>::AbstractVector{Bool}</code>) ADC sample vector</li><li><code>t</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[s]</code>) time vector</li><li><code>Œît</code>: (<code>::AbstractVector{T&lt;:Real}</code>, <code>[s]</code>) delta time vector</li></ul><p><strong>Returns</strong></p><ul><li><code>seqd</code>: (<code>::DiscreteSequence</code>) DiscreteSequence struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/simulation/DiscreteSequence.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.discretize"><a class="docstring-binding" href="#KomaMRIBase.discretize"><code>KomaMRIBase.discretize</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seqd = discretize(seq::Sequence; sampling_params=default_sampling_params())</code></pre><p>This function returns a sampled Sequence struct with RF and gradient time refinements based on simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) sequence</li></ul><p><strong>Keywords</strong></p><ul><li><code>sampling_params</code>: (<code>::Dict{String, Any}</code>, <code>=default_sampling_params()</code>) sampling   parameter dictionary</li></ul><p><strong>Returns</strong></p><ul><li><code>seqd</code>: (<code>::DiscreteSequence</code>) DiscreteSequence struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/simulation/DiscreteSequence.jl#L72-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.get_samples"><a class="docstring-binding" href="#KomaMRIBase.get_samples"><code>KomaMRIBase.get_samples</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">samples = get_samples(seq::Sequence; off_val=0, max_rf_samples=Inf)</code></pre><p>Returns the samples of the events in <code>seq</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>off_val</code>: (<code>::Number</code>, <code>=0</code>) offset value for amplitude. Typically used to hide points in   plots by setting it to <code>Inf</code></li><li><code>max_rf_samples</code>: (<code>::Integer</code>, <code>=Inf</code>) maximum number of samples for the RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>samples</code>: (<code>::NamedTuple</code>) contains samples for <code>gx</code>, <code>gy</code>, <code>gz</code>, <code>rf</code>, and <code>adc</code> events.   Each event, represented by <code>e::NamedTuple</code>, includes time samples (<code>e.t</code>) and amplitude   samples (<code>e.A</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/datatypes/Sequence.jl#L297-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.times"><a class="docstring-binding" href="#KomaMRIBase.times"><code>KomaMRIBase.times</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">t = times(gr::Grad)
t = times(rf::RF)
t = times(adc::ADC)</code></pre><p>Get time samples of MRI sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>gr</code>: (<code>::Grad</code>) Gradient struct</li><li><code>rf</code>: (<code>::RF</code>) RF struct</li><li><code>adc</code>: (<code>::ADC</code>) ADC struct</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Number}</code>) vector with time samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/KeyValuesCalculation.jl#L74-L88">source</a></section><section><div><p>times &amp; unit_time </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/TimeCurve.jl#L131">source</a></section><section><div><pre><code class="language-julia hljs">times = times(motion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/motion/MotionList.jl#L165-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.ampls"><a class="docstring-binding" href="#KomaMRIBase.ampls"><code>KomaMRIBase.ampls</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">A = ampls(g::Grad)
A = ampls(r::RF)
A = ampls(d::ADC)</code></pre><p>Get amplitude samples of MRI sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>gr</code>: (<code>::Grad</code>) Gradient struct</li><li><code>rf</code>: (<code>::RF</code>) RF struct</li><li><code>adc</code>: (<code>::ADC</code>) ADC struct</li></ul><p><strong>Returns</strong></p><ul><li><code>A</code>: (<code>::Vector{Number}</code>) vector with amplitude samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/KeyValuesCalculation.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.freqs"><a class="docstring-binding" href="#KomaMRIBase.freqs"><code>KomaMRIBase.freqs</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">f = freqs(r::RF)</code></pre><p>Get frequency samples of MRI sequence event.</p><p><strong>Arguments</strong></p><ul><li><code>rf</code>: (<code>::RF</code>) RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>f</code>: (<code>::Vector{Number}</code>) vector with frequency samples</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/KeyValuesCalculation.jl#L44-L54">source</a></section></details></article><h3 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="KomaMRIBase.trapz"><a class="docstring-binding" href="#KomaMRIBase.trapz"><code>KomaMRIBase.trapz</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = trapz(Œît, x)</code></pre><p>Trapezoidal integration for every spin of a phantom.</p><div class="admonition is-info" id="Note-9c42128ce3b564cc"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9c42128ce3b564cc" title="Permalink"></a></header><div class="admonition-body"><p>In practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Œît for all the spins. <code>NŒît</code> is the length of <code>Œît</code>. <code>Ns</code> stands for the number of spins of a phantom. <code>x</code> is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>Œît</code>: (<code>1 x NŒît ::Matrix{Float64}</code>, <code>[s]</code>) delta time 1-row array</li><li><code>x</code>: (<code>Ns x (NŒît+1) ::Matrix{Float64}</code>, <code>[T]</code>) magnitude of the field Gx * x + Gy * y +   Gz * z</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>Ns x 1 ::Matrix{Float64}</code>, <code>[T*s]</code>) vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Œît for every spin of a phantom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/TrapezoidalIntegration.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.cumtrapz"><a class="docstring-binding" href="#KomaMRIBase.cumtrapz"><code>KomaMRIBase.cumtrapz</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">y = cumtrapz(Œît, x)</code></pre><p>Trapezoidal cumulative integration over time for every spin of a phantom.</p><p><strong>Arguments</strong></p><ul><li><code>Œît</code>: (<code>1 x NŒît ::Matrix{Float64}</code>, <code>[s]</code>) delta time 1-row array</li><li><code>x</code>: (<code>Ns x (NŒît+1) ::Matrix{Float64}</code>, <code>[T]</code>) magnitude of the field Gx * x + Gy * y +   Gz * z</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>Ns x NŒît ::Matrix{Float64}</code>, <code>[T*s]</code>) matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Œît for every spin of a   phantom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/TrapezoidalIntegration.jl#L32-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.kfoldperm"><a class="docstring-binding" href="#KomaMRIBase.kfoldperm"><code>KomaMRIBase.kfoldperm</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">array_of_ranges = kfoldperm(N, k; breaks=[])</code></pre><p>Divides a list of indices from 1 to <code>N</code> into <code>k</code> groups.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: (<code>::Integer</code>) number of elements to be ordered</li><li><code>k</code>: (<code>::Integer</code>) number of groups to divide the <code>N</code> elements.</li></ul><p><strong>Keywords</strong></p><ul><li><code>breaks</code>: (<code>::Vector{&lt;:Integer}</code>, <code>=[]</code>) array of indices where predefined breakpoints are   placed.</li></ul><p><strong>Returns</strong></p><ul><li><code>array_of_ranges</code>: (<code>::Vector{UnitRange{&lt;:Integer}}</code>) array containing ranges of different   groups. The target is <code>k</code> groups, but this could increase by adding elements to the   <code>breaks</code> input array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/timing/TimeStepCalculation.jl#L3-L20">source</a></section></details></article><h2 id="Sequence-Building-Blocks-(SBB)"><a class="docs-heading-anchor" href="#Sequence-Building-Blocks-(SBB)">Sequence Building Blocks (SBB)</a><a id="Sequence-Building-Blocks-(SBB)-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence-Building-Blocks-(SBB)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner"><code>KomaMRIBase.PulseDesigner</code></a> ‚Äî <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">PulseDesigner</code></pre><p>A module to define different pulse sequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.RF_hard"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.RF_hard"><code>KomaMRIBase.PulseDesigner.RF_hard</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seq = RF_hard(B1, T, sys; G=[0, 0, 0], Œîf=0)</code></pre><p>Returns a sequence with a RF excitation pulse.</p><p><strong>Arguments</strong></p><ul><li><code>B1</code>: (<code>::Number</code>, <code>[T]</code>) RF pulse amplitude</li><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) RF pulse duration</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>G</code>: (<code>::Vector{Real}</code>, <code>=[0, 0, 0]</code>, <code>[T/m]</code>) gradient amplitudes for x, y, z</li><li><code>Œîf</code>: (<code>::Real</code>, <code>=0</code>, <code>[Hz]</code>) RF pulse carrier frequency displacement</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct with a RF pulse</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner(); durRF = œÄ / 2 / (2œÄ * Œ≥ * sys.B1);

julia&gt; seq = PulseDesigner.RF_hard(sys.B1, durRF, sys);

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L9-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.RF_sinc"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.RF_sinc"><code>KomaMRIBase.PulseDesigner.RF_sinc</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seq = RF_sinc(B1, T, sys; G=[0, 0, 0], Œîf=0, a=0.46, TBP=4)</code></pre><p>Returns a sequence with a RF sinc waveform.</p><p><strong>References</strong></p><ul><li>Matt A. Bernstein, Kevin F. King, Xiaohong Joe Zhou, Chapter 2 - Radiofrequency Pulse</li></ul><p>Shapes, Handbook of MRI Pulse Sequences, 2004, Pages 35-66, https://doi.org/10.1016/B978-012092861-3/50006-6.</p><p><strong>Arguments</strong></p><ul><li><code>B1</code>: (<code>::Number</code>, <code>[T]</code>) RF sinc amplitude</li><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) RF sinc duration</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>G</code>: (<code>::Vector{Real}</code>, <code>=[0, 0, 0]</code>, <code>[T/m]</code>) gradient amplitudes for x, y, z</li><li><code>Œîf</code>: (<code>::Real</code>, <code>=0</code>, <code>[Hz]</code>) RF pulse carrier frequency displacement</li><li><code>a</code>: (<code>::Real</code>, <code>=0.46</code>) height appodization window parameter</li><li><code>TBP</code>: (<code>::Real</code>, <code>=4</code>) width appodization window parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct with a RF pulse</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner(); durRF = œÄ / 2 / (2œÄ * Œ≥ * sys.B1);

julia&gt; seq = PulseDesigner.RF_sinc(sys.B1, durRF, sys);

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L42-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.EPI"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.EPI"><code>KomaMRIBase.PulseDesigner.EPI</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seq = EPI(FOV::Real, N::Integer, sys::Scanner)</code></pre><p>Returns a sequence with EPI gradients.</p><p><strong>Arguments</strong></p><ul><li><code>FOV</code>: (<code>::Real</code>, <code>[m]</code>) field of view</li><li><code>N</code>: (<code>::Integer</code>) number of pixels in the x and y axis</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct with EPI gradients</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys, FOV, N = Scanner(), 23e-2, 101

julia&gt; seq = PulseDesigner.EPI(FOV, N, sys)

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L124-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.radial_base"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.radial_base"><code>KomaMRIBase.PulseDesigner.radial_base</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seq = radial_base(FOV::Real, Nr::Integer, sys::Scanner)</code></pre><p>Returns a sequence with radial gradients for a single trajectory.</p><p><strong>Arguments</strong></p><ul><li><code>FOV</code>: (<code>::Real</code>, <code>[m]</code>) field of view</li><li><code>N</code>: (<code>::Integer</code>) number of pixels along the diameter</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) Sequence struct of a single radial trajectory</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys, FOV, N = Scanner(), 23e-2, 101

julia&gt; seq = PulseDesigner.radial_base(FOV, N, sys)

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L185-L208">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.spiral_base"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.spiral_base"><code>KomaMRIBase.PulseDesigner.spiral_base</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spiral = spiral_base(FOV, N, sys; S0=sys.Smax*2/3, Nint=8, Œª=Nint/FOV, BW=60e3)</code></pre><p>Definition of a spiral base sequence.</p><p><strong>References</strong></p><ul><li>Glover, G.H. (1999), Simple analytic spiral K-space algorithm. Magn. Reson. Med.,</li></ul><p>42: 412-415. https://doi.org/10.1002/(SICI)1522-2594(199908)42:2&lt;412::AID-MRM25&gt;3.0.CO;2-U</p><p><strong>Arguments</strong></p><ul><li><code>FOV</code>: (<code>::Real</code>, <code>[m]</code>) field of view</li><li><code>N</code>: (<code>::Integer</code>) number of pixels along the radious</li><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>S0</code>: (<code>::Vector{Real}</code>, <code>=sys.Smax*2/3</code>, <code>[T/m/s]</code>) slew rate reference</li><li><code>Nint</code>: (<code>::Integer</code>, <code>=8</code>) number of interleaves</li><li><code>Œª</code>: (<code>::Real</code>, <code>=Nint/FOV</code>, <code>[1/m]</code>) kspace spiral parameter</li><li><code>BW</code>: (<code>::Real</code>, <code>=60e3</code>, <code>[Hz]</code>) adquisition parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>spiral</code>: (<code>::Function</code>) function that returns a <code>Sequence</code> struct when evaluated</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys, FOV, N = Scanner(), 23e-2, 101

julia&gt; spiral = PulseDesigner.spiral_base(FOV, N, sys)

julia&gt; seq = spiral(0)

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L234-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KomaMRIBase.PulseDesigner.EPI_example"><a class="docstring-binding" href="#KomaMRIBase.PulseDesigner.EPI_example"><code>KomaMRIBase.PulseDesigner.EPI_example</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seq = EPI_example(; sys=Scanner())</code></pre><p>Returns a sequence suitable for acquiring the 2D brain example in the provided examples.</p><p><strong>Keywords</strong></p><ul><li><code>sys</code>: (<code>::Scanner</code>) Scanner struct</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) EPI example Sequence struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq = PulseDesigner.EPI_example();

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/0ddc61cf07c7113520ff69fe5e2604b8f3774346/KomaMRIBase/src/sequences/PulseDesigner.jl#L316-L333">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1-api/">¬´ API Overview</a><a class="docs-footer-nextpage" href="../3-koma-core/">KomaMRICore ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 23:52">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
