var documenterSearchIndex = {"docs":
[{"location":"tutorial-pluto/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. \n\nFiles matching the pluto-*.jl pattern anywhere in examples/4.reproducible_notebooks will be included.\n\nAll files included in this folder will be ignored.","category":"section"},{"location":"tutorial-pluto/01-gradient-echo-spin-echo/#Understanding-basic-MRI-sequences","page":"Understanding basic MRI sequences","title":"Understanding basic MRI sequences","text":"(Image: ) (Image: )\n\n<iframe type=\"text/html\" src=\"../01-gradient-echo-spin-echo.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"section"},{"location":"tutorial/06-DiffusionMotion/#Diffusion-induced-Signal-Attenuation","page":"Diffusion-induced Signal Attenuation","title":"Diffusion-induced Signal Attenuation","text":"(Image: ) (Image: ) (Image: )\n\nThe purpose of this tutorial is to showcase the simulation of diffusion-related effects. For this, we are going to define a path motion to simulate the Brownian motion of spins. This is not the most efficient way of simulating diffusion, but it is a good way to understand the phenomenon. In particular, we will going to simulate isotropic diffusion, characterized by the Apparent Diffusion Coefficient (ADC).","category":"section"},{"location":"tutorial/06-DiffusionMotion/#Creating-a-phantom-with-isotropic-diffusion","page":"Diffusion-induced Signal Attenuation","title":"Creating a phantom with isotropic diffusion","text":"First we will define a Phantom without motion containing 10000 spins. The spins will have the same relaxation times T_1 = 1000mathrmms and T_2 = 100mathrmms, and will be placed at the origin.\n\nNspins = 10_000\nobj = Phantom(;\n    x  = zeros(Nspins),\n    T1 = ones(Nspins) * 1000e-3,\n    T2 = ones(Nspins) * 100e-3,\n);\n\nNow we will define the Brownian motion of the spins using the path motion definition. The motion will be defined by the displacements in the x, y, and z directions (dx, dy, and dz) of the spins. The displacements will be generated by a random walk with mean square displacement\n\nmathbbEleftx^2right=2D Δt\n\nwhere D is the diffusion coefficient and Δt is time step duration.\n\nD = 2e-9                # Diffusion Coefficient of water in m^2/s\nT = 100e-3              # Duration of the motion\nNt = 100                # Number of time steps\nΔt = T / (Nt - 1)       # Time sep\nΔr = sqrt(2 * D * Δt);  # √ Mean square displacement\n\nRandom walk is defined as the cumulative sum of random displacements:\n\nrng = MersenneTwister(1234) # Setting up the random seed\ndx = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2)\ndy = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2)\ndz = cumsum([zeros(Nspins) Δr .* randn(rng, Nspins, Nt - 1)]; dims=2);\n\nIncluding the random_walk into the Phantom definition:\n\nrandom_walk = KomaMRI.path(dx, dy, dz, TimeRange(0.0, T))\nobj.motion = random_walk\np1 = plot_phantom_map(obj, :T1; time_samples=Nt÷4, height=450)\n\n<center><object type=\"text/html\" data=\"../../assets/6-displacements.html\" style=\"width:85%; height:470px;\"></object></center>\n\nThe plot shows the random walk of spins due to diffusion, also known as Brownian motion. This motion was named after Robert Brown, who first described the phenomenon in 1827 while looking at pollen suspended in water under a microscope.","category":"section"},{"location":"tutorial/06-DiffusionMotion/#Pulse-Gradient-Spin-Echo-(PGSE)-sequence","page":"Diffusion-induced Signal Attenuation","title":"Pulse Gradient Spin Echo (PGSE) sequence","text":"The classical sequence used to measure diffusion is the pulse gradient spin echo (PGSE) introduced by Stejskal and Tanner in 1965. This sequence is characterized by the use of two diffusion gradients, placed right before and right after the inversion RF pulse. The duration of each gradient is defined by the δ parameter and the distance between the beginning of both gradients is described by the Δ parameter. In this tutorial square-shaped gradients will be used.\n\nFirst, we generate the RF pulses:\n\nsys   = Scanner()\ndurRF = 1e-3\nB1    = (π / 2) / (2π * γ * durRF)\nrf90  = PulseDesigner.RF_hard(B1, durRF, sys)\nrf180 = (0.0 + 2im) * rf90;\n\nNow we generate the gradients:\n\nG = 30e-3            # Gradient amplitude\nδ = 30e-3            # Duration of the gradient\nΔ = durRF + δ        # Time between the two gradients\ngx_diff = Grad(G, δ);\n\nFinally, we generate the ADC:\n\nadc_dwell_time = 1e-6\nadc = ADC(1, adc_dwell_time, durRF/2 - adc_dwell_time/2); # ADCs with N=1 are positioned at the center\n\nObtaining the PGSE sequence:\n\nseq = Sequence()\nseq += rf90\nseq += gx_diff\nseq += rf180\nseq += gx_diff\nseq += adc\np2 = plot_seq(seq; show_adc=true) # Plotting the sequence\n\n<center><object type=\"text/html\" data=\"../../assets/6-pgse_sequence.html\" style=\"width:100%; height:300px;\"></object></center>\n\nFor the isotropic diffusion, the signal attenuation is given by the Stejskal-Tanner formula:\n\nE = expleft(-b Dright)\n\nwhere (b) is the b-value, defined as:\n\nb = (gamma G delta)^2 cdot left(Delta - delta3right)\n\nwhere gamma is the gyromagnetic ratio, G is the gradient amplitude, delta is the gradient duration, and Delta is the time between the two gradients.\n\nfunction bvalue(seq)\n    block, axis = 2, 1 # Gx from second block\n    G = seq.GR[axis, block].A\n    δ = seq.GR[axis, block].T\n    Δ = dur(seq[2:3]) # Because there are no gaps\n    b = (2π * γ * G * δ)^2 * (Δ - δ/3)\n    return b * 1e-6\nend;","category":"section"},{"location":"tutorial/06-DiffusionMotion/#Diffusion-Weighted-Imaging-(DWI)","page":"Diffusion-induced Signal Attenuation","title":"Diffusion Weighted Imaging (DWI)","text":"For DWI, multiple b-values are acquired to determine the tissue's ADC. For this, we will scale the gradient's amplitude of the previous sequence to obtain a desired b-value. We will store the sequences in a vector seqs and simulate the signal for each one of them.\n\nseqs = Sequence[] # Vector of sequences\nbvals = [0, 250, 500, 1000, 1500, 2000] # b-values in s/mm^2\nfor bval_target in bvals\n    gradient_scaling = sqrt(bval_target / bvalue(seq))\n    seq_b = gradient_scaling * seq\n    push!(seqs, seq_b)\nend\n\nTo simulate, we will broadcast the simulate function over the sequences and store the signals in a vector Sb. The Ref's are used to avoid broadcasting the obj and sys arguments (they will remain constant for all seqs).\n\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"Δt\"] = Δt; # Set max. grad. time step to fit diffusion time step\n\nsignals = @suppress simulate.(Ref(obj), seqs, Ref(sys); sim_params); # simulate broadcasted over seqs\n\nSb = [sb[1] for sb in signals] # Reshaping the simulated signals\nbvals_si = bvals .* 1e6; # Convert b-values from s/mm^2 to s/m^2\n\nE_simulated   = abs.(Sb) ./ abs.(Sb[1])\nE_theoretical = exp.(-bvals_si .* D);\n\n<center><object type=\"text/html\" data=\"../../assets/6-pgse_signal_attenuation.html\" style=\"width:80%; height:400px;\"></object></center>\n\nThe plot shows the signal attenuation as a function of the b-value. The simulated signal attenuation matches the theoretical curve, showing the expected exponential decay with the b-value.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"explanation/6-simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"explanation/6-simulation/#General-Overview","page":"Simulation","title":"General Overview","text":"KomaMRI simulates the magnetization of each spin of a Phantom for variable magnetic fields given by a Sequence. It is assumed that a single spin is independent of the state of the other spins in the system (a key feature that enables parallelization). Furthermore, there are defined two regimes in the Sequence: excitation and precession. During the latter, the excitation fields are nulled and are useful for simplifying some physical equations.\n\nThe are more internal considerations in the KomaMRI implementation. The Figure 1 summarizes the functions called to perform the simulation.\n\n<center><img width=\"100%\" src=\"../../assets/koma-solution.svg\"></center>\n\nFigure 1: The sequence seq is discretized after calculating the required time points in the wrapper function simulate. The time points are then divided into Nblocks to reduce the amount of memory used. The phantom obj is divided into Nthreads, and KomaMRI will use either run_spin_excitation! or run_spin_precession! depending on the regime. If an ADC object is present, the simulator will add the signal contributions of each thread to construct the acquired signal sig[t]. All the parameters: Nthreads, Nblocks, Δt_rf, and Δt, are passed through a dictionary called sim_params as an optional parameter of the simulate function.\n\nFrom the programming perspective, it is needed to call the simulate function with the sim_params dictionary keyword argument. A user can change the values of the following keys:\n\nParameter Description\n\"return_type\" defines the output of the simulate function. Possible values are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco RawAcquisitionData, the signal values, and the last magnetization state of the simulation, respectively.\n\"sim_method\" defines the type of simulation. The default value is Bloch(), but you can alternatively use the BlochDict() simulation method. Moreover, you have the flexibility to create your own methods without altering the KomaMRI source code; for further details, refer to the Simulation Method Extensibility section.\n\"Δt\" raster time for gradients.\n\"Δt_rf\" raster time for RFs.\n\"precision\" defines the floating-point simulation precision. You can choose between \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively. It's important to note that, especially for GPU operations, using \"f32\" is generally much faster.\n\"Nblocks\" divides the simulation into a specified number of time blocks. This parameter is designed to conserve RAM resources, as KomaMRI computes a series of simulations consecutively, each with the specified number of blocks determined by the value of \"Nblocks\".\n\"Nthreads\" divides the Phantom into a specified number of threads. Because spins are modeled independently of each other, KomaMRI can solve simulations in parallel threads, speeding up the execution time.\n\"gpu\" is a boolean that determines whether to use GPU or CPU hardware resources, as long as they are available on the host computer.\n\"gpu_device\" sets the index ID of the available GPU in the host computer.\n\nFor instance, if you want to perform a simulation on the CPU with float64 precision using the BlochDict() method (assuming you have already defined obj, seq and sys), you can do so like this:\n\n# Set non-default simulation parameters and run simulation\nsim_params = KomaMRICore.default_sim_params() \nsim_params[\"gpu\"] = false\nsim_params[\"precision\"] = \"f64\"\nsim_params[\"sim_method\"] = BlochDict()\nraw = simulate(obj, seq, sys; sim_params)\n\nAdditionally, the user must be aware of the functions run_spin_excitation! and run_spin_precession! which defines the algorithm for excitation and precession regimes respectively and can be changed by the user without modifying the source code (more details at Simulation Method Extensibility).\n\nPrevious simulation, the Sequence is discretized to consider specific time points which are critical for simulation. The user can control the time between intermediate gradient samples with the parameter Δt. Similarly, the parameter Δt_rf manages the time between RF samples, and can be relatively large for 2D imaging where the slice profile is less relevant.","category":"section"},{"location":"explanation/6-simulation/#Computation-Efficiency","page":"Simulation","title":"Computation Efficiency","text":"To reduce the memory usage of our simulator, we subdivided time into Nblocks. KomaMRI classifies each block in either the excitation regime or the precession regime before the simulation.\n\nWe increased the simulation speed by separating the calculations into Nthreads and then performing the GPU parallel operations with CUDA.jl . This separation is possible as all magnetization vectors are independent of one another.","category":"section"},{"location":"explanation/6-simulation/#Simulation-Method-Extensibility","page":"Simulation","title":"Simulation Method Extensibility","text":"In Julia, functions use different methods based on the input types via multiple dispatch. We used this to specialize the simulation functions for a given sim_method <:SimulationMethod specified in sim_params. For a given simulation method, the function initialize_spin_state outputs a variable Xt <: SpinStateRepresentation that is passed through the simulation (Figure 1). For the default simulation method Bloch, the spin state is of type Mag, but can be extended to a custom representation, like for example EPGs44 or others. Then, the functions run_spin_excitation! and run_spin_precession! can be described externally for custom types sim_method and Xt, extending Koma’s functionalities without the need of modifying the source code and taking advantage of all of Koma’s features.","category":"section"},{"location":"explanation/6-simulation/#Bloch-Simulation-Method","page":"Simulation","title":"Bloch Simulation Method","text":"This is the default simulation method used by KomaMRI, however it can always be specified by setting the sim_method = Bloch() entry of the sim_params dictionary. In the following subsection, we will explain the physical and mathematical background and some considerations and assumptions that enables to speed up the simulation.","category":"section"},{"location":"explanation/6-simulation/#Physical-and-Mathematical-Background","page":"Simulation","title":"Physical and Mathematical Background","text":"The Bloch method of KomaMRI simulates the magnetization of each spin by solving the Bloch equations in the rotating frame:\n\nbeginalign tag1\n\nfracmathrmd boldsymbolMmathrmd t =\n  gamma boldsymbolM times boldsymbolB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1 \n\nendalign\n\nwith gamma the gyromagnetic ratio, boldsymbolM = M_x M_y M_z^T the magnetization vector, and\n\nboldsymbolB = B_1x(t) B_1y(t) boldsymbolG(t) cdot boldsymbolx + Delta omega(t)^T\n\nthe effective magnetic field. M_0 is the proton density, T_1 and T_2 are the relaxation times, and Delta omega is the off-resonance, for each position.\n\nThe Bloch Simulation Method also uses the technique of operator splitting to simplify the solution of Equation (1). This reflects mathematically the intuition of separating the Bloch equations in a rotation operator described by\n\nbeginalign tag2\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n 0            gamma B_z  -gamma B_y \n-gamma B_z   0            gamma B_x \n gamma B_y  -gamma B_x   0\nendbmatrix\nboldsymbolM \n\nendalign\n\nand a relaxation operator described by\n\nbeginalign tag3\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n-tfrac1T_2  0  0 \n0  -tfrac1T_2  0 \n0  0  -tfrac1T_1\nendbmatrix\nboldsymbolM\n+\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix \n\nendalign\n\nThe evolution of the magnetization can then be described as a two-step process for each time step Delta t (Figure 2).\n\n<p align=\"center\">\n<figure>\n  <img width=\"60%\" src=\"../../assets/block-equation-intuition.svg\">\n  <figcaption><b>Figure 2</b>: Solution of the Bloch equations for one time step can be described by (2) a rotation and (3) a relaxation step.</figcaption>\n</figure>\n</p>","category":"section"},{"location":"explanation/6-simulation/#Bloch()-Method-Example","page":"Simulation","title":"Bloch() Method Example","text":"We will consider an RF pulse that excites a phantom with 3 spins, and then we acquire the data:\n\n<details><summary>View code</summary>\n\n# Import modules\nusing KomaMRI\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\n\n</details>\n\njulia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>\n\nThe resulting signal from the Bloch() method is the sum of magnetizations in the transverse plane (x, y):\n\n# Configure Bloch() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = Bloch()\nsig = simulate(obj, seq, sys; sim_params)\n\njulia> plot(abs.(sig[:,1,1]))\n\n<object type=\"text/html\" data=\"../../assets/sim-bloch-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/6-simulation/#BlochDict-Simulation-Method","page":"Simulation","title":"BlochDict Simulation Method","text":"This is another simulation method defined in the source code of KomaMRI. You can specify it by setting the sim_method = BlochDict() entry in the sim_params dictionary. Additionally, it offers the option to save the resulting signal in the z-component by using sim_method = BlochDict(save_Mz=true). This method allows you to store the magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z) if specified.","category":"section"},{"location":"explanation/6-simulation/#BlochDict()-Method-Example","page":"Simulation","title":"BlochDict() Method Example","text":"We are going to consider the same setup as in the Bloch() Method Example. This includes the same excitation, acquisition, and the same 3-spin phantom:\n\n<details><summary>View code</summary>\n\n# Import modules\nusing KomaMRI, PlotlyJS\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 4000e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\n\n</details>\n\njulia> obj = Phantom(x=[-0.5e-3; 0.0; 0.5e-3], T1=[1000e-3; 2000e-3; 500e-3], T2=[500e-3; 1000e-3; 2000e-3]);\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/sim-bloch-seq.html\" style=\"width:100%; height:420px;\"></object>\n\nThe resulting signal from the BlochDict() method comprises the individual magnetizations of all spins in both the transverse plane (x, y) and the longitudinal axis (z):\n\n# Configure BlochDict() simulation method and run simulation\nsim_params = KomaMRICore.default_sim_params()\nsim_params[\"return_type\"] = \"mat\"\nsim_params[\"sim_method\"] = BlochDict(save_Mz=true)\nsig = simulate(obj, seq, sys; sim_params)\n\n# Define the plots for traverse and longitudinal magnetizations\npxy = plot(abs.(sig[:,:,1]));\npz = plot(abs.(sig[:,:,2]));\n\njulia> [pxy pz]\n\n<object type=\"text/html\" data=\"../../assets/sim-blochdict-sig.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"how-to/3-create-your-own-phantom/#Create-Your-Own-Phantom","page":"Create Your Own Phantom","title":"Create Your Own Phantom","text":"In this section, we will create some custom Phantom structs.\n\nIn KomaMRI, the creation of a Phantom struct involves defining spin position arrays (x, y, z) and spin property arrays.  The indices of these arrays are then associated with independent spins. See the Phantom explanation section for more information about how digital phantoms work in KomaMRI. ","category":"section"},{"location":"how-to/3-create-your-own-phantom/#Basic-case:-1-spin-phantom","page":"Create Your Own Phantom","title":"Basic case: 1-spin phantom","text":"You can create a Phantom with one spin like so:\n\n# Define arrays of positions (spin at zero position)\nx = [0.0]\ny = [0.0]\nz = [0.0]\n\n# Define arrays of properties (for CSF tissue)\nρ = [1.0]\nT1 = [2.569]\nT2 = [0.329]\nT2s = [0.058]\n\n# Define the phantom\nspin = Phantom(name=\"spin\", x=x, y=y, z=z, ρ=ρ, T1=T1, T2=T2, T2s=T2s)\n\nPhantom{Float64}\n  name: String \"spin\"\n  x: Array{Float64}((1,)) [0.0]\n  y: Array{Float64}((1,)) [0.0]\n  z: Array{Float64}((1,)) [0.0]\n  ρ: Array{Float64}((1,)) [1.0]\n  T1: Array{Float64}((1,)) [2.569]\n  T2: Array{Float64}((1,)) [0.329]\n  T2s: Array{Float64}((1,)) [0.058]\n  Δw: Array{Float64}((1,)) [0.0]\n  Dλ1: Array{Float64}((1,)) [0.0]\n  Dλ2: Array{Float64}((1,)) [0.0]\n  Dθ: Array{Float64}((1,)) [0.0]\n  motion: NoMotion NoMotion()\n\nYou can add more properties to the Phantom, such as off-resonance, diffusion parameters, and even motion information.","category":"section"},{"location":"how-to/3-create-your-own-phantom/#Loading-phantom-data-from-a-.mat-file","page":"Create Your Own Phantom","title":"Loading phantom data from a .mat file","text":"If you are familiar with the MRI world, you likely have a 2D or 3D array, where each element contains an ID number identifying a different class of tissue. In this setup, the array axes represent spatial positions, while the elements are used for tissue identification.\n\nIn this example, we will utilize a .mat file containing arrays with such arrangements. The file is readily available upon installing KomaMRI. Let's read the file and store the 2D data in an array called class:\n\n# Get data from a .mat file\npath_koma = dirname(dirname(pathof(KomaMRI)))\npath_phantom_mat = joinpath(path_koma, \"KomaMRIBase\", \"src\", \"datatypes\", \"phantom\", \"pelvis2D.mat\")\ndata = KomaMRIFiles.matread(path_phantom_mat)\nclass = data[\"pelvis3D_slice\"]\n\nYou can visualize the tissue map using the plot_image function:\n\nplot_image(class)\n\n<center><object type=\"text/html\" data=\"../../assets/create-your-own-phantom-class-map.html\" style=\"width:85%; height:470px;\"></object></center>\n\nLet's define the position arrays. You need to know the distance between the spins in the original array (in this case, it is 0.5mm), and then you can determine all the positions like this (the z-component is not calculated since this is a 2D example):\n\n# Define spin position arrays\nΔx = .5e-3                  # 0.5mm\nM, N = size(class)          # Number of spins in x and y\nFOVx = (M-1)*Δx             # Field of view in x\nFOVy = (N-1)*Δx             # Field of view in y\nx = -FOVx/2:Δx:FOVx/2       # x spin coordinates vector\ny = -FOVy/2:Δx:FOVy/2       # y spin coordinates vector\nx, y = x .+ y'*0, x*0 .+ y' # x and y grid points\n\nNow, let's define the arrays for the properties. It's essential to have prior knowledge of the property values for different tissue classes. For example, for soft tissue, we use ρ = 0.9, T1 = 1200 * 1e-3, T2 = 80 * 1e-3, and T2s = 80 * 1e-3. Additionally, we create an array mask to identify the location of a tissue's ID. For soft tissue with ID = 153, the mask is (class .== 153). Finally, to obtain a property, sum all the masks with values for all tissue classes. This process is illustrated below: \n\n# Define the proton density array\nρ = (class.==102)*.86 .+    # Fat\n    (class.==153)*.9 .+     # SoftTissue\n    (class.==204)*.4 .+     # SpongyBone\n    (class.==255)*.2        # CorticalBone\n\n# Define the T1 decay array\nT1 = (class.==102)*366 .+   # Fat\n    (class.==153)*1200 .+   # SoftTissue\n    (class.==204)*381 .+    # SpongyBone\n    (class.==255)*100       # CorticalBone\n\n# Define the T2 decay array\nT2 = (class.==102)*70 .+    # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define the T2s decay array\nT2s = (class.==102)*70 .+   # Fat\n    (class.==153)*80 .+     # SoftTissue\n    (class.==204)*52 .+     # SpongyBone\n    (class.==255)*.3        # CorticalBone\n\n# Define off-resonance array\nΔw_fat = -220 * 2π\nΔw = (class.==102) * Δw_fat # FAT1\n\n# Adjust with scaling factor\nT1 = T1*1e-3\nT2 = T2*1e-3\nT2s = T2s*1e-3\n\nFinally, we can invoke the Phantom constructor. However, before doing so, we choose not to store spins where the proton density is zero to avoid unnecessary data storage. This is achieved by applying the mask ρ.!=0 to the arrays. Additionally, please note that we set the z-position array filled with zeros.\n\n# Define the phantom\nobj = Phantom(\n    name = \"custom-pelvis\",\n\tx = x[ρ.!=0],\n\ty = y[ρ.!=0],\n\tz = 0*x[ρ.!=0],\n\tρ = ρ[ρ.!=0],\n\tT1 = T1[ρ.!=0],\n\tT2 = T2[ρ.!=0],\n\tT2s = T2s[ρ.!=0],\n\tΔw = Δw[ρ.!=0],\n)\n\nWe can display the Phantom struct with the plot_phantom_map function. In this case we select the T1 decay to be displayed, but you can choose other property to be displayed:\n\nplot_phantom_map(obj, :T1)\n\n<object type=\"text/html\" data=\"../../assets/create-your-own-phantom-pelvis-T1.html\" style=\"width:85%; height:470px;\"></object>","category":"section"},{"location":"how-to/3-create-your-own-phantom/#Creating-a-custom-flow-cylinder-phantom","page":"Create Your Own Phantom","title":"Creating a custom flow cylinder phantom","text":"This section shows how to create a slightly more complex phantom, which includes flow, from scratch. \n\nThe phantom is modelled as a vertical cylindrical tube, with outer radius of 10 mm, an inner radius of 4.5 mm, and a length of 40 mm.\n\nFirst, we generate the 3D grid that defines the spatial layaout of the spins:\n\nR = 10e-3; r = 4.5e-3; L = 40e-3; Δx = 1e-3\n\n#POSITIONS\nx = -R:Δx:R\ny = -R:Δx:R \nz = -L/2:Δx:L/2\n\nxx = reshape(x, (length(x),1,1)) \nyy = reshape(y, (1,length(y),1)) \nzz = reshape(z, (1,1,length(z))) \n\n# Grid\nx = 1*xx .+ 0*yy .+ 0*zz\ny = 0*xx .+ 1*yy .+ 0*zz\nz = 0*xx .+ 0*yy .+ 1*zz\n\nThen, we separate the grid into two regions. The boolean array bl marks the inner part of the tube, where the \"blood\" spins should flow,  while the ts array identifies the surrounding tissue, which must remain static. The ⚪(R) function helps us with this task:\n\n⚪(R) =  (x.^2 .+ y.^2 .<= R^2) # circle of radius R\n\nts = Bool.(⚪(R) - ⚪(r))\nbl = Bool.(⚪(r))\n\nOnce each region is defined, we can go ahead and create the phantom. It is often convenient to generate the phantoms for each region separately. Let's start with the static outer tissue, which is very straightforward. We’ll assign it PD, T1, and T2 values of 1.0, 700 ms, and 42 ms, respectively:\n\nPD = 1.0; T1 = 700e-3; T2 = 42e-3\n\ntissue = Phantom(\n    name=\"Tissue\",\n    x=x[ts],\n    y=y[ts],\n    z=z[ts],\n    ρ=PD.*ones(length(x[ts])),\n    T1=T1.*ones(length(x[ts])),\n    T2=T2.*ones(length(x[ts]))\n)\n\nPhantom{Float64}\n  name: String \"Tissue\"\n  x: Array{Float64}((10168,)) [0.0, -0.004, -0.003, -0.002, -0.001  …  0.0, 0.001, 0.002, 0.003, 0.004, 0.0]\n  y: Array{Float64}((10168,)) [-0.01, -0.009, -0.009, -0.009, -0.009  …  0.009, 0.009, 0.009, 0.009, 0.01]\n  z: Array{Float64}((10168,)) [-0.02, -0.02, -0.02, -0.02, -0.02  …  0.02, 0.02, 0.02, 0.02, 0.02, 0.02]\n  ρ: Array{Float64}((10168,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  T1: Array{Float64}((10168,)) [0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7  …  0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7]\n  T2: Array{Float64}((10168,)) [0.042, 0.042, 0.042, 0.042, 0.042  …  0.042, 0.042, 0.042, 0.042, 0.042]\n  T2s: Array{Float64}((10168,)) [1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6  …  1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6]\n  Δw: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((10168,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: NoMotion NoMotion()\n\nNow, we repeat the process for the blood spins inside the tube. For this region, the PD, T1, and T2 values will be 0.9, 1200 ms, and 92 ms, respectively.\n\nTo define the flow movement for these inner spins, we need to create a FlowPath motion. This will include both the trajectories followed by each spin and the flags that indicate when a spin leaves the phantom's domain (at the upper end) and is reinjected at the lower end of the cylinder:\n\nPD = 0.9; T1 = 1200e-3; T2 = 92e-3\n\nNt = 500    # Number of discrete time nodes\nv  = 200e-3 # 200 mm/s \n\ndx = dy = zeros(length(z[bl]), Nt)\ndz =z[bl] .+ cumsum(L/Nt .+ zeros(1,Nt), dims=2)\n\nspin_reset = dz .> L/2\nfor i in 1:size(spin_reset, 1)\n    idx = findfirst(x -> x == 1, spin_reset[i, :])\n    if idx !== nothing\n        spin_reset[i, :]  .= 0\n        spin_reset[i, idx] = 1 # Activate the flag at the NEXT node after the jump\n    end\nend\n\ndz[dz .> L/2] .-= L\ndz .-= z[bl]\n\nblood = Phantom(\n    name=\"Blood\",\n    x=x[bl],\n    y=y[bl],\n    z=z[bl],\n    ρ =PD.*ones(length(x[bl])),\n    T1=T1.*ones(length(x[bl])),\n    T2=T2.*ones(length(x[bl])),\n    motion=FlowPath(dx, dy, dz, spin_reset, Periodic(L/v, 1.0-1e-6))\n)\n\nPhantom{Float64}\n  name: String \"Blood\"\n  x: Array{Float64}((2829,)) [-0.002, -0.001, 0.0, 0.001, 0.002  …  -0.002, -0.001, 0.0, 0.001, 0.002]\n  y: Array{Float64}((2829,)) [-0.004, -0.004, -0.004, -0.004  …  0.004, 0.004, 0.004, 0.004, 0.004]\n  z: Array{Float64}((2829,)) [-0.02, -0.02, -0.02, -0.02, -0.02  …  0.02, 0.02, 0.02, 0.02, 0.02, 0.02]\n  ρ: Array{Float64}((2829,)) [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9  …  0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]\n  T1: Array{Float64}((2829,)) [1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2  …  1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]\n  T2: Array{Float64}((2829,)) [0.092, 0.092, 0.092, 0.092, 0.092  …  0.092, 0.092, 0.092, 0.092, 0.092]\n  T2s: Array{Float64}((2829,)) [1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6  …  1.0e6, 1.0e6, 1.0e6, 1.0e6, 1.0e6]\n  Δw: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((2829,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: Motion{Float64}\n\nLast, we obtain the final obj as the sum of both phantoms:\n\nobj = tissue + blood\n\nplot_phantom_map(obj, :T1; time_samples=11)\n\n<object type=\"text/html\" data=\"../../assets/create-your-own-phantom-flow-T1.html\" style=\"width:85%; height:470px;\"></object>","category":"section"},{"location":"how-to/3-create-your-own-phantom/#Importing/exporting-phantoms-(.phantom-file-format)","page":"Create Your Own Phantom","title":"Importing/exporting phantoms (.phantom file format)","text":"Another option to create your own phantom is to import it directly from a .phantom file. To demonstrate this, we will first create the file from the previous phantom, using the write_phantom function, and then we will read it using the read_phantom function:\n\njulia> write_phantom(obj, \"flow_cylinder.phantom\")\n# Now, you could even close Julia, turn off your computer...\njulia> obj2 = read_phantom(\"flow_cylinder.phantom\")","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots","page":"KomaMRIPlots","title":"KomaMRIPlots","text":"","category":"section"},{"location":"reference/5-koma-plots/#Plotting-Phantom","page":"KomaMRIPlots","title":"Plotting Phantom","text":"","category":"section"},{"location":"reference/5-koma-plots/#Plotting-Sequence","page":"KomaMRIPlots","title":"Plotting Sequence","text":"","category":"section"},{"location":"reference/5-koma-plots/#Plotting-RawAcquisitionData","page":"KomaMRIPlots","title":"Plotting RawAcquisitionData","text":"","category":"section"},{"location":"reference/5-koma-plots/#Plotting-images","page":"KomaMRIPlots","title":"Plotting images","text":"","category":"section"},{"location":"reference/5-koma-plots/#Others","page":"KomaMRIPlots","title":"Others","text":"","category":"section"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_phantom_map","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_phantom_map","text":"p = plot_phantom_map(obj::Phantom, key::Symbol; kwargs...)\n\nPlots a phantom map for a specific spin parameter given by key.\n\nArguments\n\nobj: (::Phantom) Phantom struct\nkey: (::Symbol, opts: [:ρ, :T1, :T2, :T2s, :x, :y, :z]) symbol for   displaying different parameters of the phantom spins\n\nKeywords\n\nheight: (::Integer, =600) plot height\nwidth: (::Integer, =nothing) plot width\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nview_2d: (::Bool, =false) boolean to indicate whether to use a 2D scatter plot\ncolorbar: (::Bool, =true) boolean to indicate whether to display a colorbar\nmax_spins:(::Int, =20_000) maximum number of displayed spins\ntime_samples:(::Int, =0) intermediate time samples between motion t_start and t_end\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the phantom map for a specific spin parameter\n\nReferences\n\nColormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).\n\nExamples\n\njulia> obj2D, obj3D = brain_phantom2D(), brain_phantom3D();\n\njulia> plot_phantom_map(obj2D, :ρ)\n\njulia> plot_phantom_map(obj3D, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seq","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seq","text":"p = plot_seq(seq::Sequence; kwargs...)\n\nPlots a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\nfreq_in_phase: (::Bool, =true) Include FM modulation in RF phase\ngl: (::Bool, =false) use PlotlyJS.scattergl backend (faster)\nmax_rf_samples: (::Integer, =100) maximum number of RF samples\nshow_adc: (::Bool, =false) plot ADC samples with markers\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_kspace","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_kspace","text":"p = plot_kspace(seq::Sequence; width=nothing, height=nothing, darkmode=false)\n\nPlots the k-space of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the k-space of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M0","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M0","text":"p = plot_M0(seq::Sequence; kwargs...)\n\nPlots the zero order moment (M0) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M0 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M0(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M1","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M1","text":"p = plot_M1(seq::Sequence; kwargs...)\n\nPlots the first order moment (M1) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M1 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M1(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_M2","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_M2","text":"p = plot_M2(seq::Sequence; kwargs...)\n\nPlots the second order moment (M2) of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the moment M2 of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_M2(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_eddy_currents","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_eddy_currents","text":"p = plot_eddy_currents(seq::Sequence, λ; kwargs...)\n\nPlots the eddy currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nλ: (::Real, [s]) time constant for the decay of Eddy currents\n\nKeywords\n\nα: (::Vector{Real}, =ones(size(λ))) eddy currents factors\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Eddy currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_eddy_currents(seq, 80e-3)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_slew_rate","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_slew_rate","text":"p = plot_slew_rate(seq::Sequence; kwargs...)\n\nPlots the slew rate currents of a Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the slew rate currents of the Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_slew_rate(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_seqd","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_seqd","text":"p = plot_seqd(seq::Sequence; sampling_params=KomaMRIBase.default_sampling_params())\n\nPlots a sampled sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nsampling_params: (::Dict{String,Any}(), =KomaMRIBase.default_sampling_params()) dictionary of   sampling parameters\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the sampled Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seqd(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_signal","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_signal","text":"p = plot_signal(raw::RawAcquisitionData; kwargs...)\n\nPlots a raw signal in ISMRMRD format.\n\nArguments\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct (raw signal in ISMRMRD format)\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nslider: (::Bool, =true) boolean to indicate whether to display a slider\nshow_sim_blocks: (::Bool, =false) boolean to indicate whether to display sequence blocks\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\nrange: (::Vector{Real}, =[]) time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the raw signal\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_image","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_image","text":"p = plot_image(image; height, width, zmin, zmax, darkmode, title)\n\nPlots an image matrix.\n\nArguments\n\nimage: (::Matrix{Number}) image matrix\n\nKeywords\n\nwidth: (::Integer, =nothing) plot width\nheight: (::Integer, =nothing) plot height\nzmin: (::Real, =minimum(abs.(image[:]))) reference value for minimum color\nzmax: (::Real, =maximum(abs.(image[:]))) reference value for maximum color\ndarkmode: (::Bool, =false) boolean to indicate whether to display darkmode style\ntitle: (::String, =\"\") plot title\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the image matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/5-koma-plots/#KomaMRIPlots.plot_dict","page":"KomaMRIPlots","title":"KomaMRIPlots.plot_dict","text":"str = plot_dict(dict::Dict)\n\nGenerates an HTML table based on the dictionary dict.\n\nArguments\n\ndict: (::Dict) dictionary\n\nReturns\n\nstr: (::String) dictionary as an HTML table\n\n\n\n\n\n","category":"function"},{"location":"tutorial/01-FID/#Free-Induction-Decay","page":"Free Induction Decay","title":"Free Induction Decay","text":"(Image: ) (Image: ) (Image: )\n\nFirst of all, let's use the KomaMRI package and define the default scanner.\n\nusing KomaMRI, Suppressor\nsys = Scanner(); # default hardware definition\n\nThe free induction decay is the simplest observable NMR signal. This signal is the one that follows a single tipping RF pulse. To recreate this experiment, we will need to define a Sequence with 2 blocks.\n\nThe first block containing an RF pulse with a flip-angle of 90 deg,\n\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF,durRF);\n\nand the second block containing the ADC.\n\nnADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay);\n\nFinally, we concatenate the sequence blocks to create the final sequence.\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\np1 = plot_seq(seq; slider=false, height=300)\n\n<object type=\"text/html\" data=\"../../assets/1-seq.html\" style=\"width:100%; height:320px;\"></object>\n\nNow, we will define a Phantom with a single spin at x=0 with T_1=1000mathrmms and T_2=100mathrmms.\n\nobj = Phantom(x=[0.], T1=[1000e-3], T2=[100e-3]);\n\nFinally, to simulate we will need to use the function simulate (note how the use of the @suppress macro prevents internal messages from being printed by the function):\n\nraw = @suppress simulate(obj, seq, sys);\n\nTo plot the results we will need to use the plot_signal function\n\np2 = plot_signal(raw; slider=false, height=300)\n\n<object type=\"text/html\" data=\"../../assets/1-signal.html\" style=\"width:100%; height:320px;\"></object>\n\nNice!, we can see that S(t) follows an exponential decay exp(-tT_2) as expected.\n\nFor a little bit of spiciness, let's add off-resonance to our example. We will use Delta f=-100mathrmHz. For this, we will need to add a definition for Δw in our Phantom\n\nobj = Phantom(x=[0.], T1=[1000e-3], T2=[100e-3], Δw=[-2π*100])# and simulate again.\n\nraw = @suppress simulate(obj, seq, sys)\np3 = plot_signal(raw; slider=false, height=300)\n\n<object type=\"text/html\" data=\"../../assets/1-signal2.html\" style=\"width:100%; height:320px;\"></object>\n\nThe signal now follows an exponential of the form exp(-tT_2)cdotexp(-iDeltaomega t). The addition of exp(-iDeltaomega t) to the signal will generate a shift in the image space (Fourier shifting property). This effect will be better visualized and explained in later examples.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"explanation/5-seq-events/#Sequence-Events","page":"Sequence Events","title":"Sequence Events","text":"As we already know, a Sequence struct contains field names that store arrays of RF, Grad, and ADC structs. In the context of MRI, we refer to RF, Grad, and ADC as \"events.\" To create a Sequence, it's essential to understand how to create these fundamental events.\n\nIn the following subsections, we will provide detailed explanations of event parameters and guide you through the process of creating a Sequence using RF, Grad, and ADC events.","category":"section"},{"location":"explanation/5-seq-events/#RF","page":"Sequence Events","title":"RF","text":"The RF struct is defined in the source code of KomaMRI as follows:\n\nmutable struct RF\n    A\n    T\n    Δf\n    delay::Real\nend\n\nAs you can see, it has 4 field names: A defines amplitude, T defines duration time, delay is the distance between the 0 time and the first waveform sample and Δf is the displacement respect to the main field carrier frequency (this is for advanced users).\n\nA and T can be numbers or vectors of numbers. Depending on the length of the A and T, KomaMRI interprets different waveforms: \n\nPulse Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors; T stores interval durations so length(A) = length(T) + 1, and the waveform is reconstructed by connecting consecutive A entries with piecewise-linear segments\n\nIn the image below, we provide a summary of how you can define RF events:\n\n<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-rf-horizontal.svg\"/></p>\n\nLet's look at some basic examples of creating these RF structs and including them in a Sequence struct. The examples should be self-explanatory.","category":"section"},{"location":"explanation/5-seq-events/#RF-Pulse-Waveform","page":"Sequence Events","title":"RF Pulse Waveform","text":"julia> A, T, delay =  10e-3, 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(10000.0 uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-rf-pulse-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#RF-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"RF Uniformly-Sampled Waveform","text":"julia> tl = -3:0.2:-0.2; tr = 0.2:0.2:3;\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; sin.(π*tr)./(π*tr)];\n\njulia> T, delay = 0.5e-3, 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 0.5 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 0.6 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-rf-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#RF-Time-Shaped-Waveform","page":"Sequence Events","title":"RF Time-Shaped Waveform","text":"julia> tl = -4:0.2:-0.2; tr = 0.2:0.2:4\n\njulia> A = (10e-3)*[sin.(π*tl)./(π*tl); 1; 1; sin.(π*tr)./(π*tr)]\n\njulia> T = [0.05e-3*ones(length(tl)); 2e-3; 0.05e-3*ones(length(tl))]\n\njulia> delay = 0.1e-3;\n\njulia> rf = RF(A, T, 0, delay)\n←0.1 ms→ RF(∿ uT, 4.0 ms, 0.0 Hz)\n\njulia> seq = Sequence(); seq += rf\nSequence[ τ = 4.1 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-rf-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#Gradient","page":"Sequence Events","title":"Gradient","text":"The Grad struct is defined as follows in the source code of KomaMRI:\n\nmutable struct Grad\n    A\n    T\n    rise::Real\n    fall::Real\n    delay::Real\nend\n\nAs you can see, it has 5 field names: A defines amplitude, T defines duration time, delay is the distance between the 0 time and the first waveform sample, rise and fall are the time durations of the first and last gradient ramps.\n\nJust like the RF, A and T in the Grad struct can be numbers or vectors of numbers. Depending on the length of the A and T, KomaMRI interprets different waveforms: \n\nTrapezoidal Waveform: A and T are numbers\nUniformly-Sampled Waveform: A is a vector and T is a number\nTime-Shaped Waveform: A and T are both vectors; T stores interval durations so length(A) = length(T) + 1, and the waveform is reconstructed by connecting consecutive A entries with piecewise-linear segments\n\nIn the image below, we provide a summary of how you can define Grad events:\n\n<p align=\"center\"><img width=\"100%\" src=\"../../assets/event-shapes-gr-horizontal.svg\"/></p>\n\nLet's look at some basic examples of creating these Grad structs and including them in a Sequence struct, focusing on the x component of the gradients. The examples should be self-explanatory.","category":"section"},{"location":"explanation/5-seq-events/#Gradient-Trapezoidal-Waveform","page":"Sequence Events","title":"Gradient Trapezoidal Waveform","text":"julia> A, T, delay, rise, fall = 50*10e-6, 5e-3, 2e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←2.0 ms→ Grad(0.5 mT, 0.5 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-gr-trapezoidal-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#Gradient-Uniformly-Sampled-Waveform","page":"Sequence Events","title":"Gradient Uniformly-Sampled Waveform","text":"julia> t = 0:0.25:7.5\n\njulia> A = 10*10e-6 * sqrt.(π*t) .* sin.(π*t)\n\njulia> T = 10e-3;\n\njulia> delay, rise, fall = 1e-3, 0, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 10.0 ms, ↑0.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 12.0 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-gr-uniformly-sampled-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#Gradient-Time-Shaped-Waveform","page":"Sequence Events","title":"Gradient Time-Shaped Waveform","text":"julia> A = 50*10e-6*[1; 1; 0.8; 0.8; 1; 1];\n\njulia> T = 1e-3*[5; 0.2; 5; 0.2; 5];\n\njulia> delay, rise, fall = 1e-3, 1e-3, 1e-3;\n\njulia> gr = Grad(A, T, rise, fall, delay)\n←1.0 ms→ Grad(∿ mT, 15.4 ms, ↑1.0 ms, ↓1.0 ms)\n\njulia> seq = Sequence([gr])\nSequence[ τ = 10.75 ms | blocks: 1 | ADC: 0 | GR: 1 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-gr-time-shaped-waveform.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#ADC","page":"Sequence Events","title":"ADC","text":"The ADC struct is defined in the KomaMRI source code as follows:\n\nmutable struct ADC\n    N::Integer\n    T::Real\n    delay::Real\n    Δf::Real\n    ϕ::Real\nend\n\nAs you can see, it has 5 field names: N defines number of samples, T defines total acquisition duration, delay is the distance between the 0 time and the first sampled signal, Δf and ϕ are factor to correct signal acquisition (for advanced users).\n\nIn the image below you can see how to define an ADC event:\n\n<p align=\"center\"><img width=\"50%\" src=\"../../assets/event-shapes-adc.svg\"/></p>\n\nLet's look at a basic example of defining an ADC struct and including it in a Sequence struct:\n\njulia> N, T, delay =  16, 5e-3, 1e-3;\n\njulia> adc = ADC(N, T, delay)\nADC(16, 0.005, 0.001, 0.0, 0.0)\n\njulia> seq = Sequence(); seq += adc\nSequence[ τ = 6.0 ms | blocks: 1 | ADC: 1 | GR: 0 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-adc.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/5-seq-events/#Extensions-and-Labels","page":"Sequence Events","title":"Extensions and Labels","text":"The EXTENSION field in the Sequence struct is used to store additional metadata or labels for each block in the sequence. This can be particularly useful for adding metadata headers required for formats like ISMRMRD. Labels can be used to manage sequence metadata, such as line numbers or echo numbers, which are essential for certain reconstruction algorithms.","category":"section"},{"location":"explanation/5-seq-events/#LabelInc-and-LabelSet-extension","page":"Sequence Events","title":"LabelInc and LabelSet extension","text":"The LabelInc and LabelSet functions are used to create labels that can be added to the EXTENSION field of a Sequence. These labels help in managing ADC metada.\n\nOnly Pulseq labels are availables. MRD also stores other FLAGS currently not available in KomaMRI:\n\nmutable struct AdcLabels\n  LIN::Int\n  PAR::Int\n  SLC::Int\n  SEG::Int\n  REP::Int\n  AVG::Int\n  SET::Int\n  ECO::Int\n  PHS::Int\n  NAV::Int\n  REV::Int\n  SMS::Int\nend","category":"section"},{"location":"explanation/5-seq-events/#LabelInc","page":"Sequence Events","title":"LabelInc","text":"The LabelInc function creates a label that increments a specific metadata field by a given value. This is useful for managing fields like line numbers or echo numbers.\n\nLabelInc(value::Int, label::String)\n\nvalue: The increment value.\nlabel: The name of the metadata field to increment.","category":"section"},{"location":"explanation/5-seq-events/#LabelSet","page":"Sequence Events","title":"LabelSet","text":"The LabelSet function creates a label that sets a specific metadata field to a given value. This is useful for managing fields like line numbers or echo numbers.\n\nLabelSet(value::Int, label::String)\n\nvalue: The value to set.\nlabel: The name of the metadata field to set.","category":"section"},{"location":"explanation/5-seq-events/#Trigger-extension","page":"Sequence Events","title":"Trigger extension","text":"As described by the Pulseq specifications : TRIGGERS extension, which is not a part of the core Pulseq format and MAY be subject to rapid changes. The usage of the type / channel is system dependent and must be checked beforehand.\n\nnote: Note\nTrigger extension is implemented but currently not taken into account during the simulation \n\nmutable struct Trigger <: Extension \n  type::Int # Type of trigger (system dependent). 0: undefined / unused\n  channel::Int # channel of trigger (system dependent). 0: undefined / unused\n  d1::Float64 # Delay prior to the trigger event (us)\n  d2::Float64 # Duration of trigger event (us)\nend","category":"section"},{"location":"explanation/5-seq-events/#Example-Usage","page":"Sequence Events","title":"Example Usage","text":"Below is an example of how to use LabelInc and LabelSet to add labels to a sequence:\n\n# Define a sequence\nseq = Sequence()\n\n# Create labels\nlInc = LabelInc(1, \"LIN\")\nlSet = LabelSet(1, \"ECO\")\ntrig = Trigger(0,1,100,500)\n\n# Add labels to the sequence\nseq.EXT = [[lInc,trig], [lSet]]\n\n# Display the sequence\nprintln(seq)\n\nIn this example, LabelInc(1, \"LIN\") increments the line number by 1, and LabelSet(1, \"ECO\") sets the echo number to 1. These labels are added to the EXTENSION field of the sequence.","category":"section"},{"location":"explanation/5-seq-events/#Combining-Labels","page":"Sequence Events","title":"Combining Labels","text":"You can combine multiple labels for a single block by adding them to the EXTENSION field as a vector of labels. Here is an example:\n\n# Define a sequence\nseq = Sequence()\n\n# Create labels\nlInc = LabelInc(1, \"LIN\")\nlSet = LabelSet(1, \"ECO\")\n\n# Add combined labels to the sequence\nseq.EXT = [[lInc, lSet]]\n\n# Display the sequence\nprintln(seq)\n\nIn this example, both LabelInc and LabelSet are added to the EXTENSION field of the sequence, allowing for more complex metadata management.\n\nBy using LabelInc and LabelSet, you can effectively manage sequence metadata and ensure that your sequence is compatible with various reconstruction algorithms and formats.\n\nwarning: Warning\nSo far, KomaMRI EXTENSION only manage ADC labels and Triggers. In future version, other specific Pulseq extension will be added like Soft Delay, no rotation etc.","category":"section"},{"location":"explanation/5-seq-events/#Combination-of-Events","page":"Sequence Events","title":"Combination of Events","text":"We can include multiple events within a single block of a sequence. The example below demonstrates how to combine an RF struct, three Grad structs for the x-y-z components, and an ADC struct in a single block of a sequence:\n\n# Define an RF struct\nA, T =  1e-6*[0; -0.1; 0.2; -0.5; 1; -0.5; 0.2; -0.1; 0], 0.5e-3;\nrf = RF(A, T)\n\n# Define a Grad struct for Gx\nA, T, rise =  50*10e-6, 5e-3, 1e-3\ngx = Grad(A, T, rise)\n\n# Define a Grad struct for Gy\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT, rise = 5e-3, 2e-3;\ngy = Grad(A, T, rise)\n\n# Define a Grad struct for Gz\nA = 50*10e-6*[0; 0.5; 0.9; 1; 0.9; 0.5; 0; -0.5; -0.9; -1]\nT = 5e-3*[0.0; 0.1; 0.3; 0.2; 0.1; 0.2; 0.3; 0.2; 0.1]\ngz = Grad(A, T)\n\n# Define an ADC struct\nN, T, delay =  16, 5e-3, 1e-3\nadc = ADC(N, T, delay)\n\njulia> seq = Sequence([gx; gy; gz;;], [rf;;], [adc])\nSequence[ τ = 9.0 ms | blocks: 1 | ADC: 1 | GR: 3 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/event-combination.html\" style=\"width:100%; height:420px;\"></object>\n\nOnce the struct events are defined, it's important to note that to create a single block sequence, you need to provide 2D matrices of Grad and RF structs, as well as a vector of ADC structs as arguments in the Sequence constructor.","category":"section"},{"location":"explanation/5-seq-events/#Algebraic-manipulation","page":"Sequence Events","title":"Algebraic manipulation","text":"Certain mathematical operations can be directly applied to events and sequence structs. This proves helpful when constructing sequences using reference structs and manipulating them algebraically to create new structs. Below, we provide a list of operations you can perform, along with examples where we check the equivalence of two different struct definitions:\n\nRF scaling\n\n# Define params\nA, T = 10e-6, 0.5e-3    # Define base RF params  \nα = (1 + im*1)/sqrt(2)  # Define a complex scaling factor\n\n# Create two equivalent RFs in different ways\nra = RF(α * A, T)\nrb = α * RF(A, T)\n\njulia> ra ≈ rb\ntrue\n\nGradient scaling\n\n# Define params\nA, T = 10e-3, 0.5e-3   # Define base gradient params  \nα = 2                  # Define a scaling factor\n\n# Create two equivalent gradients in different ways\nga = Grad(α * A, T)\ngb = α * Grad(A, T)\n\njulia> ga ≈ gb\ntrue\n\nGradient addition\n\n# Define params\nT = 0.5e-3      # Define common duration of the gradients\nA1 = 5e-3       # Define base amplitude for gradient  \nA2 = 10e-3      # Define another base amplitude for gradient  \n\n# Create two equivalent gradients in different ways\nga = Grad(A1 + A2, T)\ngb = Grad(A1, T) + Grad(A2, T)\n\njulia> ga ≈ gb\ntrue\n\nGradient array multiplication by a matrix\n\n# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent gradient vectors in different ways\nga = [gy; gz; gx]\ngb = R * [gx; gy; gz]\n\n# Create two equivalent gradient matrices in different ways\ngc = [gy 2*gy; gz 2*gz; gx 2*gx]\ngd = R * [gx 2*gx; gy 2*gy; gz 2*gz]\n\njulia> all(ga .≈ gb)\ntrue\n\njulia> all(gc .≈ gd)\ntrue\n\nSequence rotation\n\n# Define params\nT = 0.5e-3                          # Define common duration of the gradients\nAx, Ay, Az = 10e-3, 20e-3, 5e-3     # Define base amplitude for gradients  \ngx, gy, gz = Grad(Ax, T), Grad(Ay, T), Grad(Az, T)  # Define gradients\nR = [0 1. 0; 0 0 1.; 1. 0 0]        # Define matrix (a rotation matrix in this example)\n\n# Create two equivalent sequences in different ways\nsa = Sequence(R * [gx; gy; gz;;])\nsb = R * Sequence([gx; gy; gz;;])\n\njulia> all(sa.GR .≈ sb.GR)\ntrue","category":"section"},{"location":"how-to/3-create-your-own-sequence/#Create-Your-Own-Sequence","page":"Create Your Own Sequence","title":"Create Your Own Sequence","text":"warning: Warning\nThis section is currently under construction, and some details on how to construct a Sequence may be missing.\n\nThis is an example of how to create a Sequence struct:\n\n# Export necessary modules\nusing KomaMRI\n\n# Create the function that creates a phantom\nfunction sequence_example(FOV::Real, N::Integer)\n\n    # Define initial paramters (TODO: consider when N is even)\n    sys = Scanner()\n\tΔt = sys.ADC_Δt\n\tGmax = sys.Gmax\n\tNx = Ny = N #Square acquisition\n\tΔx = FOV/(Nx-1)\n\tTa = Δt*(Nx-1) #4-8 us\n    Δτ = Ta/(Ny-1)\n\tGa = 1/(γ*Δt*FOV)\n\tζ = Ga / sys.Smax\n\tGa ≥ sys.Gmax ? error(\"Ga=$(Ga*1e3) mT/m exceeds Gmax=$(Gmax*1e3) mT/m, increase Δt to at least Δt_min=\"\n\t*string(round(1/(γ*Gmax*FOV),digits=2))*\" us.\") : 0\n\tϵ1 = Δτ/(Δτ+ζ)\n\n\t# EPI base\n\tEPI = Sequence(vcat(\n\t    [mod(i,2)==0 ? Grad(Ga*(-1)^(i/2),Ta,ζ) : Grad(0.,Δτ,ζ) for i=0:2*Ny-2],  #Gx\n\t \t[mod(i,2)==1 ? ϵ1*Grad(Ga,Δτ,ζ) :         Grad(0.,Ta,ζ) for i=0:2*Ny-2])) #Gy\n\tEPI.ADC = [mod(i,2)==1 ? ADC(0,Δτ,ζ) : ADC(N,Ta,ζ) for i=0:2*Ny-2]\n\n\t# Pre-wind and wind gradients\n\tϵ2 = Ta/(Ta+ζ)\n    PHASE =   Sequence(reshape(1/2*[Grad(      -Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # This needs to be calculated differently\n\tDEPHASE = Sequence(reshape(1/2*[Grad((-1)^N*Ga, Ta, ζ); ϵ2*Grad(-Ga, Ta, ζ)],:,1)) # for even N\n\tseq = PHASE + EPI + DEPHASE\n\n\t# Saving parameters\n\tseq.DEF = Dict(\"Nx\"=>Nx,\"Ny\"=>Ny,\"Nz\"=>1,\"Name\"=>\"epi\")\n\n    # Return the sequence\n\treturn seq\nend\n\n# Call the function to create a sequence\nFOV, N = 23e-2, 101\nseq = sequence_example(FOV, N)\n\n# Plot the sequence in time and its kspace\nplot_seq(seq; range=[0 30])\nplot_kspace(seq)\n\n<object type=\"text/html\" data=\"../../assets/create-your-own-sequence-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/create-your-own-sequence-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore","page":"KomaMRICore","title":"KomaMRICore","text":"","category":"section"},{"location":"reference/3-koma-core/#Simulation-functions","page":"KomaMRICore","title":"Simulation functions","text":"","category":"section"},{"location":"reference/3-koma-core/#GPU-helper-functions","page":"KomaMRICore","title":"GPU helper functions","text":"","category":"section"},{"location":"reference/3-koma-core/#Signal-to-RawAquisitionData-(MRD)","page":"KomaMRICore","title":"Signal to RawAquisitionData (MRD)","text":"","category":"section"},{"location":"reference/3-koma-core/#SpinRepresentationState's","page":"KomaMRICore","title":"SpinRepresentationState's","text":"","category":"section"},{"location":"reference/3-koma-core/#Spinor-rotation-matrix-(RF-excitation)","page":"KomaMRICore","title":"Spinor rotation matrix (RF excitation)","text":"","category":"section"},{"location":"reference/3-koma-core/#KomaMRICore.simulate","page":"KomaMRICore","title":"KomaMRICore.simulate","text":"out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; sim_params, w)\n\nReturns the raw signal or the last state of the magnetization according to the value of the \"return_type\" key of the sim_params dictionary. \n\nThis is a wrapper function to run_sim_time_iter, which converts the inputs to the appropriate types and discretizes the sequence before simulation. The reported simulation time only considers run_sim_time_iter, as the preprocessing duration should be negligible compared to the simulation time (if this is not the case, please file a bug report). \n\nArguments\n\nobj: (::Phantom) Phantom struct\nseq: (::Sequence) Sequence struct\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameter dictionary\nw: (::Blink.AtomShell.Window, =nothing) the window within which to display a   progress bar in the Blink Window UI. If this variable is anything other than 'nothing',   the progress bar will be considered\n\nReturns\n\nout: (::Vector{Complex} or ::SpinStateRepresentation or ::RawAcquisitionData) depending   on whether \"return_type\" is \"mat\", \"state\" or \"raw\" (default), respectively\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\");\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> raw = simulate(obj, seq, sys)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.simulate_slice_profile","page":"KomaMRICore","title":"KomaMRICore.simulate_slice_profile","text":"mag = simulate_slice_profile(seq; z, sim_params)\n\nReturns magnetization of spins distributed along z after running the Sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nz: (=range(-2e-2,2e-2,200)) range for the z axis\nsim_params: (::Dict{String, Any}, =Dict{String,Any}(\"Δt_rf\"=>1e-6)) dictionary with   simulation parameters\n\nReturns\n\nmag: (::SpinStateRepresentation) final state of the magnetization vector\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.default_sim_params","page":"KomaMRICore","title":"KomaMRICore.default_sim_params","text":"sim_params = default_sim_params(sim_params=Dict{String,Any}())\n\nThis function returns a dictionary containing default simulation parameters while also allowing the user to define some of them.\n\nArguments\n\nsim_params: (::Dict{String,Any}, =Dict{String,Any}()) user-defined dictionary with   simulation parameters. The following lists its keys along with their possible values:\n\"return_type\": defines the output of the simulate function. Possible values   are \"raw\", \"mat\", and \"state\", corresponding to outputting a MRIReco   RawAcquisitionData, the signal values, and the last magnetization state of the   simulation, respectively\n\"sim_method\": defines the type of simulation. The default value is Bloch(), but you   can alternatively use the BlochDict() simulation method. Moreover, you have the   flexibility to create your own methods without altering the KomaMRI source code\n\"Δt\": raster time for gradients\n\"Δt_rf\": raster time for RFs\n\"precision\": defines the floating-point simulation precision. You can choose between   \"f32\" and \"f64\" to use Float32 and Float64 primitive types, respectively.   It's important to note that, especially for GPU operations, using \"f32\" is   generally much faster\n\"Nblocks\": divides the simulation into a specified number of time blocks. This parameter   is designed to conserve RAM resources, as KomaMRI computes a series of   simulations consecutively, each with the specified number of blocks determined by   the value of \"Nblocks\"\n\"Nthreads\": divides the Phantom into a specified number of threads. Because spins   are modeled independently of each other, KomaMRI can solve simulations in   parallel threads, speeding up the execution time\n\"gpu\": is a boolean that determines whether to use GPU or CPU hardware resources, as   long as they are available on the host computer\n\"gpu_device\": default value is 'nothing'. If set to integer or device instance, calls the   corresponding function to set the device of the available GPU in the host computer    (e.g. CUDA.device!)\n\nReturns\n\nsim_params: (::Dict{String,Any}) dictionary with simulation parameters\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.get_backend","page":"KomaMRICore","title":"KomaMRICore.get_backend","text":"get_backend(use_gpu)\n\nGets the simulation backend to use. If use_gpu=false or there are no available GPU backends,  returns CPU(), else, returns the GPU backend (currently either CUDABackend(), MetalBackend(),  ROCBackend(), or oneAPIBackend()).\n\nThe GPU package for the corresponding backend (CUDA.jl, Metal.jl, AMDGPU.jl, or oneAPI.jl) must be loaded and functional, otherwise KomaMRI will default to using the CPU.\n\nArguments\n\n'use_gpu': ('::Bool') If true, attempt to use GPU and check for available backends\n\nReturns\n\n'backend': (::KernelAbstractions.backend) The backend to use\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.print_devices","page":"KomaMRICore","title":"KomaMRICore.print_devices","text":"print_devices()\n\nSimple function to print available devices. Calls internal get_backend() function to get the appropriate GPU / CPU backend and prints device information.\n\nArguments\n\n'use_gpu':  ('::Bool') If true, check for loaded / functional GPU backends and print appropriate warnings if no GPU backends have been loaded\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.gpu","page":"KomaMRICore","title":"KomaMRICore.gpu","text":"gpu(x)\n\nMoves 'x' to the GPU. For this function to work, a GPU backend will need to be loaded with 'using AMDGPU / CUDA / Metal / oneAPI.\n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nusing CUDA\nx = x |> gpu\n\n\n\n\n\ngpu(x, backend)\n\nTries to move x to the GPU backend specified in the 'backend' parameter. \n\nThis works for functions, and any struct marked with @functor.\n\nUse cpu to copy back to ordinary Arrays.\n\nSee also f32 and f64 to change element type only.\n\nExamples\n\nx = gpu(x, CUDABackend())\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.cpu","page":"KomaMRICore","title":"KomaMRICore.cpu","text":"cpu(x)\n\nTries to move object to CPU. This works for functions, and any struct marked with @functor.\n\nSee also gpu.\n\nExamples\n\nx = x |> cpu\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f32","page":"KomaMRICore","title":"KomaMRICore.f32","text":"f32(m)\n\nConverts the eltype of model's parameters to Float32 Recurses into structs marked with @functor.\n\nSee also f64.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.f64","page":"KomaMRICore","title":"KomaMRICore.f64","text":"f64(m)\n\nConverts the eltype of model's parameters to Float64 (which is Koma's default).. Recurses into structs marked with @functor.\n\nSee also f32.\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.signal_to_raw_data","page":"KomaMRICore","title":"KomaMRICore.signal_to_raw_data","text":"raw = signal_to_raw_data(signal, seq; phantom_name, sys, sim_params)\n\nTransforms the raw signal into a RawAcquisitionData struct (nearly equivalent to the ISMRMRD format) used for reconstruction with MRIReco.\n\nArguments\n\nsignal: (::Matrix{Complex}) raw signal matrix\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nphantom_name: (::String, =\"Phantom\") phantom name\nsys: (::Scanner, =Scanner()) Scanner struct\nsim_params: (::Dict{String, Any}, =Dict{String,Any}()) simulation parameter dictionary\n\nReturns\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_se.seq\")\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(seq_file)\n\njulia> sim_params = KomaMRICore.default_sim_params(); sim_params[\"return_type\"] = \"mat\"\n\njulia> signal = simulate(obj, seq, sys; sim_params)\n\njulia> raw = signal_to_raw_data(signal, seq)\n\njulia> plot_signal(raw)\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Mag","page":"KomaMRICore","title":"KomaMRICore.Mag","text":"mag = Mag(xy::Complex, z::Real)\n\nThe Magnetization struct.\n\nArguments\n\nxy: (::Complex{Float64}) magnetization of a spin in the xy plane\nz: (::Real) magnetization of a spin in the z plane\n\nReturns\n\nmag: (::Mag) Magnetization struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#KomaMRICore.Spinor","page":"KomaMRICore","title":"KomaMRICore.Spinor","text":"spinor = Spinor(α, β)\n\nSpinor(α, β) with Cayley-Klein parameters α and β. Based on \"Introduction to the Shinnar-Le Roux algorithm\", Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (alphabetainmathbbC):\n\nR=leftbeginarraycc\nalpha  -beta^*\nbeta  alpha^*\nendarrayright\n\nwith alpha^2+beta^2 = 1.\n\nThis later operates on the 2times2 representation of (xyz) as follows V^+ = R V R^*.\n\nArguments\n\nα: (::Complex{Float64}) Cayley-Klein parameter α\nβ: (::Complex{Float64}) Cayley-Klein parameter β\n\nReturns\n\nspinor: (::Spinor) Spinor struct\n\n\n\n\n\n","category":"type"},{"location":"reference/3-koma-core/#KomaMRICore.Q","page":"KomaMRICore","title":"KomaMRICore.Q","text":"s = Q(φ, nxy, nz)\n\nSpinor rotation matrix. Counter-clockwise rotation of φ with respect to the axis of rotation n=(nx, ny, nz).\n\nPauly, J., Le Roux, P., Nishimura, D., & Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611\n\nvarphi=-gammaDelta tsqrtleftB_1right^2+left(boldsymbolGcdotboldsymbolx\nright)^2=-gammaDelta tleftVert boldsymbolBrightVert\n\nboldsymboln=boldsymbolBleftVert boldsymbolBrightVert\n\nArguments\n\nφ: (::Real, [rad]) φ angle\nnxy: (::Real) nxy factor\nnz: (::Real) nz factor\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Q rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Un","page":"KomaMRICore","title":"KomaMRICore.Un","text":"Rodrigues' formula: Rotation matrix that when applied rotates with respect to \"n\" in an angle θ anti clock-wise\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rx","page":"KomaMRICore","title":"KomaMRICore.Rx","text":"s = Rx(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to x-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to x-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Rx rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Ry","page":"KomaMRICore","title":"KomaMRICore.Ry","text":"s = Ry(θ)\n\nSpinor counter-clockwise rotation matrix with angle θ with respect to y-axis.\n\nArguments\n\nθ: (::Real, [rad]) angle with respect to y-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Ry rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/3-koma-core/#KomaMRICore.Rz","page":"KomaMRICore","title":"KomaMRICore.Rz","text":"s = Rz(φ)\n\nSpinor counter-clockwise rotation matrix with angle φ with respect to z-axis.\n\nArguments\n\nφ: (::Real, [rad]) angle with respect to z-axis\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Rz rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"explanation/3-phantom-format/#Phantom-File-Format","page":"Phantom File Format","title":"Phantom File Format","text":"","category":"section"},{"location":"explanation/3-phantom-format/#Introduction","page":"Phantom File Format","title":"Introduction","text":"While there is already an open and fairly standardised format for MRI sequences  such as Pulseq, this is not the case for digital phantoms. That's why we defined a new .phantom format, which relies on the HDF5 standard. HDF5 is specially designed to store large amounts of heterogeneous data and to make it readable  and writable quickly and easily. In addition, it allows the storage of metadata.  For all these reasons, it is the ideal file format for storing phantoms.","category":"section"},{"location":"explanation/3-phantom-format/#Phantom-File-I/O","page":"Phantom File Format","title":"Phantom File I/O","text":"The KomaMRIFiles module provides two key functions for working with .phantom files:\n\nread_phantom loads a .phantom and converts it into a Phantom instance.\nwrite_phantom converts a Phantom instance into an HDF5-based .phantom file.","category":"section"},{"location":"explanation/3-phantom-format/#File-Format-Specification","page":"Phantom File Format","title":"File Format Specification","text":"This section describes the internal structure of the .phantom file. While most users will interact with phantoms via the KomaMRI tools, this section is intended for developers who wish to implement support for the format in other applications or workflows.","category":"section"},{"location":"explanation/3-phantom-format/#Phantom-File-Tree","page":"Phantom File Format","title":"Phantom File Tree","text":"<p><img width=\"80%\" src=\"../../assets/ph-file-format.svg\"/></p>","category":"section"},{"location":"explanation/3-phantom-format/#Action-types","page":"Phantom File Format","title":"Action types","text":"<p><img width=\"80%\" src=\"../../assets/ph-actions.svg\"/></p>","category":"section"},{"location":"explanation/3-phantom-format/#TimeCurve","page":"Phantom File Format","title":"TimeCurve","text":"<p><img width=\"80%\" src=\"../../assets/ph-timecurve.svg\"/></p>","category":"section"},{"location":"explanation/3-phantom-format/#SpinSpan-types","page":"Phantom File Format","title":"SpinSpan types","text":"<p><img width=\"80%\" src=\"../../assets/ph-spins.svg\"/></p>","category":"section"},{"location":"tutorial/02-SmallTipApproximation/#Small-Tip-Angle-Approximation","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"(Image: ) (Image: ) (Image: )\n\nBased on the results in page 41 of the book \"Handbook of MRI Pulse Sequences\" by Bernstein et al.\n\nIn this example, we will showcase a common approximation in MRI, the small tip angle approximation. For this, we will simulate a slice profile for spins with positions zin-22mathrmcm and with a gradient G_z so their frequencies are mapped to fin-55mathrmkHz. To start, we define an RF pulse with a flip angle of 30 deg and pulse duration of T_mathrmrf=32mathrmms.\n\nB1 = 4.92e-6\nTrf = 3.2e-3\nzmax = 2e-2\nfmax = 5e3\nz = range(-zmax, zmax, 400)\nGz = fmax / (γ * zmax);\n\nThe designed RF pulse is presented in the figure below, where the additional gradient refocuses the spins' phase after the excitation.\n\nseq = PulseDesigner.RF_sinc(B1, Trf, sys; G=[0;0;Gz], TBP=8)\np2 = plot_seq(seq; max_rf_samples=Inf, slider=false)\n\n<object type=\"text/html\" data=\"../../assets/42-seq.html\" style=\"width:100%; height:380px;\"></object>\n\nNow we will perform the simulation using the function simulate_slice_profile. Note that we modified Δt_rf in sim_params to match the resolution of the waveform.\n\nsim_params = Dict{String, Any}(\"Δt_rf\" => Trf / length(seq.RF.A[1]))\nM = @suppress simulate_slice_profile(seq; z, sim_params)\n\n\nThis produces the following slice profile:\n\n<object type=\"text/html\" data=\"../../assets/4b-profile.html\" style=\"width:100%; height:380px;\"></object>\n\nAs you can see, for a flip angle of 30 deg, the slice profile is very close to the small tip angle approximation (the Fourier transform of B_1(t)).\n\nBut what will happen if we use a flip angle of 120 deg instead?\n\nα_desired = 120 + 0im               # The multiplication of a complex number scales the RF pulse of a Sequence\nα = get_flip_angles(seq)[1]         # Previous FA approx 30 deg\nseq = (α_desired / α) * seq         # Scaling the pulse to have a flip angle of 120\nM = @suppress simulate_slice_profile(seq; z, sim_params);\n\n\n<object type=\"text/html\" data=\"../../assets/4a-profile.html\" style=\"width:100%; height:320px;\"></object>\n\nFor this case, the small tip angle approximation breaks 😢, thus, the reason for its name!\n\nThis basic sinc pulse is not designed to be B_1-insensitive.  Some adiabatic RF pulses have been proposed to achieve this. Watch out for a future example showing these adiabatic RF pulses 👀.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/05-SimpleMotion/#Patient's-Motion-During-Acquisition","page":"Patient's Motion During Acquisition","title":"Patient's Motion During Acquisition","text":"(Image: ) (Image: ) (Image: )\n\nIt can also be interesting to see the effect of the patient's motion during an MRI scan. For this, Koma provides the ability to add motion to the phantom. In this tutorial, we will show how to add a translate motion to a 2D brain phantom.\n\nFirst, let's load the 2D brain phantom used in the previous tutorials:\n\nobj = brain_phantom2D()","category":"section"},{"location":"tutorial/05-SimpleMotion/#Head-Translation","page":"Patient's Motion During Acquisition","title":"Head Translation","text":"In this example, we will add a translate of 2 cm in x, with duration of 200 ms (v = 0.1 m/s):\n\nobj.motion = translate(2e-2, 0.0, 0.0, TimeRange(t_start=0.0, t_end=200e-3))\n\n\n<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom.html\" style=\"width:85%; height:470px;\"></object></center>\n\nIf we simulate an EPI sequence with acquisition duration (183.989 ms) comparable with the motion's duration (200 ms), we will observe motion-induced artifacts in the reconstructed image.\n\n<center>\n<object type=\"text/html\" data=\"../../assets/tut-5-recon1.html\" style=\"width:65%; height:420px;\"></object>\n</center>\n\nThe severity of the artifacts can vary depending on the acquisition duration and k-space trajectory.","category":"section"},{"location":"tutorial/05-SimpleMotion/#Motion-Corrected-Reconstruction","page":"Patient's Motion During Acquisition","title":"Motion-Corrected Reconstruction","text":"To correct for the motion-induced artifacts we can perform a motion-corrected reconstruction. This can be achieved by multiplying each sample of the acquired signal  S(t) by a phase shift Deltaphi_mathrmcorr proportional to the displacement boldsymbolu(t) [Godenschweger, 2016]:\n\nS_mathrmMCleft(tright)=Sleft(tright)cdotmathrme^mathrmiDeltaphi_mathrmcorr=Sleft(tright)cdotmathrme^mathrmi2piboldsymbolkleft(tright)cdotboldsymboluleft(tright)\n\nIn practice, we would need to estimate or measure the motion before performing a motion-corrected reconstruction, but for this example, we will directly use the displacement functions boldsymbolu(boldsymbolx t) defined by obj.motion::MotionList. Since translations are rigid motions (boldsymbolu(boldsymbolx t)=boldsymbolu(t) no position dependence), we can obtain the required displacements by calculating boldsymbolu(boldsymbolx=boldsymbol0 t=t_mathrmadc).\n\nsample_times = get_adc_sampling_times(seq1)\ndisplacements = hcat(get_spin_coords(obj.motion, [0.0], [0.0], [0.0], sample_times)...)\n\n<center><object type=\"text/html\" data=\"../../assets/tut-5-displacements.html\" style=\"width:80%; height:300px;\"></object></center>\n\nWe can now get the necessary phase shift for each sample:\n\n_, kspace = get_kspace(seq1)\nΔΦ = 2π*sum(kspace .* displacements, dims=2);\n\nAnd apply it to the acquired signal to correct its phase:\n\nacq1.kdata[1] .*= exp.(im*ΔΦ)\n\nFinally, we compare the original image ▶️ and the motion-corrected reconstruction ⏸️:\n\n<object type=\"text/html\" data=\"../../assets/tut-5-recon1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/tut-5-recon2.html\" style=\"width:50%; height:420px;\"></object>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/6-koma-mri/#KomaMRI","page":"KomaMRI","title":"KomaMRI","text":"","category":"section"},{"location":"reference/6-koma-mri/#User-Interface","page":"KomaMRI","title":"User Interface","text":"","category":"section"},{"location":"reference/6-koma-mri/#KomaMRI.KomaUI","page":"KomaMRI","title":"KomaMRI.KomaUI","text":"out = KomaUI(; kwargs...)\n\nLaunch the Koma's UI.\n\nKeywords\n\ndarkmode: (::Bool, =true) define dark mode style for the UI\nframe: (::Bool, =true) display the upper frame of the Blink window\nphantom_mode: (::String, =\"2D\", opts=[\"2D\", \"3D\"]) load the default phantom as a   2D or 3D brain example\nsim: (::Dict{String,Any}, =Dict{String,Any}()) simulation parameters dictionary\nrec: (::Dict{Symbol,Any}, =Dict{Symbol,Any}()) reconstruction parameters dictionary\nreturn_window: (::Bool, =false) make the out be either 'nothing' or the Blink window,   depending on whether the return_window keyword argument is set to true\nshow_window: (::Bool, =true) display the Blink window\n\nReturns\n\nout: (::Nothing or ::Blink.AtomShell.Window) returns either 'nothing' or the Blink   window, depending on whether the return_window keyword argument is set to true.\n\nExamples\n\njulia> KomaUI()\n\n\n\n\n\n","category":"function"},{"location":"tutorial/03-ChemicalShiftEPI/#Chemical-Shift-in-an-EPI-sequence","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"(Image: ) (Image: ) (Image: )\n\nFor a more realistic example, we will use a brain phantom.\n\nobj = brain_phantom2D() # a slice of a brain\np1 = plot_phantom_map(obj, :T2 ; height=400, width=400, view_2d=true)\np2 = plot_phantom_map(obj, :Δw ; height=400, width=400, view_2d=true)\n\nAt the left, you can see the T_2 map of the phantom, and at the right, the off-resonance Deltaomega. In this example, the fat is the only source of off-resonance (with Delta f =  -220mathrmHz) and you can see it in black in the off-resonance map.\n\n<object type=\"text/html\" data=\"../../assets/2-phantom1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/2-phantom2.html\" style=\"width:50%; height:420px;\"></object>\n\nThen, we will load an EPI sequence, that is well known for being affected by off-resonance. With this sequence, we will be able visualize the effect of the chemical shift.\n\nseq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/5.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\")\nseq = @suppress read_seq(seq_file)\np3 = plot_seq(seq; range=[0 40], slider=true, height=300)\n\nFeel free to explore the sequence's plot 🔍 below!\n\n<object type=\"text/html\" data=\"../../assets/2-seq.html\" style=\"width:100%; height:320px;\"></object>\n\nIf we simulate this sequence we will end up with the following signal.\n\nraw = @suppress simulate(obj, seq, sys)\np4 = plot_signal(raw; range=[98.4 103.4] , height=300)\n\n<object type=\"text/html\" data=\"../../assets/2-signal.html\" style=\"width:100%; height:320px;\"></object>\n\nNow, we need to inspect what effect the off-resonance had in the reconstructed image. As you can see, the fat layer is now shifted to a different position 🤯, this is why the effect is called chemical shift!\n\n# Get the acquisition data\nacq = AcquisitionData(raw)\nacq.traj[1].circular = false #This is to remove the circular mask\n\n# Setting up the reconstruction parameters\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the recon\nslice_abs = abs.(image[:, :, 1])\np5 = plot_image(slice_abs; height=400)\n\n<center><object type=\"text/html\" data=\"../../assets/2-recon.html\" style=\"width:65%; height:420px;\"></object></center>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"how-to/1-getting-started/#Getting-Started","page":"🏃 Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"how-to/1-getting-started/#Installing-Julia","page":"🏃 Getting Started","title":"Installing Julia","text":"KomaMRI was written in Julia, so the first thing you should do is to install it! The latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"section"},{"location":"how-to/1-getting-started/#Installing-KomaMRI","page":"🏃 Getting Started","title":"Installing KomaMRI","text":"Once Julia is installed, open the Julia REPL, and add the KomaMRI package by typing the following commands:\n\nPress the ] key and then press enter to bring up Julia's package manager.\nType add KomaMRI and then press enter in the package manager session.\n\nThis process should take about 5 minutes in a fresh Julia installation. Here is how it looks in the Julia REPL:\n\njulia> ]\n\n(@v1.9) pkg> add KomaMRI\n\nThen press Ctrl+C or backspace to return to the julia> prompt.\n\n","category":"section"},{"location":"how-to/1-getting-started/#My-First-MRI-Simulation","page":"🏃 Getting Started","title":"My First MRI Simulation","text":"For our first simulation we will use KomaMRI's graphical user interface (GUI). For this, you will first need to load KomaMRI by typing using KomaMRI, and then launch the GUI with the KomaUI function. Note that if you want to run simulations on the GPU (for example, using CUDA), then using CUDA is also necessary (see GPU Parallelization).  \n\njulia> using KomaMRI, CUDA\n\njulia> KomaUI()\n\nThe first time you use this command it may take more time than usual, but a window with the Koma GUI will pop up:\n\n(Image: )\n\nThe user interface has some basic definitions for the scanner, phantom, and sequence already preloaded. So you can immediately interact with the simulation and reconstruction processes, and then visualize the results.\n\nAs a simple demonstration, press the Simulate! button and wait until the simulation is ready. Now you have acquired the Raw Signal and you should see the following:\n\n(Image: )\n\nThen, press the Reconstruct! button and wait until the reconstruction ends. Now you have reconstructed an Image from the Raw Signal and you should see the following in the GUI:\n\n(Image: )\n\nCongratulations, you successfully simulated an MRI acquisition! 🎊","category":"section"},{"location":"tutorial/07-label/#Using-Labels-to-reconstruct-multi-slice-/-multi-contrast-sequences","page":"Using Labels to reconstruct multi-slice / multi-contrast sequences","title":"Using Labels to reconstruct multi-slice / multi-contrast sequences","text":"(Image: ) (Image: ) (Image: )\n\nThis is generally done in pulseq / pypulseq. In that case, the sequence structure automatically contains the labels increment and set extension.\n\nHere we will show how to modify a sequence in KomaMRI to add the extension\n\nusing KomaMRI, PlotlyJS, Suppressor # hide\nsys = Scanner() # hide\nobj = brain_phantom3D()\nobj.Δw .= 0; # Removes the off-resonance","category":"section"},{"location":"tutorial/07-label/#How-to-add-label-to-a-sequence","page":"Using Labels to reconstruct multi-slice / multi-contrast sequences","title":"How to add label to a sequence","text":"Let's add the label to increment the slice for each seq_EPI block. We will add that to the first block of the sequence\n\nseq_EPI = PulseDesigner.EPI_example()\nseq = deepcopy(seq_EPI);\n\nWe can create 2 different types of label \"Increment\" and \"Set\" with LabelInc and LabelSet\n\nlSlcInc = LabelInc(1,\"SLC\");\n\nLet's change the extension field of the first block of seq_EPI in order to add an increment to the SLC label\n\nseq_EPI.EXT[1] = [lSlcInc];\n\nNow let's merge 3 seqEPI. We now have 1 EPI sequence without EXTENSION, then we have an increment of the SLC label, and another one at the beginning of the last seqEPI\n\nseq = seq + seq_EPI + seq_EPI\nplot_seq(seq);\n\nWe can extract the label value with the following function\n\nl = get_label(seq);\n\nAnd store in a vector only the value of the SLC label\n\nSLC_vec = [l[i].SLC for i in eachindex(l)];\n\nThe value is equal to 0 until we reach LabelInc(1,\"SLC)\n\np1 = plot(SLC_vec, Layout(\n    xaxis_title=\"n° blocks\",\n    yaxis_title=\"SLC label\"\n))\n\n\n<object type=\"text/html\" data=\"../../assets/7-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"section"},{"location":"tutorial/07-label/#Simulate-the-acquisition-and-reconstruct-the-data","page":"Using Labels to reconstruct multi-slice / multi-contrast sequences","title":"Simulate the acquisition and reconstruct the data","text":"Define simulation parameters and perform simulation\n\nsim_params = KomaMRICore.default_sim_params()\nraw = @suppress simulate(obj, seq, sys; sim_params)\n\nRawAcquisitionData[SeqName: epi | 303 Profile(s) of 101×1]\n\nThe simulated raw data stored the correct label for each profile\n\nfor p in [1,101,102,203]\n  slc = raw.profiles[p].head.idx.slice |> Int\n  println(\"Profile n°$p : SLC label = $slc\")\nend\n\nProfile n°1 : SLC label = 0\nProfile n°101 : SLC label = 0\nProfile n°102 : SLC label = 1\nProfile n°203 : SLC label = 2\n\n\nMRIReco splits the data into 3 when the data are converted to the AcquisitionData structure. The dimensions are (contrast / slice / repetitions)\n\nacqData = AcquisitionData(raw)\nacqData.kdata |> size\n\n(1, 3, 1)\n\nFor multi-slice acquisition, MRIReco uses the same trajectory. We need to crop the trajectory.\n\nsize_readout = size(acqData.traj[1].nodes,2) / 3 |> Int\nacqData.traj[1].nodes = acqData.traj[1].nodes[1:2,1:size_readout];\n\nWe need to normalize the trajectory to -0.5 to 0.5\n\nC = maximum(2*abs.(acqData.traj[1].nodes[1:2]))\nacqData.traj[1].nodes ./= C\nacqData.traj[1].circular = false # Removing circular window\n\nNx, Ny = raw.params[\"reconSize\"][1:2]\n\nrecParams = Dict{Symbol,Any}()\nrecParams[:reconSize] = (Nx, Ny)\nrecParams[:densityWeighting] = true\nrec = reconstruction(acqData, recParams)\nimage = abs.(reshape(rec,Nx,Ny,:));\n\nLet's take a look at the first 2 images\n\np2 = plot_image(image[:,:,1], height=400);\np3 = plot_image(image[:,:,2], height=400);\n\n\n<object type=\"text/html\" data=\"../../assets/7-seq-2.html\" style=\"width:50%; height:380px;\"></object><object type=\"text/html\" data=\"../../assets/7-seq-3.html\" style=\"width:50%; height:380px;\"></object>\n\nThe signal ponderation is changing because we are acquiring the same slice position with a short TR sequence. Thus, the magnetization is not at equilibrium.","category":"section"},{"location":"tutorial/07-label/#Reconstruction-using-the-labels-LIN-and-PAR","page":"Using Labels to reconstruct multi-slice / multi-contrast sequences","title":"Reconstruction using the labels LIN and PAR","text":"Rather than using the k-space trajectory calculated by KomaMRI and performing a NUFFT for the reconstruction, we can use the label LIN (phase encoding) and PAR (partition encoding).\n\nFirst, we will create an increment label for LIN\n\nseq_LIN = PulseDesigner.EPI_example()\nlInc = LabelInc(1,\"LIN\");\n\nWe can put the increment at any stage between 2 ADC blocks. Here we will put it onto each ADC block.\n\nidx_ADC = is_ADC_on.(seq_LIN)\nfor i in eachindex(idx_ADC)\n  idx_ADC[i] == 1 ? seq_LIN.EXT[i] = [lInc] : nothing;\nend\n\nBecause we want the label of each ADC to start from 0, we set the value to -1 on the first block.\n\nseq_LIN.EXT[1] = [LabelSet(-1,\"LIN\")];\n\nLet's check the LIN label for each ADC\n\nl = get_label(seq_LIN)\nl[idx_ADC][1:10]\n\n10-element Vector{AdcLabels}:\n AdcLabels[ LIN = 0 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 1 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 2 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 3 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 4 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 5 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 6 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 7 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 8 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n AdcLabels[ LIN = 9 | PAR = 0 | SLC = 0 | SEG = 0 | REP = 0 | AVG = 0 | SET = 0 | ECO = 0 | PHS = 0 | NAV = 0 | REV = 0 | SMS = 0 ]\n\nWe can now simulate the results\n\nraw = @suppress simulate(obj, seq_LIN, sys; sim_params)\n\nRawAcquisitionData[SeqName: epi | 101 Profile(s) of 101×1]\n\nIn order to not use the NUFFT reconstruction of MRIReco.jl, we need to change the trajectory name to \"cartesian\"\n\nraw.params[\"trajectory\"] = \"cartesian\"\nraw.params[\"encodedSize\"] = [seq.DEF[\"Nx\"],seq.DEF[\"Ny\"]];\n\nWe also need to estimate the profile center, which will be at the center of the readout. If it is not the case, it should be specified in f.profiles[i].head.center_sample = center_sample and estimateProfileCenter = false\n\nacqData = AcquisitionData(raw,estimateProfileCenter=true);\n\nLet's see the results\n\nrecParams = Dict{Symbol,Any}()\nrec = reconstruction(acqData, recParams);\n\np4=plot_image(abs.(rec[:,:,1]), height=400);\n\n\n<object type=\"text/html\" data=\"../../assets/7-seq-4.html\" style=\"width:65%; height:420px;\"></object>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/07-RRVariability/#Cardiac-Cine-MRI-with-Arrhythmias","page":"Cardiac Cine MRI with Arrhythmias","title":"Cardiac Cine MRI with Arrhythmias","text":"(Image: ) (Image: ) (Image: )\n\nThis tutorial shows how to simulate cardiac cine MRI using Koma, including cases with variable RR intervals (i.e., arrhythmias). You'll learn how to:\n\nSimulate a clean cine acquisition with constant RR intervals.\nIntroduce arrhythmias (variable RR intervals) into the cardiac phantom.\nObserve how this desynchronization degrades image quality.\nCorrect the acquisition by synchronizing the sequence with the phantom’s RR variability (manual triggering).","category":"section"},{"location":"tutorial/07-RRVariability/#1.-Constant-RR-for-Phantom-and-Sequence","page":"Cardiac Cine MRI with Arrhythmias","title":"1. Constant RR for Phantom and Sequence","text":"We will begin by simulating a cardiac cine on a myocardial phantom with a constant RR interval. We'll use the heart_phantom function to create a ring-shaped phantom filled with blood, resembling the left ventricle:\n\nobj = heart_phantom();\n\nBy default, this phantom exhibits periodic contraction and rotation with a 1-second period:\n\n<center><object type=\"text/html\" data=\"../../assets/tut-6-phantom1.html\" style=\"width:90%; height:470px;\"></object></center>\n\nAs shown in previous tutorials, the phantom's motion is defined by its motion field. Until now, this motion has typically consisted of a single Motion component. In this case, however, it consists of two independent motions: a contraction (HeartBeat) and a Rotation. These two are grouped together in a MotionList structure:\n\nobj.motion\n\nMotionList{Float64}(Motion{Float64}[Motion{Float64}\n  action: HeartBeat{Float64}\n  time: TimeCurve{Float64}\n  spins: AllSpins AllSpins()\n, Motion{Float64}\n  action: Rotate{Float64}\n  time: TimeCurve{Float64}\n  spins: AllSpins AllSpins()\n])\n\nNow, we will create a bSSFP cine sequence with the following parameters:\n\nRRs          = [1.0]       # [s] constant RR interval\nN_matrix     = 50          # image size = N x N\nN_phases     = 25          # Number of cardiac phases\nFOV          = 0.11        # [m]\nTR           = 25e-3       # [s]\nflip_angle   = 10          # [º]\nadc_duration = 0.2e-3;     # [s]\n\nseq = bSSFP_cine(\n    FOV, N_matrix, TR, flip_angle, RRs, N_phases, sys;\n    N_dummy_cycles = 40, adc_duration = adc_duration,\n);\n\n\nThe simulation and subsequent reconstruction produces the following cine frames, which look clean and temporally coherent:\n\n<center><object data=\"../../assets/tut-7-frames1.gif\" style=\"width:100%; max-width:325px\"></object></center>","category":"section"},{"location":"tutorial/07-RRVariability/#2.-Arrhythmic-Phantom:-Variable-RR,-Constant-Sequence","page":"Cardiac Cine MRI with Arrhythmias","title":"2. Arrhythmic Phantom: Variable RR, Constant Sequence","text":"Now, we will introduce arrhythmias into the phantom by varying its RR intervals. However, the sequence will still assume a constant RR interval of 1 second.\n\nRRs = [900, 1100, 1000, 1000, 1000, 800] .* 1e-3;\n\nnote: Note\nThe RRs array contains scaling factors relative to the original duration of the phantom’s motion cycle.In this example, the base duration of the cardiac motion is 1 second, which is defined within the t field of its TimeCurve structure. Consequently, the elements in RRs directly represent the actual RR intervals in seconds (e.g., 0.9 s, 1.1 s, etc.).\n\nLet's apply the new RRs to the phantom:\n\n# Take the time curve from the contraction motion:\nt_curve = obj.motion.motions[1].time\n# Generate a new time curve:\nt_curve_new = TimeCurve(\n    t = t_curve.t,\n    t_unit = t_curve.t_unit,\n    periodic = true,\n    periods = RRs\n)\n# Assign the new time curve to both the contraction and the rotation:\nobj.motion.motions[1].time = t_curve_new\nobj.motion.motions[2].time = t_curve_new;\n\nLet’s visualize how the motion pattern has changed, now with variable-duration RR intervals:\n\n<center><object type=\"text/html\" data=\"../../assets/tut-6-phantom2.html\" style=\"width:90%; height:470px;\"></object></center>\n\nSince the sequence still assumes a constant RR interval, it becomes unsynchronized with the phantom. This results in artifacts and temporal inconsistencies in the cine images. We will showcase these images in the next section.","category":"section"},{"location":"tutorial/07-RRVariability/#3.-Prospective-Triggering:-Resynchronized-Acquisition","page":"Cardiac Cine MRI with Arrhythmias","title":"3. Prospective Triggering: Resynchronized Acquisition","text":"To correct this, we synchronize the sequence manually by providing it the same RR intervals as the phantom:\n\nseq = bSSFP_cine(\n    FOV, N_matrix, TR, flip_angle, RRs, N_phases, sys;\n    N_dummy_cycles = 40, adc_duration = adc_duration,\n);\n\nThis approach manually mimics cardiac triggering. The resulting cine is once again correctly aligned, despite the underlying arrhythmia.\n\nIn the future, this synchronization will be handled automatically through upcoming support for trigger extensions in the sequence framework.\n\nBelow, we compare the results of the desynchronized 👎 acquisition simulated in the previous section with the resynchronized 🕐 acquisition:\n\n<center><object data=\"../../assets/tut-7-frames_comparison.gif\" style=\"width:100%\"></object></center>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial-pluto/02-low-field-cmra-optimization/#Low-Field-CMRA-Optimization","page":"Low-Field CMRA Optimization","title":"Low-Field CMRA Optimization","text":"(Image: ) (Image: )\n\n<iframe type=\"text/html\" src=\"../02-low-field-cmra-optimization.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"section"},{"location":"tutorial/README/","page":"-","title":"-","text":"This folder is intentionally left empty. It will be filled by docs/make.jl in the gh-pages branch. \n\nFiles matching the lit-*.jl pattern anywhere in examples/3.tutorials will be included.\n\nAll files included in this folder will be ignored.","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Use-Koma's-User-Interface","page":"Use Koma's User Interface","title":"Use Koma's User Interface","text":"This section provides a comprehensive guide on using the User Interface of the KomaMRI package and delves into the internal processes that occur during interaction. By the end of this section, you will be equipped to execute a complete workflow even without any prior programming experience.\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-simulation.gif\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Basic-Workflow","page":"Use Koma's User Interface","title":"Basic Workflow","text":"(You can also go to analog steps using Scripts)\n\nAs a general overview, remember the following workflow steps when using KomaMRI:\n\nLoading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco\n\nIn the following subsections, we will cover all the mentioned steps. First, open the Julia REPL and enter the following commands to include the KomaMRI package and launch the user interface:\n\njulia> using KomaMRI\n\njulia> KomaUI()\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-dashboard.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Loading-Simulation-Inputs","page":"Use Koma's User Interface","title":"Loading Simulation Inputs","text":"(You can also go to analog steps using Scripts)\n\nThe user interface has preloaded certain inputs into RAM, including the Scanner, Phantom, and Sequence structs. In the following subsections, we will demonstrate how to visualize these inputs.","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Scanner","page":"Use Koma's User Interface","title":"Scanner","text":"You can visualize the preloaded Scanner struct by clicking on the Scanner dropdown and then pressing the View Scanner button. The Scanner struct contains hardware-related information, such as the main magnetic field's magnitude:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-scanner-view.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Phantom","page":"Use Koma's User Interface","title":"Phantom","text":"To see the phantom already stored in RAM, simply click on the Phantom dropdown an then press the View Phantom button. The preloaded phantom is a slice of a brain:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-view.png\"/></p>\n\nIt is also possible to load .h5 phantom files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/2.phantoms/. For instance, let's load the sphere_chemical_shift.h5 file:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-phantom-load.png\"/></p>\n\nNote that you can select different spin parameters to visualize like ρ, T1, T2, among others. ","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Sequence","page":"Use Koma's User Interface","title":"Sequence","text":"There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.\n\nFor visualization of the sequence in the time domain, click on the Sequence dropdown and then press the Sequence (MPS) button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-view.png\"/></p>\n\nFor visualization of the sequence in the k-space, click on the Sequence dropdown and then press the k-space button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-view.png\"/></p>\n\nYou can also display the Moments related to the Sequence by pressing the View Moments and then pressing the buttons for zero, first and second moments.\n\nIt is also possible to load Pulseq compatible .seq sequence files. The KomaMRI has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/1.sequences/. For instance, let's load the spiral.seq file and view it the time domain and k-space:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-time-load.png\"/></p>\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-seq-kspace-load.png\"/></p>\n\nAnd remember, you are free to interact with the plots:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-seq.gif\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Running-Simulation","page":"Use Koma's User Interface","title":"Running Simulation","text":"(You can also go to analog steps using Scripts)\n\nOnce the inputs are loaded in RAM, it is possible to perform the simulation to get the Raw Signal.","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Simulation-Parameters","page":"Use Koma's User Interface","title":"Simulation Parameters","text":"To visualize the default simulation parameters, click on the Simulate! dropdown and then press the View Options button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-sim-params-view.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Raw-Signal","page":"Use Koma's User Interface","title":"Visualization of the Raw Signal","text":"Press the Simulate! button to perform the simulation (this may take a while). Automatically the generated Raw Signal should be displayed or you can click on the Raw Data dropdown and then press the View Raw Data button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-rawsignal-view.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Reconstructing-Image-using-MRIReco","page":"Use Koma's User Interface","title":"Reconstructing Image using MRIReco","text":"(You can also go to analog steps using Scripts)\n\nOnce the Raw Signal is loaded in RAM, it is possible to reconstruct the image.","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Reconstruction-Parameters","page":"Use Koma's User Interface","title":"Reconstruction Parameters","text":"To visualize the default reconstruction parameters, click on the Reconstruct! dropdown and then press the View Options button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-recon-params-view.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Visualization-of-the-Image","page":"Use Koma's User Interface","title":"Visualization of the Image","text":"Press the Reconstruct! button to perform the reconstruction (this may take a while).  Automatically the generated Image should be displayed or you can click on the he Reconstruct! dropdown and then press the |Image| button:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-image-view.png\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#Exporting-Results-to-.mat-File","page":"Use Koma's User Interface","title":"Exporting Results to .mat File","text":"(You can also go to analog steps using Scripts)\n\nThe user interface has the option to save the results in .mat format. Simply click on the Export to .mat and you have the alternatives to get data independently or you can press the All button to have all the results given by the simulator:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/gui-export-to-mat.png\"/></p>\n\nSo far, and due to limitations of the user interface dependencies, the .mat files are saved in the temporal directory of your computer OS, which can be found by typing the tempdir() command in the Julia REPL:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-export-data.gif\"/></p>","category":"section"},{"location":"how-to/2-1-use-koma-ui/#REPL-and-UI-communication","page":"Use Koma's User Interface","title":"REPL and UI communication","text":"An amazing feature of KomaMRI is that it allows you to modify certain variables in the Julia REPL, and then the user interface automatically updates its plots in real-time:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/ui-observables.gif\"/></p>\n\nThe variables that update the interface are:\n\nseq_ui[] for the Sequence\nobj_ui[] for the Phantom\nsys_ui[] for the Scanner\nraw_ui[] for the Raw Signal\nimg_ui[] for the Image\n\nDon't forget to add the brackets [] to these variables, otherwise it won't work.","category":"section"},{"location":"tutorial-pluto/03-low-field-boost-optimization/#Low-Field-BOOST-Optimization","page":"Low-Field BOOST Optimization","title":"Low-Field BOOST Optimization","text":"(Image: ) (Image: )\n\n<iframe type=\"text/html\" src=\"../03-low-field-boost-optimization.html\" style=\"height:100vh;width:100%;\"></iframe>","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Use-Koma-in-Julia-Scripts","page":"Use Koma in Julia Scripts","title":"Use Koma in Julia Scripts","text":"You should already be familiar with the  Graphical User Interface of KomaMRI. However, you can also use this package directly from the Julia REPL or write your own Julia scripts. This allows you to unlock the full potential of KomaMRI, enabling you to utilize more of its functionalities and even test your own MRI ideas.\n\nThis section demonstrates a basic workflow with KomaMRI through writing your own scripts or entering commands directly into the Julia REPL. Let's begin.","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Basic-Workflow","page":"Use Koma in Julia Scripts","title":"Basic Workflow","text":"(You can also go to analog steps using UI)\n\nAs a general overview, remember the following workflow steps when using KomaMRI:\n\nLoading Simulation Inputs: Scanner, Phantom, Sequence\nRunning Simulation\nReconstructing Image using MRIReco\n\nLet's replicate these previous steps in a Julia script. You will obtain the following code, which you can copy and paste into the Julia REPL:\n\n# Import the package\nusing KomaMRI\n\n# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)\n\n# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)\n\nLet's go through this script step by step.","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Loading-Simulation-Inputs","page":"Use Koma in Julia Scripts","title":"Loading Simulation Inputs","text":"(You can also go to analog steps using UI)\n\nThe inputs of the simulation are created in the following part of the script: \n\n# Define scanner, object and sequence\nsys = Scanner()\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Scanner","page":"Use Koma in Julia Scripts","title":"Scanner","text":"The previously created Scanner struct contains default parameters. In your initial simulations, you will likely use this default struct without making any modifications. You can view all the parameters by displaying the struct variable in the Julia REPL. The Scanner's parameters include hardware limitations such as the main magnetic field, maximum gradient values, minimum raster times, and more. You may want to adjust these values for your future custom simulations.\n\njulia> sys\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Δt: Float64 2.0e-6\n  seq_Δt: Float64 1.0e-5\n  GR_Δt: Float64 1.0e-5\n  RF_Δt: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Phantom","page":"Use Koma in Julia Scripts","title":"Phantom","text":"The Phantom struct created in this example represents a slice of a brain. To create it, we use the function brain_phantom2D, which is part of the subdependency KomaMRICore. While KomaMRI provides some phantom examples for experimentation, you may also want to create your custom Phantom struct tailored to your specific requirements.\n\nThe Phantom struct contains MRI parameters related to the magnetization properties of an object. These parameters include magnetization positions, proton density, relaxation times, off-resonance, among others. For more information about Koma's Phantom and what it can do, as well as how to store and share it, check out the Phantom section. To view all the keys and values of the object, you can do so in the Julia REPL as follows:\n\njulia> obj\nPhantom{Float64}\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084,  …  0.086, 0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028,  …  0.0, 0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0,  …  0.0, 0.0]\n  ρ: Array{Float64}((6506,)) [0.7, 0.7,  …  0.7, 0.7]\n  T1: Array{Float64}((6506,)) [0.569, 0.569,  …  0.569, 0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329,  …  0.329, 0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058,  …  0.058, 0.058]\n  Δw: Array{Float64}((6506,)) [-0.0, -0.0,  …  -0.0, -0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0,  …  0.0, 0.0]\n  motion: NoMotion{Float64} NoMotion{Float64}()\n...\n\nYou can also visualize the Phantom struct using the plot_phantom_map function:\n\njulia> plot_phantom_map(obj, :ρ)\n\n<object type=\"text/html\" data=\"../../assets/phantom-rho.html\" style=\"width:100%; height:620px;\"></object>\n\nTo utilize test phantoms included with KomaMRI, navigate to the \"examples\" folder and use the read_phantom_jemris  function to read a phantom in .h5 format. The following steps outline how to do this in Julia:\n\njulia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_sphere = joinpath(path_koma, \"examples\", \"2.phantoms\", \"sphere_chemical_shift.h5\")\njulia> sphere = read_phantom_jemris(path_sphere)\njulia> plot_phantom_map(sphere, :T2)\n\n<object type=\"text/html\" data=\"../../assets/phantom-T2-circle.html\" style=\"width:100%; height:620px;\"></object>","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Sequence","page":"Use Koma in Julia Scripts","title":"Sequence","text":"The Sequence struct in the example represents one of the most basic MRI sequences. It excites the object with a 90° RF pulse and then uses EPI gradients to fill the k-space in a \"square\" manner. While you may want to create your sequences for experiments, you can always use some of the examples already available in KomaMRI.\n\nIn MRI, the sequence must be carefully designed with precise timing to obtain an image. It includes subcomponents such as gradients, radio-frequency excitation signals, and sample acquisition. For more information on constructing a Sequence struct, refer to the Sequence section.\n\nYou can view general information about a Sequence struct by displaying it in the Julia REPL:\n\njulia> seq\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]\n\nFor more precise timing checks, you can use the plot_seq function:\n\njulia> plot_seq(seq; range=[0 30])\n\n<object type=\"text/html\" data=\"../../assets/plot-seq-epi.html\" style=\"width:100%; height:420px;\"></object>\n\nIt is important to consider how the sequence traverses through k-space. The plot_kspace function does precisely that:\n\njulia> plot_kspace(seq)\n\n<object type=\"text/html\" data=\"../../assets/kspace-epi.html\" style=\"width:100%; height:420px;\"></object>\n\nAdditionally, there are helpful sequence construction functions within a submodule of KomaMRI called PulseDesigner. These functions include PulseDesigner.RF_hard, PulseDesigner.RF_sinc, PulseDesigner.EPI, PulseDesigner.radial_base and PulseDesigner.spiral_base. For more details on how to use them, refer to the API documentation.\n\nKomaMRI is also compatible with Pulseq. The package installation includes some .seq files in Pulseq format, which can be read and used as a Sequence struct. Here's how to read a spiral Pulseq file stored in the \"examples\" folder of KomaMRI:\n\njulia> path_koma = dirname(dirname(pathof(KomaMRI)))\njulia> path_spiral = joinpath(path_koma, \"examples\", \"1.sequences\", \"spiral.seq\")\njulia> spiral = read_seq(path_spiral)\njulia> plot_seq(spiral)\njulia> plot_kspace(spiral)\n\n<object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-time.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/seq-spiral-pulseq-kspace.html\" style=\"width:50%; height:420px;\"></object>","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Running-Simulation","page":"Use Koma in Julia Scripts","title":"Running Simulation","text":"(You can also go to analog steps using UI)\n\nThe following lines in the example script configure and perform the simulation:\n\n# Define simulation parameters and perform simulation\nsim_params = KomaMRICore.default_sim_params() \nraw = simulate(obj, seq, sys; sim_params)","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Simulation-Parameters","page":"Use Koma in Julia Scripts","title":"Simulation Parameters","text":"To perform simulations, KomaMRI requires certain parameters. You can use the default parameters for testing, but you also have the option to customize specific simulation aspects. In the example, we use the KomaMRICore.default_sim_params function to create a dictionary with default simulation parameters. You can view the keys that can be modified by displaying the sim_params variable:\n\njulia> sim_params\nDict{String, Any} with 9 entries:\n  \"return_type\" => \"raw\"\n  \"Nblocks\"     => 20\n  \"gpu\"         => true\n  \"Nthreads\"    => 1\n  \"gpu_device\"  => 0\n  \"sim_method\"  => Bloch()\n  \"precision\"   => \"f32\"\n  \"Δt\"          => 0.001\n  \"Δt_rf\"       => 5.0e-5\n\nAll of these parameters deserve special attention. We will explain some of the most important ones here. For instance, \"Δt\" and \"Δt_rf\" represent the raster times for the gradients and RFs. \"return_type\" specifies the type of variable returned by the simulator (by default, it returns an object ready for use with MRIReco for reconstruction, but you can use the value \"mat\" to return a simple vector). \"gpu\" indicates whether you want to use your GPU device for simulations, and \"precision\" sets the floating-point precision. For more details on how to set these parameters, please refer to the Simulation Parameters Section.","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Raw-Signal","page":"Use Koma in Julia Scripts","title":"Raw Signal","text":"The simulation is performed using the simulate function, which requires three arguments: a Scanner struct, a Phantom struct, and a Sequence struct. Optionally, you can include the keyword argument sim_params if you wish to use custom simulation parameters.\n\nIn the example, we can see that the output of the simulation is a special struct:\n\njulia> typeof(raw)\nRawAcquisitionData\n\njulia> raw\nRawAcquisitionData[SeqName: epi | 101 Profile(s) of 101×1]\n\nYou can plot the simulation result with the plot_signal function like so:\n\njulia> plot_signal(raw)\n\n<object type=\"text/html\" data=\"../../assets/raw-epi-brain-default.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Reconstructing-Image-using-MRIReco","page":"Use Koma in Julia Scripts","title":"Reconstructing Image using MRIReco","text":"(You can also go to analog steps using UI)\n\nKomaMRI does not handle reconstruction; instead, you should utilize the MRIReco package to generate an image. For convenience, when you install KomaMRI, you also install MRIReco, allowing you to access functions from that package. You should pay special attention to the RawAcquisitionData and AcquisitionData structs, as well as the reconstruction function.\n\nIn the example below, we define an auxiliary function, reconstruct_2d_image, which takes a raw signal struct, RawAcquisitionData, as input and returns a 2D Array representing an image. Within this function, we create an AcquisitionData struct and set some reconstruction parameters, which serve as inputs for the reconstruction function. The latter function is responsible for the image generation process.\n\n# Auxiliary function for reconstruction\nfunction reconstruct_2d_image(raw::RawAcquisitionData)\n    acqData = AcquisitionData(raw)\n    acqData.traj[1].circular = false #Removing circular window\n    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT\n    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C\n    Nx, Ny = raw.params[\"reconSize\"][1:2]\n    recParams = Dict{Symbol,Any}()\n    recParams[:reconSize] = (Nx, Ny)\n    recParams[:densityWeighting] = true\n    rec = reconstruction(acqData, recParams)\n    image3d  = reshape(rec.data, Nx, Ny, :)\n    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]\n    return image2d\nend\n\n# Perform reconstruction to get the image\nimage = reconstruct_2d_image(raw)\n\nIf you need more information about how to use the AcquisitionData and the how to fill the reconstruction parameters, you need to visit the MRIReco webpage).\n\nTo display the image, you can use the plot_image function which is part of the KomaMRIPlots subpackage:\n\njulia> plot_image(image)\n\n<center><object type=\"text/html\" data=\"../../assets/image-default-brain.html\" style=\"width:100%; height:620px;\"></object></center>","category":"section"},{"location":"how-to/2-3-use-koma-scripts/#Exporting-Results-to-.mat-File","page":"Use Koma in Julia Scripts","title":"Exporting Results to .mat File","text":"(You can also go to analog steps using UI)\n\nMany people in the MRI community uses MATLAB, probably you are one of them and you want to process the raw signal in the MATLAB environment after simulation is done with KomaMRI. Here we show you an example of how to save a .mat file with the information of the raw signal thank to the help of the MAT package:\n\nMany people in the MRI community use MATLAB; you might be one of them and may want to process the Raw Signal in the MATLAB environment after simulation is completed with KomaMRI. Here, we provide an example of how to save a .mat file containing the  Raw Signal information using the MAT package.\n\n# Use the MAT package\nusing MAT\n\n# Perform simulation to return an Array type\nsim_params[\"return_type\"] = \"mat\"\nraw = simulate(obj, seq, sys; sim_params)\n\n# Save the .mat file in the temp directory\nmatwrite(joinpath(tempdir(), \"koma-raw.mat\"), Dict(\"raw\" => raw))\n\nNote that we need to simulate to return an array type (not the default RawAcquisitionData), and then we utilize the matwrite function to save a file named \"koma-raw.mat\" in your computer's temporary directory. Now, you can navigate to your temporary directory (which you can find by displaying the result of tempdir() in the Julia REPL) and locate the \"koma-raw.mat\" file.","category":"section"},{"location":"reference/4-koma-files/#KomaMRIFiles","page":"KomaMRIFiles","title":"KomaMRIFiles","text":"","category":"section"},{"location":"reference/4-koma-files/#Sequence","page":"KomaMRIFiles","title":"Sequence","text":"","category":"section"},{"location":"reference/4-koma-files/#Phantom","page":"KomaMRIFiles","title":"Phantom","text":"","category":"section"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_seq","page":"KomaMRIFiles","title":"KomaMRIFiles.read_seq","text":"seq = read_seq(filename)\n\nReturns the Sequence struct from a Pulseq file with .seq extension.\n\nArguments\n\nfilename: (::String) absolute or relative path of the sequence file .seq\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\nExamples\n\njulia> seq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/spiral.seq\")\n\njulia> seq = read_seq(seq_file)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_jemris","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_jemris","text":"obj = read_phantom_jemris(filename)\n\nReturns the Phantom struct from a JEMRIS phantom file .h5.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .h5\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.h5\")\n\njulia> obj = read_phantom_jemris(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom_MRiLab","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom_MRiLab","text":"obj = read_phantom_MRiLab(filename)\n\nReturns the Phantom struct from a MRiLab phantom file .mat.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .mat\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/2.phantoms/brain.mat\")\n\njulia> obj = read_phantom_MRiLab(obj_file)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.read_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.read_phantom","text":"phantom = read_phantom(filename)\n\nReads a (.phantom) file and creates a Phantom structure from it\n\n\n\n\n\n","category":"function"},{"location":"reference/4-koma-files/#KomaMRIFiles.write_phantom","page":"KomaMRIFiles","title":"KomaMRIFiles.write_phantom","text":"phantom = write_phantom(ph,filename)\n\nWrites a (.phantom) file from a Phantom struct.\n\n\n\n\n\n","category":"function"},{"location":"how-to/5-contribute-to-koma/#Contribute-to-Koma","page":"Contribute to Koma","title":"Contribute to Koma","text":"If you're interested in contributing to Koma, this document will guide you through the setup process. Before you begin, make sure to install and configure a few essential tools on your machine to ensure a smooth development experience:\n\nGit\nGitHub\nVSCode\nVSCode Plugins: \nJulia \nGitHub Pull Requests","category":"section"},{"location":"how-to/5-contribute-to-koma/#Installing-KomaMRI-as-a-developer","page":"Contribute to Koma","title":"Installing KomaMRI as a developer","text":"","category":"section"},{"location":"how-to/5-contribute-to-koma/#1.-Clone-KomaMRI-repository","page":"Contribute to Koma","title":"1. Clone KomaMRI repository","text":"To install the dev version of Koma, we will use the Julia REPL:\n\npkg> dev KomaMRI\n\nThis command will clone KomaMRI.jl's repository (dev version) to your ~/.julia/dev/KomaMRI/ directory if you are in a macOS or Linux operating system, or C:\\Users\\<user-name>\\.julia\\dev\\KomaMRI\\ if you are using Windows, where <user-name> should be replaced with your Windows user.","category":"section"},{"location":"how-to/5-contribute-to-koma/#2.-Create-Your-Fork-Of-KomaMRI","page":"Contribute to Koma","title":"2. Create Your Fork Of KomaMRI","text":"If you try to commit or generate a pull request at this point, you will get an Access denied error. This is because you need to create a fork before you can contribute to this repository directly (unless you are included as a collaborator!).\n\nTo create this fork, go to the official KomaMRI repository and follow the steps below:\n\n(Image: ) (Image: )","category":"section"},{"location":"how-to/5-contribute-to-koma/#3.-Access-Your-GitHub-Account-In-VSCode","page":"Contribute to Koma","title":"3. Access Your GitHub Account In VSCode","text":"Now, you need to ensure that your GitHub account is connected to VSCode. This allows you to clone repositories, create branches, and manage pull requests directly within VSCode.\n\nOpen VSCode.\nGo to the Source Control tab.\nSign in to your GitHub account if you're not already signed in.\n\n💡You can also check if your git credentials are correctly added to your machine by writing in the VSCode terminal:git config --global user.name\ngit config --global user.email","category":"section"},{"location":"how-to/5-contribute-to-koma/#4.-Open-Your-Forked-Repository-In-VSCode","page":"Contribute to Koma","title":"4. Open Your Forked Repository In VSCode","text":"In VSCode, click on File -> Open Folder... and select your ~/.julia/dev/KomaMRI/ directory (C:\\Users\\<user-name>\\.julia\\dev\\KomaMRI\\ if you are using Windows).\n\nNow add the fork URL by clicking Source Control -> ... -> Remote -> Add Remote...\n\n    <img width=\"80%\" src=\"../../assets/add-remote.png\">\n\nThis will create the option to provide a repository URL. Here is where you will paste your fork URL and give it the name my-fork.\n\n(Image: ) (Image: )\n\n💡Press Yes when prompted to constantly fetch in the future.\n\nThe Julia extension should automatically detect the KomaMRI environment. To check this, look at the status bar (bottom) and you should see Julia env: KomaMRI. If this is not the case, click the option in the menu bar and select KomaMRI.jl.","category":"section"},{"location":"how-to/5-contribute-to-koma/#5.-KomaMRI-Monorepo-Setup","page":"Contribute to Koma","title":"5. KomaMRI Monorepo Setup","text":"As KomaMRI.jl contains multiple packages in one GitHub repository, you need to specify that you want to use your local copies (instead of the ones available on the Julia registries) and using the instantiate command to install all the required packages (specified in Project.toml) with the following script:\n\nusing Pkg  \n# Koma sub-packages dev setup  \nkoma_subpkgs = [\"KomaMRICore\", \"KomaMRIFiles\", \"KomaMRIPlots\"]  \nfor pkg in koma_subpkgs  \n    Pkg.activate(pkg)  \n    Pkg.develop(path = \"./KomaMRIBase\")  \nend  \n# Main package (KomaMRI) dev setup  \nPkg.activate(\".\")  \nfor pkg in koma_subpkgs  \n    Pkg.develop(path = \"./$pkg\")  \nend\nPkg.instantiate()\n\nIn case you want to contribute specifically to documentation, you will need to use the docs environment with the following script:\n\nPkg.activate(\"docs\")\nPkg.develop(path = \".\")\nPkg.instantiate()\n\nThis will also include all the specific package versions into the Manifest.toml. The Manifest.toml should not be updated to the repo when making a commit or pull request. Thus, it is present in the .gitignore.","category":"section"},{"location":"how-to/5-contribute-to-koma/#6.-Create-A-New-Branch-For-Your-Feature","page":"Contribute to Koma","title":"6. Create A New Branch For Your Feature","text":"If you correctly followed the previous steps you will have created your fork connected to the original Koma repository. Now, if you want to create your own changes, you will need to create a new branch from your fork.\n\nTo create this new branch, go to Source Control -> ... -> Branch -> Create Branch form...\n\n    <img width=\"80%\" src=\"../../assets/add-branch.png\">\n\nThis will open a menu to select a starting point for your branch. Select my-fork/master as your starting point, and give it the name my-new-feature.\n\n(Image: ) (Image: )\n\n💡In your VSCode terminal use git status to check if your branch is correctly created. Your branch should be listed at the top of the output. ","category":"section"},{"location":"how-to/5-contribute-to-koma/#How-To-Commit","page":"Contribute to Koma","title":"How To Commit","text":"If you have already created your first modifications in your local version of the repository, you will want to commit your changes in your public branch.\n\nTo do this, in VSCode go to the Source Control panel in the Activity Bar.\n\nAssuming you are currently in your my-new-feature branch, the Source Control panel should show your changes to the project and the option to create a commit message.\n\n    <img width=\"40%\" src=\"../../assets/how-to-commit.png\">\n\nIf you hover over the Changes tab, it should show a + icon. Press it to stage all changes in the project.\n\nWrite down a message that describes the changes you are staging to the project, and press the Commit button.\n\nPress Sync Changes to push your commit into your branch (this step is equivalent to git push ...).\n\n💡 If you want to make sure the commit was correctly done, check your GitHub repository and see if the changes you committed are present.","category":"section"},{"location":"how-to/5-contribute-to-koma/#How-to-Test-Your-Contributions","page":"Contribute to Koma","title":"How to Test Your Contributions","text":"Depending on the package where you made your changes, KomaMRIBase, KomaMRICore, KomaMRIFiles, KomaMRIPlots or KomaMRI, follow the instructions below to test them correctly:","category":"section"},{"location":"how-to/5-contribute-to-koma/#Test-KomaMRI:","page":"Contribute to Koma","title":"Test KomaMRI:","text":"In the Julia REPL run the following script:\n\npkg> test\n\nThis should open the UI and all buttons will be clicked to test their functionality.","category":"section"},{"location":"how-to/5-contribute-to-koma/#Test-KomaMRIBase,-KomaMRIFiles-or-KomaMRIPlots:","page":"Contribute to Koma","title":"Test KomaMRIBase, KomaMRIFiles or KomaMRIPlots:","text":"For all of these packages tests look the same. There are two options to run the tests:\n\nTest With VSCode: \n\nOn the activity bar, open the Testing extension, expand the available tests, and select the \"▶\" icon next to the respective package to run the test. The results will be displayed in the Test Results panel. \n\n<img width=\"40%\" src=\"../../assets/test-komamribase.png\">\n\nTest With Julia REPL: \n\nRun the following script after replacing [package] with the selected KomaMRIBase, KomaMRIPlots or KomaMRIFiles package:\n\npkg> test [package]","category":"section"},{"location":"how-to/5-contribute-to-koma/#Test-KomaMRICore:","page":"Contribute to Koma","title":"Test KomaMRICore:","text":"In this package, you may want to run tests using the CPU or GPU. By default the tests will run on the CPU, with the number of threads set to Threads.nthreads(). You can run KomaMRICore tests using the Julia REPL or VSCode, but some changes are required to choose the backend to be tested.\n\nTest With VSCode:\n\nTo run KomaMRICore's tests, on the activity bar, open the Testing extension, expand the available tests, and select the \"▶\" icon next to the word KomaMRICore to run the test. The results will be displayed in the Test Results panel.\n\n    <img width=\"40%\" src=\"../../assets/test-komamricore.png\">\n\nTo change the default backend used for testing, modify the [preferences.KomaMRICore] section in KomaMRICore/test/project.toml file:\n\n[preferences.KomaMRICore]\ntest_backend = \"CPU\"\n\nThe variable test_backend can be changed to “CPU”, “CUDA”, “AMDGPU”, “Metal”, or “oneAPI”. After this change, restart VSCode. Make sure that the required backend is installed in Julia’s global environment before testing. This is, for example, @v1.10 for Julia 1.10.\n\nTest With Julia REPL:\n\nBy default, tests are run on the CPU with the number of threads set to Threads.nthreads(). To choose a specific backend, two methods exist: \n\nMethod 1 - Using Preferences: Add the name of the backend (\"CPU\",\"CUDA\",\"AMDGPU\",\"Metal\", or \"oneAPI\") to the test/Project.toml file in KomaMRICore. Then, test as usual:\n\npkg> test KomaMRICore\n\nMethod 2 - Using Test Arguments: This method is used in Buildkite's CI, and it is best visualised by the use of examples.\n\nExamples:\n\nTo run on the GPU using CUDA:\n\nimport Pkg\n\nPkg.test(\"KomaMRICore\"; test_args=`CUDA`)\n\nTo run on the CPU with a specific number of threads, pass the number of threads as a Julia argument:\n\nimport Pkg\n\nPkg.test(\"KomaMRICore\"; julia_args=`--threads=4`)","category":"section"},{"location":"how-to/5-contribute-to-koma/#Adding-A-New-Test","page":"Contribute to Koma","title":"Adding A New Test","text":"In case your contribution generates a method that is not currently tested, the code coverage will decrease when the pull request is analyzed, creating an automatic comment if the code coverage goes below a threshold.\n\nTo test your function, add a test into the runtests.jl file corresponding to the package where you made your contribution.\n\nTest example:\n\n@testitem \"my math\" tags = [:base] begin # @testitem: Runnable from VSCode (tag them!)\n    @testset \"plus operation\" begin # @testset: Adds a name to section\n        @test 1 + 1 == 2 # @test boolean: Test. You can include multiple tests per section\n        @test 4 + 1 == 5\n    end\n    @testset \"minus operation\" begin\n        @test 1 - 1 == 0\n    end\nend\n\nOnce the file is selected, check whether the contribution to the test fulfills the conditions for an existing @testitem. If not, create a new @testitem.\n\nPlease add tags in your @testitem's for them to work properly. The possible tags are:\n\nKomaMRIBase: :base\nKomaMRICore: You must include :core and one of the following:\nTest uses motion: :motion\nTest does not use motion: :nomotion\nKomaMRIPlots: :plots\nKomaMRIFiles: :files\nKomaMRI: :koma","category":"section"},{"location":"how-to/5-contribute-to-koma/#How-To-Create-A-Pull-Request","page":"Contribute to Koma","title":"How To Create A Pull Request","text":"If you want to send your committed new version of the repository, you can create a pull request that will be reviewed by a Koma certified developer.\n\nTo create this pull request, in VSCode, go to the GitHub Pull Request panel in the Activity Bar and hover over the Pull request tab. This should show a Create pull request icon to press.\n\n    <img width=\"50%\" src=\"../../assets/create-pull-request.png\">\n\nIn the Create tab that appears, select JuliaHealth/master as the base and the branch you are working with to merge.\n\nTo finish your pull request, give it a name with a clear mention of the subject of the contribution you made, and a description that explains the issue or feature you are addressing in your branch, and press the Create button.\n\n    <img width=\"50%\" src=\"../../assets/fill-pull-request.png\">\n\n💡 Tips For A Successful Pull Request:Try to address one issue or feature per pull request to make it easier for reviewers.\nProvide all the context necessary, including all the information of the related issue or added feature.\nRespond to feedback and suggestions to make adjustments based on the reviewers' comments.","category":"section"},{"location":"how-to/5-contribute-to-koma/#(Advanced)-GPU-CI-Testing","page":"Contribute to Koma","title":"(Advanced) GPU CI Testing","text":"KomaMRI runs continuous integration tests on multiple GPU backends (CUDA, AMDGPU, Metal, oneAPI) via Buildkite. To control resource usage and costs, GPU tests are not run by default on pull requests.\n\nIf your contribution affects GPU code, such as files in KomaMRICore/ext/ or simulation kernels, please request @cncastillo to add the run-gpu-ci label to your PR.","category":"section"},{"location":"explanation/4-sequence/#Sequence","page":"Sequence","title":"Sequence","text":"This section delves into some details about how a sequence is constructed. The sequence definition in KomaMRI is strongly related to the Pulseq definition. After reading this section, you should be able to create your own Sequence structs for conducting custom simulations using the KomaMRI package.","category":"section"},{"location":"explanation/4-sequence/#KomaMRI-Sequence-Overview","page":"Sequence","title":"KomaMRI Sequence Overview","text":"Let's introduce the following simple sequence figure to expand from a visual example to a more general sequence definition:\n\n<p align=\"center\"><img width=\"80%\" src=\"../../assets/sequence-diagram.svg\"/></p>\n\nA sequence can be thought of as an ordered concatenation of blocks over time. Each block is essentially a sequence with a length of 1. Every block consists of an RF pulse, the (xyz) gradients, and the acquisition of samples. Each block also has an associated time duration. To simplify, we will refer to these components as follows:\n\nbeginmatrix*l\ntextseqi        textblock i of the sequence \ntextseqRFi     textRF pulse at the i block \ntextseqGRxi   textgradient x at the i block \ntextseqGRyi   textgradient y at the i block \ntextseqGRzi   textgradient z at the i block \ntextseqADCi    textacquisition at the i block \ntextseqDURi    textduration at the i block\nendmatrix*\n\nThe best way to understand the Sequence struct in KomaMRI is by examining the source code where this struct is defined:\n\nmutable struct Sequence\n    GR::Array{Grad,2}\n    RF::Array{RF,2}\n    ADC::Array{ADC,1}\n    DUR::Array{Float64,1}\n    EXT::Vector{Vector{Extension}}\n    DEF::Dict{String,Any}\nend\n\nAs you can see, a Sequence struct contains 6 field names: ''DEF'' contains information for reconstruction steps (so it is not mandatory to fill it), ''DUR'' is a vector that contains the time durations of each block, ''ADC'' is also a vector with the acquisition samples for every block (a vector of ADC structs), ''GR'' is a 2D matrix which 3 rows representing the x-y-z gradients and columns having the samples of each block (a matrix of Grad structs), ''RF'' is also a 2D matrix where each row represents a different coil and the columns are for different block samples too (a matrix of RF structs), and ''EXT'' is a vector of vectors containing extensions for each block, currently it is used to manage labels of a sequence required if you want to fill metadata headers of the MRD format. The RF, Grad, and ADC are MRI events that will be explained in the section Events Definitions.\n\nwarning: Warning\nSo far, KomaMRI can only manage one coil for RF excitations. However, in future versions, parallel transmit pTX will be managed by adding more ``rows'' to the RF matrix of the Sequence field name.\n\nIn order to understand how a Sequence struct can be manipulated in Julia, let's use the EPI sequence example. You can display basic information of the Sequence variable in the Julia REPL:\n\njulia> seq = PulseDesigner.EPI_example()\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | EXT: 0 | DEF: 5 ]\n\nAs you can see, this Sequence has 204 blocks, 1 of these blocks has an RF struct with values different from zero, there are 205 number of Grad structs considering the x-y-z components, 101 ADC structs acquire samples of some blocks and 62.846 ms is the total time duration of the complete Sequence.\n\nTo display the sequence in an graph, we can use the plot_seq function:\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/seq-epi-example-full.html\" style=\"width:100%; height:420px;\"></object>\n\nThis way, you can see exactly where the RF, Grad and ADC structs are located in time.\n\nYou can access and filter information for the RF, Grad, ADC, and DUR field names of a Sequence using the dot notation. This allows you to display helpful information about the organization of the Sequence struct:\n\njulia> seq.RF\n1×204 Matrix{RF}:\n ⊓(0.5872 ms)  ⇿(0.0 ms)  ⇿(0.0 ms)  …  ⇿(0.0 ms)  ⇿(0.0 ms)   \n\njulia> seq.GR\n3×204 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)  …  ⇿(0.2062 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)     ⊓(0.2062 ms)  ⇿(0.4042 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> seq.ADC\n204-element Vector{ADC}:\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ⋮\n ADC(101, 0.00019999999999999998, 0.00010211565434713023, 0.0, 0.0)\n ADC(0, 0.0, 0.0, 0.0, 0.0)\n\njulia> seq.DUR\n204-element Vector{Float64}:\n 0.0005871650124959989\n 0.0004042313086942605\n 0.0004042313086942605\n ⋮\n 0.0004042313086942605\n 0.0004042313086942605\n\nAdditionally, you can access a subset of blocks in a Sequence by slicing or indexing. The result will also be a Sequence struct, allowing you to perform the same operations as you would with a full Sequence (just a heads-up: this is analogous for the Phantom structure). For example, if you want to analyze the first 11 blocks, you can do the following:\n\njulia> seq[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq[1:11].GR\n3×11 Matrix{Grad}:\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⊓(0.4042 ms)   …  ⊓(0.4042 ms)  ⇿(0.2062 ms)  ⊓(0.4042 ms)\n ⇿(0.5872 ms)  ⊓(0.4042 ms)  ⇿(0.4042 ms)      ⇿(0.4042 ms)  ⊓(0.2062 ms)  ⇿(0.4042 ms)\n ⇿(0.5872 ms)  ⇿(0.0 ms)     ⇿(0.0 ms)        ⇿(0.0 ms)     ⇿(0.0 ms)     ⇿(0.0 ms)\n\njulia> plot_seq(seq[1:11]; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/seq-epi-example-some-blocks.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/4-sequence/#Concatenation-of-Sequences","page":"Sequence","title":"Concatenation of Sequences","text":"Sequences can be concatenated side by side. The example below demonstrates how to concatenate sequences:\n\njulia> s = PulseDesigner.EPI_example()[1:11]\nSequence[ τ = 3.837 ms | blocks: 11 | ADC: 5 | GR: 11 | RF: 1 | DEF: 5 ]\n\njulia> seq = s + s + s\nSequence[ τ = 11.512 ms | blocks: 33 | ADC: 15 | GR: 33 | RF: 3 | DEF: 5 ]\n\njulia> plot_seq(seq; slider=false)\n\n<object type=\"text/html\" data=\"../../assets/seq-concatenation.html\" style=\"width:100%; height:420px;\"></object>","category":"section"},{"location":"explanation/2-motion/#Motion","page":"Motion","title":"Motion","text":"(Image: ) (Image: ) (Image: )\n\nKoma can easily simulate the effects of motion during acquisitions. As introduced in the previous section, the motion-related information of the phantom is stored in the motion field of its structure.\n\nKoma's motion model has been designed to accomodate a variety of real-world scenarios, including:\n\nPatient motion inside a scanner, which may involve simultaneous or sequential translations and rotations of body parts during the acquisition.\nMyocardial motion, including simulataneous contraction, rotation, torsion, and translation motion within the cardiac cycle.\nPseudo-periodic heart patterns, caused by variations in heart rate or arrhythmias that prevent the heart's motion from being perfectly periodic.\nFlow through blood vessels, where the spin trajectories or fluid fields may have been obtained from Computational Fluid Dynamics (CFD) simulations.\nDiffusion, which can be modeled, among many other ways, as microscopic Brownian spin trajectories.\n\n... And, ultimately, any type of motion you can think of, no matter how complex!\n\nTo handle these scenarios, Koma represents motion as a collection of elementary movements that can be independently configured and combined. This approach allows for the definition of any complex motion pattern, with the ability to specify overlapping time intervals and even model bidirectional motions along predefined trajectories.","category":"section"},{"location":"explanation/2-motion/#Understanding-the-motion-field-and-its-possible-values","page":"Motion","title":"Understanding the motion field and its possible values","text":"The motion field within the Phantom struct can take different values depending on whether the phantom is static or dynamic. For static phantoms, the field is set to NoMotion. For dynamic phantoms, the field can be either a Motion or a MotionList struct. A Motion represents a single movement, characterized by an action, a time curve, and a range of affected spins. Regarding the MotionList struct, it is simply a collection of Motion instances, which is useful for defining motion compositions.\n\nstruct Phantom{T<:Real}\n    (...)\n    #Motion\n    motion::Union{NoMotion, Motion{T}, MotionList{T}} = NoMotion()\nend","category":"section"},{"location":"explanation/2-motion/#NoMotion-struct","page":"Motion","title":"NoMotion struct","text":"NoMotion is the default type for static phantoms. Since its structure has no fields, making a phantom static is as simple as:\n\nobj.motion = NoMotion();","category":"section"},{"location":"explanation/2-motion/#Motion-struct","page":"Motion","title":"Motion struct","text":"The Motion struct contains information about a basic motion, understood as the combination of an action, a time curve and a spins span. This three fields will be described in detail later. Here is an example of how to assign a motion to a phantom in this case:\n\nobj.motion = Motion(Translate(0.0, 0.1, 0.2), TimeRange(0.0, 1.0), AllSpins());\n\nnote: Note\nThere are Motion constructors that simplify its definition and have the same name as the actions, but written in lowercase. For example:obj.motion = translate(0.0, 0.1, 0.2, TimeRange(0.0, 1.0), AllSpins())This is equivalent to writing:obj.motion = Motion(Translate(0.0, 0.1, 0.2), TimeRange(0.0, 1.0), AllSpins())","category":"section"},{"location":"explanation/2-motion/#MotionList-struct","page":"Motion","title":"MotionList struct","text":"The MotionList struct contains a single field called motions, which is a vector of Motion instances. This design makes it possible to define both sequential and simultaneous concatenations of motions over time. An example of how this would be used is:\n\nobj.motion = MotionList(\n    Motion(Translate(0.0, 0.1, 0.2), TimeRange(0.0, 1.0), AllSpins()),\n    Motion(Rotate(0.0, 0.0, 45.0, (0.0, 0.0, 0.0)), Periodic(1.0, 0.5), SpinRange(1:1000))\n);","category":"section"},{"location":"explanation/2-motion/#The-Motion-structure-and-its-fields","page":"Motion","title":"The Motion structure and its fields","text":"The Motion struct is the basic building block for defining motion in Koma. As we mentioned earlier, it has three main fields: action, time, and spins. Together, these fields define what the motion is, when it happens, and which spins are involved:\n\nstruct Motion{T<:Real}\n    action::AbstractAction{T}\n    time  ::TimeCurve{T}\n    spins ::AbstractSpinSpan\nend","category":"section"},{"location":"explanation/2-motion/#The-action-field","page":"Motion","title":"The action field","text":"Let's start with the action field, which defines the type and magnitude (i.e., the final state) of the motion. Currently, Koma supports five actions: Translate, Rotate, HeartBeat, Path, and FlowPath. The first three fall under the category of SimpleActions, while the last two belong to the ArbitraryActions. SimpleActions are defined by parameters that are easy to understand and use, such as translation distance, rotation angles, or contraction rates. ArbitraryActions, on the other hand, are more complex and can be defined by a set of spin trajectories.","category":"section"},{"location":"explanation/2-motion/#The-time-field","page":"Motion","title":"The time field","text":"The time field defines how the motion behaves over time and must be an instance of the TimeCurve struct, which works similarly to animation curves in video editing, 3D design, or video games. Essentially, it allows you to adjust the \"timing\" of the motion without affecting its magnitude or other characteristics.\n\nGiven an initial and final state (see the action field), time curves allow you to define how the transition between those states should occur. The TimeCurve structure lets you define an animation curve by specifying the coordinates of its points, along with two additional parameters that control its periodicity and pseudo-periodicity:\n\nstruct TimeCurve{T<:Real}\n    t::AbstractVector{T}\n    t_unit::AbstractVector{T}\n    periodic::Bool\n    periods::Union{T,AbstractVector{T}}\nend\n\nThis enables you to create any type of curve, and thus, any kind of motion pattern over time.\n\nA full description of this structure, including examples and constructors, can be found in the TimeCurve API reference.","category":"section"},{"location":"explanation/2-motion/#The-spins-field","page":"Motion","title":"The spins field","text":"Finally, the spins field must be an instance of the AbstractSpinSpan type. It defines which spins in the phantom are affected by the motion, and which of them remain static. This allows you to define motions that only affect a subset of spins, while keeping others unaffected.","category":"section"},{"location":"explanation/2-motion/#See-it-in-action","page":"Motion","title":"See it in action","text":"Now that we have a basic understanding of the motion field and its components, let's see some usage examples. In all cases, we start with the same phantom: a hollow cube with 1 mm side length and 20 µm spin spacing, centered at the origin and aligned with the coordinate axes. To make the motion easier to visualize, each face of the cube is given a different T1 value:\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-phantom.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/2-motion/#Translation-motion","page":"Motion","title":"Translation motion","text":"In this first example, we've added a translational motion of -0.5, 0.6, and 0.7 mm along the three spatial directions. The motion lasts for 1 second and affects the entire phantom:\n\nobj.motion = translate(-5e-4, 6e-4, 7e-4, TimeRange(0.0, 1.0), AllSpins());\n\nLet’s plot this phantom and see how it moves. The time_samples argument specifies the number of time samples to be plotted. You can use the bottom slider to scroll through time and check its exact position at each moment:\n\np1 = plot_phantom_map(obj, :T1; time_samples=11, height=440)\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-translate.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/2-motion/#Rotation-motion","page":"Motion","title":"Rotation motion","text":"In this case, we add a rotational motion to the phantom: 90º around the y-axis and 75º around the z-axis. Like before, the motion lasts for 1 second and affects all spins in the phantom:\n\nobj.motion = rotate(0.0, 90.0, 75.0, TimeRange(0.0, 1.0), AllSpins());\n\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-rotate.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/2-motion/#Adding-motion-to-a-phantom-subset","page":"Motion","title":"Adding motion to a phantom subset","text":"Sometimes, you may want to assign motion to just a part of the phantom instead of the whole thing. This can be done using the SpinRange structure, where you specify the indices of the spins that should be affected. In this example, we apply a translational motion to the upper half of the phantom:\n\nobj.motion = translate(-5e-4, 6e-4, 7e-4, TimeRange(0.0, 1.0), SpinRange(7500:15002));\n\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-subset.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/2-motion/#Motion-combination","page":"Motion","title":"Motion combination","text":"You can freely add multiple motions to a phantom, each with its own type, time span, and affected spin range. These motions can overlap in time (affecting the phantom simultaneously) or happen one after another. Both cases are fully supported, so you're free to combine different effects across various parts of the phantom and time intervals, creating as complex a motion pattern as you need.\n\nThis example shows two brain phantoms undergoing the same translational and rotational motions, but with different time spans. In the top phantom, the translation takes place from 0 to 0.5 seconds, followed by the rotation from 0.5 to 1 second. In the bottom phantom, both motions happen over the same time span, from 0 to 1 second:\n\nobj1.motion = MotionList(\n    translate(40e-2, 0.0, 0.0, TimeRange(0.0, 0.5),AllSpins()),\n    rotate(0.0, 0.0, 90.0, TimeRange(0.5, 1.0),AllSpins()),\n)\n\nobj2.motion = MotionList(\n    translate(40e-2, 0.0, 0.0, TimeRange(0.0, 1.0),AllSpins()),\n    rotate(0.0, 0.0, 90.0, TimeRange(0.0, 1.0),AllSpins()),\n)\n\nobj = obj1 + obj2\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-combination.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/2-motion/#Realistic-head-motion","page":"Motion","title":"Realistic head motion","text":"As a more realistic final example, let's try to replicate the head motion made by a patient inside the scanner. This motion consists of a series of translations and rotations, with the rotation center being the neck:\n\nobj = brain_phantom2D()\n\n\nNintervals = 10\ninterval_dur = 0.1\ntra_x = rand(-5:5, Nintervals) .* 1e-3 # Translation in x [m]\ntra_y = rand(-5:5, Nintervals) .* 1e-3 # Translation in y [m]\nrot_z = rand(-5:5, Nintervals) .* 1e0  # Rotation in z    [º]\nrot_center = (0.0, -3.0, 0.0)  .* 1e-2 # Rotation around the neck\n\nmotion_list = Motion[]\nfor i in 1:Nintervals\n    t_interval = TimeRange(interval_dur * (i-1), interval_dur * i)\n    tra = translate(tra_x[i], tra_y[i], 0.0, t_interval)\n    rot = rotate(0.0, 0.0, rot_z[i], t_interval; center=rot_center)\n    push!(motion_list, [tra, rot]...)\nend\n\nobj.motion = MotionList(motion_list...);\n\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-realistic.html\" style=\"width:85%; height:470px;\"></object></center>\n\n<center><object type=\"text/html\" data=\"../../assets/doc-2-displacements.html\" style=\"width:85%; height:300px;\"></object></center>\n\nA simulation and motion-corrected reconstruction based on a similar, slightly simplified head motion is available here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"explanation/7-gpu-explanation/#GPU-Parallelization","page":"GPU Parallelization","title":"GPU Parallelization","text":"KomaMRI uses a vendor agnostic approach to GPU parallelization in order to support multiple GPU backends. Currently, the following backends are supported:\n\nCUDA.jl (Nvidia)\nMetal.jl (Apple)\nAMDGPU.jl (AMD)\noneAPI.jl (Intel)","category":"section"},{"location":"explanation/7-gpu-explanation/#Choosing-a-GPU-Backend","page":"GPU Parallelization","title":"Choosing a GPU Backend","text":"To determine which backend to use, KomaMRI uses package extensions (introduced in Julia 1.9) to avoid having the packages for each GPU backend as explicit dependencies. This means that the user is responsible for loading the backend package (e.g. using CUDA) at the beginning of their code, or prior to calling KomaUI(), otherwise, Koma will default back to the CPU:\n\nusing KomaMRI\nusing CUDA # loading CUDA will load KomaMRICoreCUDAExt, selecting the backend\n\nOnce this is done, no further action is needed! The simulation objects will automatically be moved to the GPU and back once the simulation is finished. When the simulation is run a message will be shown with either the GPU device being used or the number of CPU threads if running on the CPU.\n\nOf course, it is still possible to move objects to the GPU manually, and control precision using the f32 and f64 functions:\n\nx = rand(100)\nx |> f32 |> gpu # Float32 CuArray\n\nTo change the precision level used for the entire simulation, the sim_params[\"precision\"] parameter can be set to either f32 or f64 (Note that for most GPUs, Float32 operations are considerably faster compared with Float64). In addition, the sim_params[\"gpu\"] option can be set to true or false to enable / disable the gpu functionality (if set to true, the backend package will still need to be loaded beforehand):\n\nTwo other simulation parameters, gpu_groupsize_precession and gpu_groupsize_excitation are exposed to allow adjusting the number of threads in each threadgroup within the run_spin_precession! and run_spin_excitation! gpu kernels. By default, they are both 256, however, on some devices other values may result in faster performance. The gpu groupsize must be a multiple of 32 between 32 and no higher than 1024, otherwise the simulation will throw an error.\n\nusing KomaMRI\nusing CUDA\nsys = Scanner\nobj = brain_phantom2D()\nseq = PulseDesigner.EPI_example()\n\n#Simulate on the GPU using 32-bit floating point values\nsim_params = Dict{String,Any}(\n  \"Nblocks\" => 20,\n  \"gpu\" => true,\n  \"precision\" => \"f32\"\n  \"sim_method\" => Bloch(),\n)\nsimulate(obj, seq, sys; sim_params)","category":"section"},{"location":"explanation/7-gpu-explanation/#How-Objects-are-moved-to-the-GPU","page":"GPU Parallelization","title":"How Objects are moved to the GPU","text":"Koma's gpu function implementation calls a separate gpu function with a backend parameter of type <:KernelAbstractions.GPU for the backend it is using. This function then calls the fmap function from package Functors.jl to recursively call adapt from package Adapt.jl on each field of the object being transferred. This is similar to how many other Julia packages, such as Flux.jl, transfer data to the GPU. However, an important difference is that KomaMRI adapts directly to the KernelAbstractions.Backend type in order to use the adapt_storage functions defined in each backend package, rather than defining custom adapters, resulting in an implementation with fewer lines of code.","category":"section"},{"location":"explanation/7-gpu-explanation/#Inside-the-Simulation","page":"GPU Parallelization","title":"Inside the Simulation","text":"KomaMRI has three different simulation methods, all of which can run on the GPU: \n\nBlochSimple: BlochSimple.jl\nBlochDict: BlochDict.jl\nBloch: BlochCPU.jl / BlochGPU.jl\n\nBlochSimple uses array-based methods which are simpler to understand compared with the more optimized Bloch implementation.\n\nBlochDict can be understood as an extension to BlochSimple that outputs a more detailed signal.\n\nBloch is equivalent to BlochSimple in the operations it performs, but has separate implementations optimized for both the CPU and GPU. The CPU implementation uses array broadcasting for computation and preallocates all simulation arrays to conserve memory. The simulation arrays are 1-dimensional with length equal to the number of spins in the phantom and are updated at each time step. The GPU implementation also uses preallocation and a similar loop-based computation strategy, but does so using kernels for spin precession and excitation implemented using the KernelAbstractions.jl package. A key advantage of using kernel-based methods is that intermediate values compuated based on phantom and sequence properties can be stored in registers without having to write back to GPU global memory, which has much higher memory latency compared with the CPU. Other optimizations within the kernels include:\n\nReducing the output signal value at each time step within the kernel so that the first thread for each thread group writes the sum of the signal values for each thread in the threadgroup to GPU global memory. This reduces the number of GPU global memory reads + writes needed for the output signal from Number of Spins x Number of Time Points to Number of Spins x Number of Time Points / Number of Threads in Threadgroup, improving scalability for large phantom objects.\nUsing julia's Val type to specialize at compile-time on properties unique to the simulation inputs. For example, whether the phantom exibits spin motion is passed as either Val(true) or Val(false) to the precession kernel so that different kernels will be compiled for phantoms with or without motion. For the kernel compiled for phantoms without motion, there will be no runtime check of the motion type of the phantom, and everything inside the if MOTION statements in the kernel will be compiled out, saving register space and enabling further compiler optimizations. This strategy enables adding support in the future for less common use cases without negatively impacting performance for simulations not using these features.\nSince GPU registers are limited and can hurt GPU occupancy if a kernel uses a high number, their use is minimized by working with real and imaginary components directly rather than abstracting complex number math, using unsigned int32 literal values instead of Julia's default Int64, and inlining all functions called from within the kernels.\n\nThe performance differences between Bloch and BlochSimple can be seen on the KomaMRI benchmarks page. The first data point is from when Bloch was what is now BlochSimple, before a more optimized implementation was created. The following pull requests are primarily responsible for the performance differences between Bloch and BlochSimple:\n\n(443) Optimize runspinprecession! and runspinexcitation! for CPU\n(459) Optimize runspinprecession! for GPU\n(462) Optimize runspinexcitation! for GPU\n(537) Faster Bloch GPU","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/#Use-Koma-in-Notebooks","page":"Use Koma in Notebooks","title":"Use Koma in Notebooks","text":"You can use KomaMRI with popular programming environments such as Pluto and Jupyter notebooks. The following sections show how to set up these notebooks and test KomaMRI with them.","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/#Pluto","page":"Use Koma in Notebooks","title":"Pluto","text":"First, install the Pluto module in your Julia environment. Remember to press the ] button to open the Package Manager Session:\n\njulia>\n\n@(1.9) pkg> add Pluto\n\nAfterward, return to the Julia Session by pressing the backspace button, and then execute the Pluto.run() function:\n\njulia> using Pluto\n\njulia> Pluto.run()\n\nThis should automatically open the Pluto dashboard in your default web browser:\n\n<center><img src=\"../../assets/pluto-dashboard.png\" alt=\"\" style=\"width:75%;\"></center>\n\nNext, create a new notebook by clicking on + Create a new notebook:\n\n<center><img src=\"../../assets/pluto-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>\n\nWrite and run the following code, which is identical to the Free Induction Decay example. Pluto automatically installs the required modules if they are not present on your system. Additionally, note that we do not directly use KomaMRI since we won't be utilizing the KomaUI function. Instead, we rely on the KomaMRICore and KomaMRIPlots dependencies. To display plots in Pluto, ensure that you import the PlutoPlotly package, as KomaMRIPlots requires its backend to display figures in Pluto:\n\n<embed type=\"text/html\" src=\"../../assets/pluto-fid-example.html\" style=\"height:1024px;width:100%;\">\n\nOne of the most outstanding features of Pluto is its ability to ensure reproducibility by storing the information necessary to recreate the package environment in the notebook file. When others open your notebook with Pluto, it automatically ensures they use the exact same package environment, guaranteeing seamless functionality on their computers.","category":"section"},{"location":"how-to/2-2-use-koma-notebooks/#Jupyter","page":"Use Koma in Notebooks","title":"Jupyter","text":"Ensure you have Jupyter installed on your computer. Follow this tutorial for installation using Anaconda.\n\nNext, install the IJulia module in your Julia environment. Remember to press the ] key to open the Package Manager Session:\n\njulia>\n\n(@v1.9) pkg> add IJulia\n\nFor this example, make sure to install KomaMRICore and KomaMRIPlots (we do not use KomaMRI directly since we won't be utilizing the KomaUI() function):\n\n(@v1.9) pkg> add KomaMRICore\n\n(@v1.9) pkg> add KomaMRIPlots\n\nNext, open Jupyter, navigate to a working folder, and create a new notebook by clicking on New, then Julia 1.9.3.\"\n\n<center><img src=\"../../assets/jupyter-create-new-notebook.png\" alt=\"\" style=\"width:75%;\"></center>\n\nA new, empty notebook will appear:\n\n<center><img src=\"../../assets/jupyter-empty-notebook.png\" alt=\"\" style=\"width:75%;\"></center>\n\nProceed to write and execute the provided example:\n\n<details><summary>View code</summary>\n\n# Import modules\nusing KomaMRICore, KomaMRIPlots\n\n# Define sequence\nampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF, durRF)\n\nnADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\n\nseq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\n\n# Plot the sequence\nplot_seq(seq; slider=false, height=300)\n\n</details>\n\n<center><img src=\"../../assets/jupyter-test-notebook.png\" alt=\"\" style=\"width:100%;\"></center>\n\nThis should be sufficient, and now you can start working with KomaMRI using Jupyter notebooks.\n\nIf you encounter the issue of WebIO not being detected:\n\n<center><img src=\"../../assets/jupyter-webio-problem.png\" alt=\"\" style=\"width:75%;\"></center>\n\nRefer to this IJulia documentation and this troubleshooting guide for details. Essentially, you need to install a WebIO extension depending on your Jupyter installation.","category":"section"},{"location":"how-to/4-run-distributed-simulations/#Run-Distributed-Simulations","page":"Run Distributed Simulations","title":"Run Distributed Simulations","text":"While KomaMRI provides built-in support for CPU and GPU parallelization, it is sometimes desirable to distribute simulation work even further across multiple GPUs or compute nodes. This can be done by using Distributed.jl and making use of the independent spin property: each spin in the system is independent from the rest, so the phantom spins can be subdivided into separate simulations and results recombined, as in the diagram below:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNode.svg\"/></p>\n\nThe following two examples demonstrate how to use Distributed.jl to run a simulation using multiple GPUS, and using multiple nodes in an HPC cluster.","category":"section"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-GPUs","page":"Run Distributed Simulations","title":"Using Multiple GPUs","text":"To run a simulation using multiple GPUs, the phantom object can be divided using the kfoldperm function. Distributed.jl can then be used to start one Julia worker process per available device so that each device simulates a different part of the object. The results can then be fetched asynchronously by the main process and combined to produce a final signal. This is shown in the following diagram: \n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiGPU.svg\"/></p>\n\nThe SLURM SBATCH script below requests 4 GPUs, all on a single computer. The Julia code then distributes work among each GPU:\n\ndetails: SLURM Script Requesting Multiple GPUs\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --ntasks=1                                 # 1 task\n#SBATCH --cpus-per-task=1                          # Request 1 CPU\n#SBATCH --gpus=4                                   # Request 4 GPUs\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl\n\nusing Distributed\nusing CUDA\n\n#Add workers based on the number of available devices\naddprocs(length(devices()))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI, CUDA\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    #Divide phantom\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    KomaMRICore.set_device!(i-1) #Sets device for this worker, note that CUDA devices are indexed from 0\n    simulate(obj[parts[i]], seq, sys)\nend","category":"section"},{"location":"how-to/4-run-distributed-simulations/#Using-Multiple-Nodes-in-an-HPC-Cluster","page":"Run Distributed Simulations","title":"Using Multiple Nodes in an HPC Cluster","text":"This example uses the package ClusterManagers.jl to initialize worker processes on a SLURM cluster based on the number of tasks specified in the #SBATCH –ntasks directive. This can be useful to divide simulation work among multiple compute nodes if the problem is too large to fit into memory for a single computer, or if the number of desired workers is greater than the typical number of CPU cores available. An illustration of this is shown below:\n\n<p align=\"center\"><img width=\"90%\" src=\"../../assets/KomamultiNodeCPU.svg\"/></p>\n\nThis SBATCH script requests 20 separate nodes, with each taking a single task. The Julia code is similar to the example for multiple GPUs, but initializes the processes slightly differently:\n\ndetails: SLURM Script Requesting Multiple Nodes\n#!/bin/bash\n#SBATCH --job-name KomaDistributed                 # Job name\n#SBATCH -t 0-00:30                                 # Max runtime for job\n#SBATCH -p batch                                   # Enter partition on which to run the job\n#SBATCH --nodes=20                                 # 20 nodes\n#SBATCH --ntasks=20                                # 20 tasks\n#SBATCH --ntasks-per-node=1                        # 1 task per node\n#SBATCH --cpus-per-task=4                          # 4 CPUs per task\n#SBATCH -o /mnt/workspace/%u/slurm-out/%test.out   # Enter file path to write stdout to\n#SBATCH -e /mnt/workspace/%u/slurm-out/%test.err   # Enter file path to write stderr to\n\nmodule load julia/1.10.2\njulia script.jl\n\nusing Distributed\nusing ClusterManagers\n\n#Add workers based on the specified number of SLURM tasks\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])))\n\n#Define inputs on each worker process\n@everywhere begin\n    using KomaMRI\n    sys = Scanner()\n    seq = PulseDesigner.EPI_example()\n    obj = brain_phantom2D()\n    parts = kfoldperm(length(obj), nworkers())\nend\n\n#Distribute simulation across workers\nraw = Distributed.@distributed (+) for i=1:nworkers()\n    simulate(obj[parts[i]], seq, sys)\nend","category":"section"},{"location":"explanation/1-phantom/#Phantom","page":"Phantom","title":"Phantom","text":"(Image: ) (Image: ) (Image: )\n\nThe first input argument that KomaMRI needs for simulating is the phantom.\n\nThis section goes over the concept of digital phantom and shows how it applies to the specific case of KomaMRI. We'll go into detail about the Phantom structure and its supported operations.","category":"section"},{"location":"explanation/1-phantom/#Digital-Phantom","page":"Phantom","title":"Digital Phantom","text":"A digital phantom is basically a computer model of a physical object (like the human body or a body part) which is used  in simulations to mimic the characteristics and behaviour that would be obtained from real MRI. Instead of using a physical object for testing, the digital phantom allows for virtual experiments.\n\nThis computer model should essentially contain information about the position and/or displacements of the tissues, as well as their MRI-related (T1, T2, PD, off-resonance...) values.","category":"section"},{"location":"explanation/1-phantom/#KomaMRI-Phantom-Overview","page":"Phantom","title":"KomaMRI Phantom Overview","text":"In Koma, a phantom is made up of a set of spins (which in many cases are also known as ''isochromats''). Each spin is independent of the others in terms of properties, position and state. This is a key feature of KomaMRI, as it is explained in the Simulation section.\n\nLet's take a look at the definition of the Phantom struct inside Koma's source code to see what it looks like:\n\n@with_kw mutable struct Phantom{T<:Real}\n    name::String = \"spins\"\n    x::AbstractVector{T}\n    y::AbstractVector{T}   = zeros(eltype(x), size(x))\n    z::AbstractVector{T}   = zeros(eltype(x), size(x))\n    ρ::AbstractVector{T}   = ones(eltype(x), size(x))\n    T1::AbstractVector{T}  = ones(eltype(x), size(x)) * 1_000_000\n    T2::AbstractVector{T}  = ones(eltype(x), size(x)) * 1_000_000\n    T2s::AbstractVector{T} = ones(eltype(x), size(x)) * 1_000_000\n    #Off-resonance related\n    Δw::AbstractVector{T}  = zeros(eltype(x), size(x))\n    #Diffusion\n    Dλ1::AbstractVector{T} = zeros(eltype(x), size(x))\n    Dλ2::AbstractVector{T} = zeros(eltype(x), size(x))\n    Dθ::AbstractVector{T}  = zeros(eltype(x), size(x))\n    #Motion\n    motion::Union{NoMotion, Motion{T}, MotionList{T}} = NoMotion()\nend\n\nThis structure consists of several elements. Most of them are vectors, except for the name (self-explanatory) and motion (explained below) fields. These vectors represent object properties, with each element holding a value associated with a single magnetization (i.e. a single spin). Specifically, x, y and z are the initial spatial coordinates of each spin. ρ stands for the proton density, and T1, T2 and T2s (standing for T2*) are the well-known relaxation times. Δw accounts for off-resonance effects. Dλ1, Dλ2 and Dθ are diffusion-related fields which are not in use at the moment. Last, the motion field stands for spin displacements, which are added to x, y and z when simulating in order to obtain the spin positions at each time step. For more information about motion, refer to Motion section.\n\nTo get an even better understanding on how this structure works, let's look at an example of a brain phantom:\n\nobj = brain_phantom2D()\n\nPhantom{Float64}\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084, -0.084  …  0.084, 0.084, 0.084, 0.084, 0.086, 0.086, 0.086, 0.086, 0.086, 0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028, -0.026, -0.024, -0.022, -0.02, -0.018, -0.016, -0.014, -0.012  …  0.006, 0.008, 0.01, 0.012, -0.008, -0.006, -0.004, -0.002, 0.0, 0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0  …  0.0, 0.0, 0.0, 0.0, -0.0, -0.0, -0.0, -0.0, 0.0, 0.0]\n  ρ: Array{Float64}((6506,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  T1: Array{Float64}((6506,)) [0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569  …  0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569, 0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329  …  0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329, 0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058  …  0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058, 0.058]\n  Δw: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  motion: NoMotion NoMotion()\n\n\nYou can visualize the Phantom struct using the plot_phantom_map function, which is part of the KomaMRIPlots subdependency. This function plots the magnitude of a property for each magnetization at a specific spatial position. You can observe properties such as proton density and relaxation times, so feel free to replace the :T1 symbol with another property of the phantom in the example below:\n\np1 = plot_phantom_map(obj, :T1; height=450)\n\n<center><object type=\"text/html\" data=\"../../assets/doc-1-phantom.html\" style=\"width:85%; height:470px;\"></object></center>\n\nYou can access and filter information for the all the field names of a Phantom using the dot notation:\n\nobj.name\n\n\"brain2D_axial\"\n\nobj.x\n\n6506-element Vector{Float64}:\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n -0.084\n  ⋮\n  0.084\n  0.084\n  0.084\n  0.086\n  0.086\n  0.086\n  0.086\n  0.086\n  0.086\n\nobj.motion\n\nNoMotion()","category":"section"},{"location":"explanation/1-phantom/#Phantom-Operations","page":"Phantom","title":"Phantom Operations","text":"In addition, KomaMRI supports some phantom operations:","category":"section"},{"location":"explanation/1-phantom/#Phantom-Subset","page":"Phantom","title":"Phantom Subset","text":"It is possible to access a subset of spins in a Phantom by slicing or indexing. The result will also be a Phantom struct, allowing you to perform the same operations as you would with a full Phantom:\n\nobj[1:2000]\n\n<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom-subset.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/1-phantom/#Combination-of-Phantoms","page":"Phantom","title":"Combination of Phantoms","text":"In the same way, we can add two or more phantoms, resulting in another Phantom struct:\n\nobj2 = pelvis_phantom2D()\nobj_sum = obj + obj2\n\n<center><object type=\"text/html\" data=\"../../assets/tut-5-phantom-sum.html\" style=\"width:85%; height:470px;\"></object></center>","category":"section"},{"location":"explanation/1-phantom/#Scalar-multiplication-of-a-Phantom","page":"Phantom","title":"Scalar multiplication of a Phantom","text":"Finally, multiplying a phantom by a scalar multiplies its proton density (ρ) by that amount:\n\nobj_mul = 3*obj;\n\nobj.ρ\n\n6506-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n ⋮\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\nobj_mul.ρ\n\n6506-element Vector{Float64}:\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n ⋮\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0\n 3.0","category":"section"},{"location":"explanation/1-phantom/#Phantom-Storage-and-Sharing","page":"Phantom","title":"Phantom Storage and Sharing","text":"Phantoms can be stored and shared thanks to our new Phantom File Format.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase","page":"KomaMRIBase","title":"KomaMRIBase","text":"","category":"section"},{"location":"reference/2-koma-base/#Scanner-related-functions","page":"KomaMRIBase","title":"Scanner-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#Phantom-related-functions","page":"KomaMRIBase","title":"Phantom-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#Motion-related-functions","page":"KomaMRIBase","title":"Motion-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#Motionconstructors","page":"KomaMRIBase","title":"Motionconstructors","text":"","category":"section"},{"location":"reference/2-koma-base/#AbstractAction-types","page":"KomaMRIBase","title":"AbstractAction types","text":"","category":"section"},{"location":"reference/2-koma-base/#TimeCurve-types-and-related-functions","page":"KomaMRIBase","title":"TimeCurve types and related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#AbstractSpinSpan-types","page":"KomaMRIBase","title":"AbstractSpinSpan types","text":"","category":"section"},{"location":"reference/2-koma-base/#Sequence-related-functions","page":"KomaMRIBase","title":"Sequence-related functions","text":"","category":"section"},{"location":"reference/2-koma-base/#Grad","page":"KomaMRIBase","title":"Grad","text":"","category":"section"},{"location":"reference/2-koma-base/#RF","page":"KomaMRIBase","title":"RF","text":"","category":"section"},{"location":"reference/2-koma-base/#ADC","page":"KomaMRIBase","title":"ADC","text":"","category":"section"},{"location":"reference/2-koma-base/#Delay","page":"KomaMRIBase","title":"Delay","text":"","category":"section"},{"location":"reference/2-koma-base/#Rotation-matrices","page":"KomaMRIBase","title":"Rotation matrices","text":"","category":"section"},{"location":"reference/2-koma-base/#Moments","page":"KomaMRIBase","title":"Moments","text":"","category":"section"},{"location":"reference/2-koma-base/#Event-checks","page":"KomaMRIBase","title":"Event checks","text":"","category":"section"},{"location":"reference/2-koma-base/#DiscreteSequence","page":"KomaMRIBase","title":"DiscreteSequence","text":"","category":"section"},{"location":"reference/2-koma-base/#Other-functions","page":"KomaMRIBase","title":"Other functions","text":"","category":"section"},{"location":"reference/2-koma-base/#Sequence-Building-Blocks-(SBB)","page":"KomaMRIBase","title":"Sequence Building Blocks (SBB)","text":"","category":"section"},{"location":"reference/2-koma-base/#KomaMRIBase.Scanner","page":"KomaMRIBase","title":"KomaMRIBase.Scanner","text":"sys = Scanner(B0, B1, Gmax, Smax, ADC_Δt, seq_Δt, GR_Δt, RF_Δt,\n    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)\n\nThe Scanner struct. It contains hardware limitations of the MRI resonator. It is an input for the simulation.\n\nArguments\n\nB0: (::Real, =1.5, [T]) main magnetic field strength\nB1: (::Real, =10e-6, [T]) maximum RF amplitude\nGmax: (::Real, =60e-3, [T/m]) maximum gradient amplitude\nSmax: (::Real, =500, [mT/m/ms]) gradient's maximum slew-rate\nADC_Δt: (::Real, =2e-6, [s]) ADC raster time\nseq_Δt: (::Real, =1e-5, [s]) sequence-block raster time\nGR_Δt: (::Real, =1e-5, [s]) gradient raster time\nRF_Δt: (::Real, =1e-6, [s]) RF raster time\nRF_ring_down_T: (::Real, =20e-6, [s]) RF ring down time\nRF_dead_time_T: (::Real, =100e-6, [s]) RF dead time\nADC_dead_time_T: (::Real, =10e-6, [s]) ADC dead time\n\nReturns\n\nsys: (::Scanner) Scanner struct\n\nExamples\n\njulia> sys = Scanner()\n\njulia> sys.B0\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Phantom","page":"KomaMRIBase","title":"KomaMRIBase.Phantom","text":"obj = Phantom(name, x, y, z, ρ, T1, T2, T2s, Δw, Dλ1, Dλ2, Dθ, motion)\n\nThe Phantom struct. Most of its field names are vectors, with each element associated with a property value representing a spin. This struct serves as an input for the simulation.\n\nArguments\n\nname: (::String) phantom name\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nρ: (::AbstractVector{T<:Real}) spin proton density vector\nT1: (::AbstractVector{T<:Real}, [s]) spin T1 parameter vector\nT2: (::AbstractVector{T<:Real}, [s]) spin T2 parameter vector\nT2s: (::AbstractVector{T<:Real}, [s]) spin T2s parameter vector\nΔw: (::AbstractVector{T<:Real}, [rad/s]) spin off-resonance parameter vector\nDλ1: (::AbstractVector{T<:Real}) spin Dλ1 (diffusion) parameter vector\nDλ2: (::AbstractVector{T<:Real}) spin Dλ2 (diffusion) parameter vector\nDθ: (::AbstractVector{T<:Real}) spin Dθ (diffusion) parameter vector\nmotion: (::Union{NoMotion, Motion{T<:Real} MotionList{T<:Real}}) motion\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = Phantom(x=[0.0])\n\njulia> obj.ρ\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom2D","text":"phantom = brain_phantom2D(;axis=\"axial\", ss=4)\n\nCreates a two-dimensional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\naxis: (::String, =\"axial\", opts=[\"axial\", \"coronal\", \"sagittal\"]) orientation of the phantom\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy], if used ss is set to ss=1\ntissue_properties: (::Dict, =Dict()) phantom tissue properties in SI units considering the available tissues\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = brain_phantom2D(; axis=\"sagittal\", ss=1)\n\njulia> obj = brain_phantom2D(; axis=\"axial\", us=[1, 2])\n\njulia> phantom_values = \n    Dict(\n        # ρ, T1, T2, T2*, Δw\n        \"CSF\"           => [1,      2.569,  0.329,  0.058,  0],\n        \"GM\"            => [0.86,   0.833,  0.083,  0.069,  0],\n        \"WM\"            => [0.77,   0.500,  0.070,  0.061,  0],\n        \"FAT1\"          => [0,      0,      0,      0,      0],\n        \"MUSCLE\"        => [0,      0,      0,      0,      0],\n        \"SKIN/MUSCLE\"   => [0,      0,      0,      0,      0],\n        \"SKULL\"         => [0,      0,      0,      0,      0],\n        \"VESSELS\"       => [0,      0,      0,      0,      0],\n        \"FAT2\"          => [0,      0,      0,      0,      0],\n        \"DURA\"          => [0,      0,      0,      0,      0],\n        \"MARROW\"        => [0,      0,      0,      0,      0])\njulia> obj = brain_phantom2D(; tissue_properties=phantom_values)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.brain_phantom3D","page":"KomaMRIBase","title":"KomaMRIBase.brain_phantom3D","text":"obj = brain_phantom3D(; ss=4, us=1, start_end=[160,200])\n\nCreates a three-dimentional brain Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm. \n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb/tissuemrparameters.txt\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 3 element vector [ssx, ssy, ssz]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 3 element vector [usx, usy, usz]\nstart_end: (::Vector{Integer}, =[160,200]) z index range of presampled phantom, 180 is center\ntissue_properties: (::Dict, =Dict()) phantom tissue properties in SI units considering the available tissues\n\nReturns\n\nobj: (::Phantom) 3D Phantom struct\n\nExamples\n\njulia> obj = brain_phantom3D(; ss=5)\n\njulia> obj = brain_phantom3D(; us=[2, 2, 1])\n\njulia> phantom_values = \n    Dict(\n        # ρ, T1, T2, T2*, Δw\n        \"CSF\"           => [1,      2.569,  0.329,  0.058,  0],\n        \"GM\"            => [0.86,   0.833,  0.083,  0.069,  0],\n        \"WM\"            => [0.77,   0.500,  0.070,  0.061,  0],\n        \"FAT1\"          => [0,      0,      0,      0,      0],\n        \"MUSCLE\"        => [0,      0,      0,      0,      0],\n        \"SKIN/MUSCLE\"   => [0,      0,      0,      0,      0],\n        \"SKULL\"         => [0,      0,      0,      0,      0],\n        \"VESSELS\"       => [0,      0,      0,      0,      0],\n        \"FAT2\"          => [0,      0,      0,      0,      0],\n        \"DURA\"          => [0,      0,      0,      0,      0],\n        \"MARROW\"        => [0,      0,      0,      0,      0])\njulia> obj = brain_phantom3D(; tissue_properties=phantom_values)\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.pelvis_phantom2D","page":"KomaMRIBase","title":"KomaMRIBase.pelvis_phantom2D","text":"obj = pelvis_phantom2D(; ss=4, us=1)\n\nCreates a two-dimensional pelvis Phantom struct. Default ss=4 sample spacing is 2 mm. Original file (ss=1) sample spacing is .5 mm.\n\nKeywords\n\nss: (::Integer or ::Vector{Integer}, =4) subsampling parameter for all axes if scaler, per axis if 2 element vector [ssx, ssy]\nus: (::Integer or ::Vector{Integer}, =1)  upsampling parameter for all axes if scaler, per axis if 2 element vector [usx, usy]\n\nReturns\n\nobj: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = pelvis_phantom2D(; ss=2])\n\njulia> obj = pelvis_phantom2D(; us=[1, 2])\n\njulia> pelvis_phantom2D(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.heart_phantom","page":"KomaMRIBase","title":"KomaMRIBase.heart_phantom","text":"obj = heart_phantom(\n    circumferential_strain, radial_strain, rotation_angle; \n    heart_rate, asymmetry\n)\n\nHeart-like LV 2D phantom. The variable circumferential_strain and radial_strain are for streching (if positive)  or contraction (if negative). rotation_angle is for rotation.\n\nKeywords\n\ncircumferential_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nradial_strain: (::Real, =-0.3) contraction parameter. Between -1 and 1\nrotation_angle: (::Real, =15.0, [º]) maximum rotation angle\nheart_rate: (::Real, =60, [bpm]) heartbeat frequency\ntemporal_asymmetry: (::Real, =0.2) time fraction of the period in which the systole occurs. Therefore, diastole lasts for period * (1 - temporal_asymmetry)\n\nReturns\n\nobj: (::Phantom) Heart-like LV phantom struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.NoMotion","page":"KomaMRIBase","title":"KomaMRIBase.NoMotion","text":"nomotion = NoMotion()\n\nNoMotion struct. It is used to create static phantoms.\n\nReturns\n\nnomotion: (::NoMotion) NoMotion struct\n\nExamples\n\njulia> nomotion = NoMotion()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Motion","page":"KomaMRIBase","title":"KomaMRIBase.Motion","text":"motion = Motion(action)\nmotion = Motion(action, time)\nmotion = Motion(action, time, spins)\n\nMotion struct. It defines the motion, during a certain time interval, of a given group of spins. It is composed by three fields: action, which  defines the motion itself, time, which accounts for the time during which the motion takes place, and spins, which indicates the spins  that are affected by that motion.\n\nArguments\n\naction: (::AbstractAction{T<:Real}) action, such as Translate or Rotate\ntime: (::TimeCurve{T<:Real}, =TimeRange(0.0)) time information about the motion\nspins: (::AbstractSpinSpan, =AllSpins()) spin indexes affected by the motion\n\nReturns\n\nmotion: (::Motion) Motion struct\n\nExamples\n\njulia> motion =  Motion(\n            action = Translate(0.01, 0.0, 0.02),\n            time = TimeRange(0.0, 1.0),\n            spins = SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.MotionList","page":"KomaMRIBase","title":"KomaMRIBase.MotionList","text":"motionlist = MotionList(motions...)\n\nMotionList struct. The other option, instead of NoMotion,  is to define a dynamic phantom by means of the MotionList struct. It is composed by one or more Motion instances. \n\nArguments\n\nmotions: (::Vector{Motion{T<:Real}}) vector of Motion instances\n\nReturns\n\nmotionlist: (::MotionList) MotionList struct\n\nExamples\n\njulia>  motionlist = MotionList(\n            Motion(\n                action = Translate(0.01, 0.0, 0.02),\n                time = TimeRange(0.0, 1.0),\n                spins = AllSpins()\n            ),\n            Motion(\n                action = Rotate(0.0, 0.0, 45.0),\n                time = Periodic(1.0),\n                spins = SpinRange(1:10)\n            )\n        )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_spin_coords","page":"KomaMRIBase","title":"KomaMRIBase.get_spin_coords","text":"x, y, z = get_spin_coords(motion, x, y, z, t)\n\nCalculates the position of each spin at a set of arbitrary time instants, i.e. the time steps of the simulation.  For each dimension (x, y, z), the output matrix has N_\tspins rows and length(t) columns.\n\nArguments\n\nmotion: (::Union{NoMotion, Motion{T<:Real} MotionList{T<:Real}}) phantom motion\nx: (::AbstractVector{T<:Real}, [m]) spin x-position vector\ny: (::AbstractVector{T<:Real}, [m]) spin y-position vector\nz: (::AbstractVector{T<:Real}, [m]) spin z-position vector\nt: horizontal array of time instants\n\nReturns\n\nx, y, z: (::Tuple{AbstractArray, AbstractArray, AbstractArray}) spin positions over time\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.translate","page":"KomaMRIBase","title":"KomaMRIBase.translate","text":"tr = translate(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\ntr: (::Motion) Motion struct\n\nExamples\n\njulia> tr = translate(0.01, 0.02, 0.03, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.rotate","page":"KomaMRIBase","title":"KomaMRIBase.rotate","text":"rt = rotate(pitch, roll, yaw, spins)\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nKeywords\n\ncenter: (::NTuple{3,Real} or ::CenterOfMass) center of rotation, given in global coordinates. Default is center of mass.\n\nReturns\n\nrt: (::Motion) Motion struct with Rotate action\n\nExamples\n\njulia> rt = rotate(15.0, 0.0, 20.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.heartbeat","page":"KomaMRIBase","title":"KomaMRIBase.heartbeat","text":"hb = heartbeat(circumferential_strain, radial_strain, longitudinal_strainl, time, spins)\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nhb: (::Motion) Motion struct with HeartBeat action\n\nExamples\n\njulia> hb = heartbeat(-0.3, -0.2, 0.0, TimeRange(0.0, 1.0), SpinRange(1:10))\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.path","page":"KomaMRIBase","title":"KomaMRIBase.path","text":"pt = path(dx, dy, dz, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\npt: (::Motion) Motion struct with Path action\n\nExamples\n\njulia> pt = path(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.flowpath","page":"KomaMRIBase","title":"KomaMRIBase.flowpath","text":"fp = flowpath(dx, dy, dz, spin_reset, time, spins)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\ntime: (::TimeCurve{T<:Real}) time information about the motion\nspins: (::AbstractSpinSpan) spin indexes affected by the motion\n\nReturns\n\nfp: (::Motion) Motion struct with FlowPath action\n\nExamples\n\njulia> fp = flowpath(\n          [0.01 0.02; 0.02 0.03], \n          [0.02 0.03; 0.03 0.04], \n          [0.03 0.04; 0.04 0.05], \n          [false false; false true],\n          TimeRange(0.0, 1.0), \n          SpinRange(1:10)\n       )\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.Translate","page":"KomaMRIBase","title":"KomaMRIBase.Translate","text":"t = Translate(dx, dy, dz)\n\nTranslate struct. It produces a linear translation. Its fields are the final displacements in the three axes (dx, dy, dz).\n\nArguments\n\ndx: (::Real, [m]) translation in x\ndy: (::Real, [m]) translation in y \ndz: (::Real, [m]) translation in z\n\nReturns\n\nt: (::Translate) Translate struct\n\nExamples\n\njulia> t = Translate(dx=0.01, dy=0.02, dz=0.03)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Rotate","page":"KomaMRIBase","title":"KomaMRIBase.Rotate","text":"r = Rotate(pitch, roll, yaw, center=CenterOfMass())\n\nRotate struct. It produces a rotation in the three axes:  x (pitch), y (roll), and z (yaw). We follow the RAS (Right-Anterior-Superior) orientation,  and the rotations are applied following the right-hand rule (counter-clockwise):\n\n(Image: Head Rotation Axis)\n\nThe applied rotation matrix is obtained as follows: \n\nbeginequation\nbeginaligned\nR = R_z(alpha) R_y(beta) R_x(gamma) \n  = beginbmatrix\ncos alpha  -sin alpha  0 \nsin alpha  cos alpha  0 \n0  0  1\nendbmatrix\nbeginbmatrix\ncos beta  0  sin beta \n0  1  0 \n-sin beta  0  cos beta\nendbmatrix\nbeginbmatrix\n1  0  0 \n0  cos gamma  -sin gamma \n0  sin gamma  cos gamma\nendbmatrix \n  = beginbmatrix\ncos alpha cos beta  cos alpha sin beta sin gamma - sin alpha cos gamma  cos alpha sin beta cos gamma + sin alpha sin gamma \nsin alpha cos beta  sin alpha sin beta sin gamma + cos alpha cos gamma  sin alpha sin beta cos gamma - cos alpha sin gamma \n-sin beta  cos beta sin gamma  cos beta cos gamma\nendbmatrix\nendaligned\nendequation\n\nArguments\n\npitch: (::Real, [º]) rotation in x\nroll: (::Real, [º]) rotation in y \nyaw: (::Real, [º]) rotation in z\ncenter: (::NTuple{3,Real} or ::CenterOfMass) optional center of rotation, given in global coordinates. Default is center of mass.\n\nNotes\n\nRotations are applied around the point specified in center. If omitted, the rotation is centered at the phantom’s center of mass.\nIf center is not ::CenterOfMass, the rotation center is interpreted as a fixed point in space (absolute/global coordinates).\nThis design ensures that consecutive or inverse rotations behave consistently and predictably, since the rotation center does not change with object transformations.\n\nReturns\n\nr: (::Rotate) Rotate struct\n\nExamples\n\njulia> r = Rotate(pitch=15.0, roll=0.0, yaw=20.0)\n\njulia> r = Rotate(pitch=0.0, roll=45.0, yaw=0.0, center=(5e-3,0.0,0.0))\n# Rotates around a point 5 mm to the right of the center of mass\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.HeartBeat","page":"KomaMRIBase","title":"KomaMRIBase.HeartBeat","text":"h = HeartBeat(circumferential_strain, radial_strain, longitudinal_strain)\n\nHeartBeat struct. It produces a heartbeat-like motion, characterised by three types of strain: circumferential, radial and longitudinal\n\nArguments\n\ncircumferential_strain: (::Real) contraction parameter\nradial_strain: (::Real) contraction parameter\nlongitudinal_strain: (::Real) contraction parameter\n\nReturns\n\nh: (::HeartBeat) HeartBeat struct\n\nExamples\n\njulia> h = HeartBeat(circumferential_strain=-0.3, radial_strain=-0.2, longitudinal_strain=0.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Path","page":"KomaMRIBase","title":"KomaMRIBase.Path","text":"p = Path(dx, dy, dz)\n\nPath struct. For this action (and for FlowPath), motion is not defined solely on the basis of  three numerical parameters, one for each spatial direction, as occurs for the Translate, Rotate and HeartBeat actions.\n\nFor this action, it is necessary to define  motion for each spin independently, in x (dx), y (dy) and z (dz). dx, dy and dz are now three matrixes, of (N_spins* times  N_discretetimes) each. This means that each row corresponds to a spin trajectory over a set of discrete time instants.\n\nnote: Note\n*When creating a motion with Flow or FlowPath, you must make sure that  the number of rows of the matrices dx, dy and dz matches the number  of spins that are affected by the motion. Remember that the range of spins affected by a motion  is defined by the spins field of the Motion structexample:julia> motion = Motion(\n    action = Path(\n        dx=[0.01 0.02; 0.02 0.03],  # 2 rows\n        dy=[0.02 0.03; 0.03 0.04], \n        dz=[0.03 0.04; 0.04 0.05]),\n    time = TimeRange(0.0, 1.0),\n    spins = SpinRange(1:2)          # 2 spins\n)\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\n\nReturns\n\np: (::Path) Path struct\n\nExamples\n\njulia> p = Path(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 0.05]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.FlowPath","page":"KomaMRIBase","title":"KomaMRIBase.FlowPath","text":"f = FlowPath(dx, dy, dz, spin_reset)\n\nFlowPath struct. This action is the same as Path,  except that it includes an additional field, called spin_reset,  which accounts for spins leaving the volume and being remapped  to another input position. When this happens, the magnetization  state of these spins must be reset during the simulation. \n\nAs with the dx, dy and dz matrices, spin_reset has a size of (N_spins times  N_discretetimes).\n\nArguments\n\ndx: (::AbstractArray{T<:Real}, [m]) displacements in x\ndy: (::AbstractArray{T<:Real}, [m]) displacements in y \ndz: (::AbstractArray{T<:Real}, [m]) displacements in z\nspin_reset: (::AbstractArray{Bool}) reset spin state flags\n\nReturns\n\nf: (::FlowPath) FlowPath struct\n\nExamples\n\njulia> f = FlowPath(\n           dx=[0.01 0.02; 0.02 0.03], \n           dy=[0.02 0.03; 0.03 0.04], \n           dz=[0.03 0.04; 0.04 -0.04],\n           spin_reset=[false false; false true]\n       )\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.TimeCurve","page":"KomaMRIBase","title":"KomaMRIBase.TimeCurve","text":"timecurve = TimeCurve(t, t_unit, periodic, periods)\n\nTimeCurve struct. It is a specialized type that defines a time curve, which represents  the temporal behavior of motion. This curve is defined by two vectors:  t and t_unit, which represent the horizontal (x-axis) and vertical (y-axis) axes  of the curve, respectively. To some extent, this curve can be associated with animation curves, commonly found in software for video editing, 3D scene creation, or video game development.\n\nAdditionally, the TimeCurve struct contains two more fields, independent of each other: periodic is a Boolean that indicates whether the time curve should be repeated periodically. periods contains as many elements as repetitions are desired in the time curve.  Each element specifies the scaling factor for that repetition.\n\nArguments\n\nt: (::AbstractVector{<:Real}, [s]) time vector\nt_unit: (::AbstractVector{<:Real}) y vector, it needs to be scaled between 0 and 1. 0    represents the start of the motion, while 1 represents the end.    The values in between represent the intermediate states of the motion.\nperiodic: (::Bool, =false) indicates whether the time curve should be periodically repeated\nperiods: (::Union{<:Real,AbstractVector{<:Real}}, =1.0): represents the relative duration    of each period with respect to the baseline duration defined by t[end] - t[1].    In other words, it acts as a scaling factor to lengthen or shorten specific periods.    This allows for the creation of patterns such as arrhythmias or other variations in periodicity.\n\nReturns\n\ntimecurve: (::TimeCurve) TimeCurve struct\n\nExamples\n\n1. Non-periodic motion with a single repetition: \n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 0.2, 0.5, 1.0])\n\n(Image: Time Curve 1)\n\n2. Periodic motion with a single repetition:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periodic=true)\n\n(Image: Time Curve 2)\n\n3. Non-periodic motion with multiple repetitions:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5])\n\n(Image: Time Curve 3)\n\n4. Periodic motion with multiple repetitions:\n\njulia> timecurve = TimeCurve(t=[0.0, 0.2, 0.4, 0.6], t_unit=[0.0, 1.0, 1.0, 0.0], periods=[1.0, 0.5, 1.5], periodic=true)\n\n(Image: Time Curve 4)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.TimeRange","page":"KomaMRIBase","title":"KomaMRIBase.TimeRange","text":"timerange = TimeRange(t_start, t_end)\n\nThe TimeRange function is a custom constructor for the TimeCurve struct.  It allows defining a simple time interval, with start and end times.\n\nArguments\n\nt_start: (::Real, [s], =0.0) start time\nt_end: (::Real, [s], =1.0) end time\n\nReturns\n\ntimerange: (::TimeCurve) TimeCurve struct\n\nExamples\n\njulia> timerange = TimeRange(t_start=0.6, t_end=1.4)\n\n(Image: Time Range)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.Periodic","page":"KomaMRIBase","title":"KomaMRIBase.Periodic","text":"periodic = Periodic(period, asymmetry)\n\nThe Periodic function is a custom constructor for the TimeCurve struct. It allows defining time intervals that repeat periodically with a triangular period.  It includes a measure of asymmetry in order to recreate a asymmetric period.\n\nArguments\n\nperiod: (::Real, [s], =1.0) period duration\nasymmetry: (::Real, =0.5) temporal asymmetry factor. Between 0 and 1.\n\nReturns\n\nperiodic: (::TimeCurve) TimeCurve struct\n\nExamples\n\njulia> periodic = Periodic(period=1.0, asymmetry=0.2)\n\n(Image: Periodic)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.AllSpins","page":"KomaMRIBase","title":"KomaMRIBase.AllSpins","text":"allspins = AllSpins()\n\nAllSpins struct. It is a specialized type that inherits from AbstractSpinSpan and is used to cover all the spins of a phantom.\n\nReturns\n\nallspins: (::AllSpins) AllSpins struct\n\nExamples\n\njulia> allspins = AllSpins()\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.SpinRange","page":"KomaMRIBase","title":"KomaMRIBase.SpinRange","text":"spinrange = SpinRange(range)\n\nSpinRange struct. It is a specialized type that inherits from AbstractSpinSpan and is used to select a certain range and number of spins.\n\nArguments\n\nrange: (::AbstractVector) spin id's. This argument can be a Range, a Vector or a BitVector\n\nReturns\n\nspinrange: (::SpinRange) SpinRange struct\n\nExamples\n\njulia> spinrange = SpinRange(1:10)\njulia> spinrange = SpinRange([1, 3, 5, 7])\njulia> spinrange = SpinRange(obj.x .> 0)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Sequence","page":"KomaMRIBase","title":"KomaMRIBase.Sequence","text":"seq = Sequence()\nseq = Sequence(GR)\nseq = Sequence(GR, RF)\nseq = Sequence(GR, RF, ADC)\nseq = Sequence(GR, RF, ADC, DUR)\nseq = Sequence(GR::Array{Grad,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)\n\nThe Sequence struct. It contains events of an MRI sequence. Most field names (except for the DEF field) consist of matrices or vectors, where each column index represents a sequence block. This struct serves as an input for the simulation.\n\nArguments\n\nGR: (::Matrix{Grad}) gradient matrix. Rows for x-y-z amplitudes and columns are for blocks\nRF: (::Matrix{RF}) RF matrix. The 1 row is for the coil and columns are for blocks\nADC: (::Array{ADC,1}) ADC block vector\nDUR: (::Vector, [s]) duration block vector\nDEF: (::Dict{String, Any}) dictionary with relevant information of the sequence.   Possible keys could be [\"AdcRasterTime\", \"GradientRasterTime\", \"Name\", \"Nz\",   \"Num_Blocks\", \"Nx\", \"Ny\", \"PulseqVersion\", \"BlockDurationRaster\",   \"FileName\", \"RadiofrequencyRasterTime\"]\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.dur","page":"KomaMRIBase","title":"KomaMRIBase.dur","text":"y = dur(x::Grad)\ny = dur(x::Vector{Grad})\ny = dur(x::Matrix{Grad})\n\nDuration time in [s] of Grad struct or Grad Array.\n\nArguments\n\nx: (::Grad or ::Vector{Grad} or ::Matrix{Grad}) Grad struct or Grad Array\n\nReturns\n\ny: (::Float64, [s]) duration of the Grad struct or Grad Array\n\n\n\n\n\ny = dur(x::RF)\ny = dur(x::Vector{RF})\ny = dur(x::Matrix{RF})\n\nDuration time in [s] of RF struct or RF Array.\n\nArguments\n\nx: (::RF or ::Vector{RF} or ::Matrix{RF}) RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) duration of the RF struct or RF array\n\n\n\n\n\nT = dur(x::Sequence)\n\nThe total duration of the sequence in [s].\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\nT: (::Real, [s]) total duration of the sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_block_start_times","page":"KomaMRIBase","title":"KomaMRIBase.get_block_start_times","text":"T0 = get_block_start_times(seq::Sequence)\n\nReturns a vector containing the start times of blocks in a sequence. The initial time is always zero, and the final time corresponds to the duration of the sequence.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nReturns\n\nT0: (::Vector, [s]) start times of the blocks in a sequence\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angles","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angles","text":"y = get_flip_angles(x::Sequence)\n\nReturns all the flip angles of the RF pulses in the sequence x.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Vector{Float64}, [deg]) flip angles\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(A, T)\ngr = Grad(A, T, rise)\ngr = Grad(A, T, rise, delay)\ngr = Grad(A, T, rise, fall, delay)\ngr = Grad(A, T, rise, fall, delay, first, last)\n\nThe Grad struct represents a gradient of a sequence event.\n\nArguments\n\nA: (::Real or ::Vector, [T/m]) amplitude of the gradient\nT: (::Real or ::Vector, [s]) duration of the flat-top\nrise: (::Real, [s]) duration of the rise\nfall: (::Real, [s]) duration of the fall\ndelay: (::Real, [s]) duration of the delay\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gr = Grad(1, 1, 0.1, 0.1, 0.2)\n\njulia> seq = Sequence([gr]); plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.Grad-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.Grad","text":"gr = Grad(f::Function, T::Real, N::Integer; delay::Real)\n\nGenerates an arbitrary gradient waveform defined by the function f in the interval t ∈ [0,T]. The time separation between two consecutive samples is given by T/(N-1).\n\nArguments\n\nf: (::Function) function that describes the gradient waveform\nT: (::Real, [s]) duration of the gradient waveform\nN: (::Integer, =300) number of samples of the gradient waveform\n\nKeywords\n\ndelay: (::Real, =0, [s]) delay time of the waveform\n\nReturns\n\ngr: (::Grad) gradient struct\n\nExamples\n\njulia> gx = Grad(t -> sin(π*t / 0.8), 0.8)\n\njulia> seq = Sequence([gx]); plot_seq(seq)\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.RF","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF(A, T)\nrf = RF(A, T, Δf)\nrf = RF(A, T, Δf, delay)\n\nThe RF struct represents a Radio Frequency excitation of a sequence event.\n\nArguments\n\nA: (::Complex, [T]) RF complex amplitud modulation (AM), B_1(t) = B_1(t)   e^iphi(t) = B_1(t) + iB_1y(t)\nT: (::Real, [s]) RF duration\nΔf: (::Real or ::Vector, [Hz]) RF frequency difference with respect to the Larmor frequency.   This can be a number but also a vector to represent frequency modulated signals (FM).\ndelay: (::Real, [s]) RF delay time\ncenter: (::Real, [s]) RF center time\nuse: (::RFUse) RF use type\n\nReturns\n\nrf: (::RF) the RF struct\n\nExamples\n\njulia> rf = RF(1, 1, 0, 0.2)\n\njulia> seq = Sequence(); seq += rf; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.RF-Tuple{Function, Real, Int64}","page":"KomaMRIBase","title":"KomaMRIBase.RF","text":"rf = RF_fun(f::Function, T::Real, N::Int64)\n\nGenerate an RF sequence with amplitudes sampled from a function waveform.\n\nnote: Note\nThis function is not being used in this KomaMRI version.\n\nArguments\n\nf: (::Function, [T]) function for the RF amplitud waveform\nT: (::Real, [s]) duration of the RF pulse\nN: (::Int64) number of samples of the RF pulse\n\nReturns\n\nrf:(::RF) RF struct with amplitud defined by the function f\n\n\n\n\n\n","category":"method"},{"location":"reference/2-koma-base/#KomaMRIBase.get_flip_angle","page":"KomaMRIBase","title":"KomaMRIBase.get_flip_angle","text":"α = get_flip_angle(x::RF)\n\nCalculates the flip angle α [deg] of an RF struct. α = γ ∫ B1(τ) dτ\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nα: (::Int64, [deg]) flip angle RF struct x\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.ADC","page":"KomaMRIBase","title":"KomaMRIBase.ADC","text":"adc = ADC(N, T)\nadc = ADC(N, T, delay)\nadc = ADC(N, T, delay, Δf, ϕ)\n\nThe ADC struct represents the Analog to Digital Converter (ADC) of a sequence event.\n\nArguments\n\nN: (::Int64) number of acquired samples\nT: (::Float64, [s]) duration to acquire the samples\ndelay: (::Float64, [s]) delay time to start the acquisition\nΔf: (::Float64, [Hz]) delta frequency. It is meant to compensate RF pulse phases\nϕ: (::Float64, [rad]) phase. It is meant to compensate RF pulse phases\n\nReturns\n\nadc: (::ADC) ADC struct\n\nExamples\n\njulia> adc = ADC(16, 1, 0.1)\n\njulia> seq = Sequence(); seq += adc; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_sampling_times","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_sampling_times","text":"times = get_adc_sampling_times(seq)\n\nReturns an array of times when the samples of the sequence seq are acquired.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ntimes: (::Vector{Float64}, [s]) time array when samples are acquired\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_adc_phase_compensation","page":"KomaMRIBase","title":"KomaMRIBase.get_adc_phase_compensation","text":"comp = get_adc_phase_compensation(seq)\n\nReturns an array of phase compensation factors, exp(-mathrmivarphi), which are used to compensate the acquired signal S by applying the operation S_mathrmcomp = S exp(-mathrmivarphi) after the simulation. This compensation is necessary because the signal typically exhibits a phase offset of varphi following RF excitation with a phase of varphi. Such pulses are commonly employed in sequences involving RF spoiling.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ncomp: (::Vector{Complex}, [rad]) array of phase compensations for every acquired sample\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.Delay","page":"KomaMRIBase","title":"KomaMRIBase.Delay","text":"delay = Delay(T)\n\nThe Delay struct is meant to add a delay to a sequence by using a sum operator.\n\nArguments\n\nT: (::Real, [s]) time delay value\n\nReturns\n\ndelay: (::Delay) delay struct\n\nExamples\n\njulia> delay = Delay(0.5)\n\njulia> s = Sequence([Grad(1, 1, 0.1)])\n\njulia> seq = delay + s; plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.rotx","page":"KomaMRIBase","title":"KomaMRIBase.rotx","text":"Rx = rotx(θ::Real)\n\nRotates vector counter-clockwise with respect to the x-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRx: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.roty","page":"KomaMRIBase","title":"KomaMRIBase.roty","text":"Ry = roty(θ::Real)\n\nRotates vector counter-clockwise with respect to the y-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRy: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.rotz","page":"KomaMRIBase","title":"KomaMRIBase.rotz","text":"Rz = rotz(θ::Real)\n\nRotates vector counter-clockwise with respect to the z-axis.\n\nArguments\n\nθ: (::Real, [rad]) rotation angle\n\nReturns\n\nRz: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_Mk","page":"KomaMRIBase","title":"KomaMRIBase.get_Mk","text":"Mk, Mk_adc = get_Mk(seq::Sequence, k; Δt=1)\n\nComputes the kth-order moment of the Sequence seq given by the formula int_0^T t^k G(t) dt.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nk: (::Integer) order of the moment to be computed\nΔt: (::Real, =1, [s]) nominal delta time separation between two time samples   for ADC acquisition and Gradients\n\nReturns\n\nMk: (3-column ::Matrix{Real}) kth-order moment\nMk_adc: (3-column ::Matrix{Real}) kth-order moment sampled at ADC times\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_kspace","page":"KomaMRIBase","title":"KomaMRIBase.get_kspace","text":"Computes the k-space trajectory of the Sequence seq. Refer to get_Mk and get_M0\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M0","page":"KomaMRIBase","title":"KomaMRIBase.get_M0","text":"Computes the zero-order moment of the Sequence seq. Refer to get_Mk and get_kspace\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M1","page":"KomaMRIBase","title":"KomaMRIBase.get_M1","text":"Computes the 1st-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_M2","page":"KomaMRIBase","title":"KomaMRIBase.get_M2","text":"Computes the 2nd-order moment of the Sequence seq. Refer to get_Mk\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_RF_on","page":"KomaMRIBase","title":"KomaMRIBase.is_RF_on","text":"y = is_RF_on(x::Sequence)\ny = is_RF_on(x::Sequence, t::Vector{Float64})\n\nTells if the sequence seq has elements with RF active, or active during time t.\n\nArguments\n\nx: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the RF in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_GR_on","page":"KomaMRIBase","title":"KomaMRIBase.is_GR_on","text":"y = is_GR_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GR in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gx_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gx_on","text":"y = is_Gx_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in x direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRx in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gy_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gy_on","text":"y = is_Gy_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in y direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRy in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_Gz_on","page":"KomaMRIBase","title":"KomaMRIBase.is_Gz_on","text":"y = is_Gz_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in z direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRz in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.is_ADC_on","page":"KomaMRIBase","title":"KomaMRIBase.is_ADC_on","text":"y = is_ADC_on(x::Sequence)\ny = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})\n\nTells if the sequence seq has elements with ADC active, or active during time t.\n\nArguments\n\nx: (::Sequence) sequence struct\nt: (::Union{Array{Float64,1}, Array{Float64,2}}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the ADC in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.DiscreteSequence","page":"KomaMRIBase","title":"KomaMRIBase.DiscreteSequence","text":"seqd = DiscreteSequence(Gx, Gy, Gz, B1, Δf, ADC, t, Δt)\n\nA sampled version of a Sequence struct, containing vectors for event amplitudes at specified times. DiscreteSequence is the struct used for simulation.\n\nArguments\n\nGx: (::AbstractVector{T<:Real}, [T/m]) x-gradient vector\nGy: (::AbstractVector{T<:Real}, [T/m]) y-gradient vector\nGz: (::AbstractVector{T<:Real}, [T/m]) z-gradient vector\nB1: (::AbstractVector{Complex{T<:Real}}, [T]) RF amplitude vector\nΔf: (::AbstractVector{T<:Real}, [Hz]) RF carrier frequency displacement vector\nADC: (::AbstractVector{Bool}) ADC sample vector\nt: (::AbstractVector{T<:Real}, [s]) time vector\nΔt: (::AbstractVector{T<:Real}, [s]) delta time vector\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"type"},{"location":"reference/2-koma-base/#KomaMRIBase.discretize","page":"KomaMRIBase","title":"KomaMRIBase.discretize","text":"seqd = discretize(seq::Sequence; sampling_params=default_sampling_params())\n\nThis function returns a sampled Sequence struct with RF and gradient time refinements based on simulation parameters.\n\nArguments\n\nseq: (::Sequence) sequence\n\nKeywords\n\nsampling_params: (::Dict{String, Any}, =default_sampling_params()) sampling   parameter dictionary\n\nReturns\n\nseqd: (::DiscreteSequence) DiscreteSequence struct\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.get_samples","page":"KomaMRIBase","title":"KomaMRIBase.get_samples","text":"samples = get_samples(seq::Sequence; off_val=0, max_rf_samples=Inf)\n\nReturns the samples of the events in seq.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\noff_val: (::Number, =0) offset value for amplitude. Typically used to hide points in   plots by setting it to Inf\nmax_rf_samples: (::Integer, =Inf) maximum number of samples for the RF struct\n\nReturns\n\nsamples: (::NamedTuple) contains samples for gx, gy, gz, rf, and adc events.   Each event, represented by e::NamedTuple, includes time samples (e.t) and amplitude   samples (e.A)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.times","page":"KomaMRIBase","title":"KomaMRIBase.times","text":"t = times(gr::Grad)\nt = times(rf::RF)\nt = times(adc::ADC)\n\nGet time samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nt: (::Vector{Number}) vector with time samples\n\n\n\n\n\ntimes & unit_time \n\n\n\n\n\ntimes = times(motion)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.ampls","page":"KomaMRIBase","title":"KomaMRIBase.ampls","text":"A = ampls(g::Grad)\nA = ampls(r::RF)\nA = ampls(d::ADC)\n\nGet amplitude samples of MRI sequence event.\n\nArguments\n\ngr: (::Grad) Gradient struct\nrf: (::RF) RF struct\nadc: (::ADC) ADC struct\n\nReturns\n\nA: (::Vector{Number}) vector with amplitude samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.freqs","page":"KomaMRIBase","title":"KomaMRIBase.freqs","text":"f = freqs(r::RF)\n\nGet frequency samples of MRI sequence event.\n\nArguments\n\nrf: (::RF) RF struct\n\nReturns\n\nf: (::Vector{Number}) vector with frequency samples\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.trapz","page":"KomaMRIBase","title":"KomaMRIBase.trapz","text":"y = trapz(Δt, x)\n\nTrapezoidal integration for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Δt for all the spins. NΔt is the length of Δt. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x 1 ::Matrix{Float64}, [T*s]) vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.cumtrapz","page":"KomaMRIBase","title":"KomaMRIBase.cumtrapz","text":"y = cumtrapz(Δt, x)\n\nTrapezoidal cumulative integration over time for every spin of a phantom.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x NΔt ::Matrix{Float64}, [T*s]) matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a   phantom\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.kfoldperm","page":"KomaMRIBase","title":"KomaMRIBase.kfoldperm","text":"array_of_ranges = kfoldperm(N, k; breaks=[])\n\nDivides a list of indices from 1 to N into k groups.\n\nArguments\n\nN: (::Integer) number of elements to be ordered\nk: (::Integer) number of groups to divide the N elements.\n\nKeywords\n\nbreaks: (::Vector{<:Integer}, =[]) array of indices where predefined breakpoints are   placed.\n\nReturns\n\narray_of_ranges: (::Vector{UnitRange{<:Integer}}) array containing ranges of different   groups. The target is k groups, but this could increase by adding elements to the   breaks input array\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner","text":"PulseDesigner\n\nA module to define different pulse sequences.\n\n\n\n\n\n","category":"module"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_hard","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_hard","text":"seq = RF_hard(B1, T, sys; G=[0, 0, 0], Δf=0)\n\nReturns a sequence with a RF excitation pulse.\n\nArguments\n\nB1: (::Number, [T]) RF pulse amplitude\nT: (::Real, [s]) RF pulse duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_hard(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.RF_sinc","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.RF_sinc","text":"seq = RF_sinc(B1, T, sys; G=[0, 0, 0], Δf=0, a=0.46, TBP=4)\n\nReturns a sequence with a RF sinc waveform.\n\nReferences\n\nMatt A. Bernstein, Kevin F. King, Xiaohong Joe Zhou, Chapter 2 - Radiofrequency Pulse\n\nShapes, Handbook of MRI Pulse Sequences, 2004, Pages 35-66, https://doi.org/10.1016/B978-012092861-3/50006-6.\n\nArguments\n\nB1: (::Number, [T]) RF sinc amplitude\nT: (::Real, [s]) RF sinc duration\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (::Vector{Real}, =[0, 0, 0], [T/m]) gradient amplitudes for x, y, z\nΔf: (::Real, =0, [Hz]) RF pulse carrier frequency displacement\na: (::Real, =0.46) height appodization window parameter\nTBP: (::Real, =4) width appodization window parameter\n\nReturns\n\nseq: (::Sequence) Sequence struct with a RF pulse\n\nExamples\n\njulia> sys = Scanner(); durRF = π / 2 / (2π * γ * sys.B1);\n\njulia> seq = PulseDesigner.RF_sinc(sys.B1, durRF, sys);\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI","text":"seq = EPI(FOV::Real, N::Integer, sys::Scanner)\n\nReturns a sequence with EPI gradients.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels in the x and y axis\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct with EPI gradients\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.EPI(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.radial_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.radial_base","text":"seq = radial_base(FOV::Real, Nr::Integer, sys::Scanner)\n\nReturns a sequence with radial gradients for a single trajectory.\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the diameter\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) Sequence struct of a single radial trajectory\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> seq = PulseDesigner.radial_base(FOV, N, sys)\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.spiral_base","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.spiral_base","text":"spiral = spiral_base(FOV, N, sys; S0=sys.Smax*2/3, Nint=8, λ=Nint/FOV, BW=60e3)\n\nDefinition of a spiral base sequence.\n\nReferences\n\nGlover, G.H. (1999), Simple analytic spiral K-space algorithm. Magn. Reson. Med.,\n\n42: 412-415. https://doi.org/10.1002/(SICI)1522-2594(199908)42:2<412::AID-MRM25>3.0.CO;2-U\n\nArguments\n\nFOV: (::Real, [m]) field of view\nN: (::Integer) number of pixels along the radious\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nS0: (::Vector{Real}, =sys.Smax*2/3, [T/m/s]) slew rate reference\nNint: (::Integer, =8) number of interleaves\nλ: (::Real, =Nint/FOV, [1/m]) kspace spiral parameter\nBW: (::Real, =60e3, [Hz]) adquisition parameter\n\nReturns\n\nspiral: (::Function) function that returns a Sequence struct when evaluated\n\nExamples\n\njulia> sys, FOV, N = Scanner(), 23e-2, 101\n\njulia> spiral = PulseDesigner.spiral_base(FOV, N, sys)\n\njulia> seq = spiral(0)\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"reference/2-koma-base/#KomaMRIBase.PulseDesigner.EPI_example","page":"KomaMRIBase","title":"KomaMRIBase.PulseDesigner.EPI_example","text":"seq = EPI_example(; sys=Scanner())\n\nReturns a sequence suitable for acquiring the 2D brain example in the provided examples.\n\nKeywords\n\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) EPI example Sequence struct\n\nExamples\n\njulia> seq = PulseDesigner.EPI_example();\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"🏠 Home","title":"Introduction","text":"KomaMRI is a Julia package meant to simulate general Magnetic Resonance Imaging (MRI) scenarios. Its name comes from the Japanese word for spinning-top こま (ko-ma) as they precess due to gravity like spins in a magnetic field.\n\nKomaMRI generates raw data by solving the Bloch equations using the specified scanner, phantom and sequence. It also provides a Graphical User Interface (GUI) that encapsulates the whole imaging pipeline (simulation and reconstruction).\n\n<p align=\"center\"><img class=\"docs-light-only\" width=\"100%\" src=\"assets/koma-schema.svg\"/></p>\n<p align=\"center\"><img class=\"docs-dark-only\"  width=\"100%\" src=\"assets/koma-schema-dark.svg\"/></p>\n\nWe organized the documentation following the philosophy presented by David Laing.\n\ndetails: How to Cite Koma\nIf you use Koma, please cite our paper:Plain Text:Castillo-Passi, C, Coronado, R, Varela-Mattatall, G, Alberola-López, C, Botnar, R, Irarrazaval, P. KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration. Magn Reson Med. 2023; 1- 14. doi: 10.1002/mrm.29635BibTex:@article{https://doi.org/10.1002/mrm.29635,\n        author = {Castillo-Passi, Carlos and Coronado, Ronal and Varela-Mattatall, Gabriel and Alberola-López, Carlos and Botnar, René and Irarrazaval, Pablo},\n        title = {KomaMRI.jl: An open-source framework for general MRI simulations with GPU acceleration},\n        journal = {Magnetic Resonance in Medicine},\n        keywords = {Bloch equations, GPU, GUI, Julia, open source, simulation},\n        doi = {https://doi.org/10.1002/mrm.29635},\n        url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/mrm.29635},\n        eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/mrm.29635},\n}","category":"section"},{"location":"#Features","page":"🏠 Home","title":"Features","text":"Fast simulations by using CPU and GPU parallelization 🏃💨.\nOpen Source, so anyone can include additional features 🆙.\nCompatibility with community-standards 🤝 like Pulseq .seq and ISMRMRD .mrd.\nCompatibility with Pluto and Jupyter notebooks 🎈\nInteractive visualizations using PlotlyJS.jl 📲\nCross-platform 🌐 thanks to the use of the Julia programming language.\nFriendly user interface for people with no programming skills 😌.\nFlexible API for advanced users 👨‍💻.","category":"section"},{"location":"#Potential-Use-Cases","page":"🏠 Home","title":"Potential Use Cases","text":"The generation of synthetic data to train Machine Learning models.\nTo test novel pulse sequences before implementing them directly in a real scanner (with a Pulseq sequence).\nTeaching exercises for MRI acquisition or reconstruction.","category":"section"},{"location":"reference/1-api/#API-Overview","page":"API Overview","title":"API Overview","text":"<p align=\"center\"><img width=\"100%\" src=\"../../assets/koma-schema-subdirs.svg\"/></p>\n\nKomaMRI is divided into the following sub-packages:\n\nKomaMRIBase: Custom types and functions\nKomaMRICore: Simulation functions\nKomaMRIFiles: File I/O functions\nKomaMRIPlots: Plotting functions\nKomaMRI: User Interface\n\nThe idea of separating the package into sub-packages is to make it easier to maintain and to allow users to use only the parts they need. Two common use-cases can be:\n\nGUI users: They will use the KomaMRI package to interact with the GUI. Internally this includes al the others.\nAdvanced users: They will use the sub-packages directly to build their own scripts or notebooks, for simulation only KomaMRICore is required.","category":"section"},{"location":"tutorial/04-3DSliceSelective/#Slice-Selective-Acquisition-of-3D-Phantom","page":"Slice-Selective Acquisition of 3D Phantom","title":"Slice-Selective Acquisition of 3D Phantom","text":"(Image: ) (Image: ) (Image: )\n\nWhile in the previous examples we simulated using hard RF pulses, in this demonstration we will illustrate the principles of slice selection. First, let's import a 3D phantom, in this case a brain slab (thickness of 2mathrmcm), by calling the function brain_phantom3D.\n\nobj = brain_phantom3D()\nobj.Δw .= 0 # Removes the off-resonance\np1 = @suppress plot_phantom_map(obj, :T2 ; height=400)\n\n<center><object type=\"text/html\" data=\"../../assets/3-phantom.html\" style=\"width:50%; height:420px;\"></object></center>\n\nNow, we are going to import a sequence which acquires 3 slices in the longitudinal axis. Note that the sequence contains three EPIs to acquire 3 slices of the phantom.\n\nseq_file = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_multislice.seq\")\nseq = @suppress read_seq(seq_file)\np2 = plot_seq(seq; range=[0,10], height=400);\n\n<object type=\"text/html\" data=\"../../assets/3-seq.html\" style=\"width:100%; height:420px;\"></object>\n\nWe can take a look to the slice profiles by using the function simulate_slice_profile:\n\nz = range(-2., 2., 200) * 1e-2; # -2 to 2 cm\nrf1, rf2, rf3 = findall(is_RF_on.(seq))\nM1 = @suppress simulate_slice_profile(seq[rf1]; z)\nM2 = @suppress simulate_slice_profile(seq[rf2]; z)\nM3 = @suppress simulate_slice_profile(seq[rf3]; z);\n\n\n<object type=\"text/html\" data=\"../../assets/3-profile.html\" style=\"width:100%; height:320px;\"></object>\n\nNow let's simulate the acquisition. Notice the three echoes, one for every slice excitation.\n\nraw = @suppress simulate(obj, seq, sys; sim_params=Dict{String,Any}(\"Nblocks\"=>20))\np3 = plot_signal(raw; slider=false, height=300)\n\n<object type=\"text/html\" data=\"../../assets/3-signal.html\" style=\"width:100%; height:320px;\"></object>\n\nFinally, we reconstruct the acquiered images.\n\n# Get the acquisition data\nacq = AcquisitionData(raw)\n\n# Setting up the reconstruction parameters and perform reconstruction\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the slices\np4 = plot_image(abs.(image[:, :, 1]); height=360, title=\"Slice 1\")\np5 = plot_image(abs.(image[:, :, 2]); height=360, title=\"Slice 2\")\np6 = plot_image(abs.(image[:, :, 3]); height=360, title=\"Slice 3\")\n\n<object type=\"text/html\" data=\"../../assets/3-recon1.html\" style=\"width:50%; height:380px;\"></object><object type=\"text/html\" data=\"../../assets/3-recon2.html\" style=\"width:50%; height:380px;\"></object>\n\n<center><object type=\"text/html\" data=\"../../assets/3-recon3.html\" style=\"width:50%; height:380px;\"></object></center>\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
